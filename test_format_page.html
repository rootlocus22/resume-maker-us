<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/chunks/%5Broot-of-the-server%5D__de87d4e7._.css" data-precedence="next_static/chunks/[root-of-the-server]__de87d4e7._.css"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/%5Bturbopack%5D_browser_dev_hmr-client_hmr-client_ts_bae88007._.js"/><script src="/_next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js" async=""></script><script src="/_next/static/chunks/node_modules_next_dist_compiled_react-server-dom-turbopack_9212ccad._.js" async=""></script><script src="/_next/static/chunks/node_modules_next_dist_compiled_next-devtools_index_1dd7fb59.js" async=""></script><script src="/_next/static/chunks/node_modules_next_dist_compiled_a0e4c7b4._.js" async=""></script><script src="/_next/static/chunks/node_modules_next_dist_client_aaee43fe._.js" async=""></script><script src="/_next/static/chunks/node_modules_next_dist_7a8122d0._.js" async=""></script><script src="/_next/static/chunks/node_modules_%40swc_helpers_cjs_d80fb378._.js" async=""></script><script src="/_next/static/chunks/_a0ff3932._.js" async=""></script><script src="/_next/static/chunks/turbopack-_45210fd5._.js" async=""></script><script src="/_next/static/chunks/node_modules_next_dist_094231d7._.js" async=""></script><script src="/_next/static/chunks/app_favicon_ico_mjs_756560dc._.js" async=""></script><script src="/_next/static/chunks/node_modules_next_dist_client_components_builtin_global-error_78cdd4a3.js" async=""></script><script src="/_next/static/chunks/app_5c0ccaa8._.js" async=""></script><script src="/_next/static/chunks/node_modules_next_d56e9ccf._.js" async=""></script><script src="/_next/static/chunks/node_modules_%40firebase_auth_dist_esm2017_fc9ae2b4._.js" async=""></script><script src="/_next/static/chunks/node_modules_%40firebase_firestore_dist_index_esm2017_d9c36ae7.js" async=""></script><script src="/_next/static/chunks/node_modules_%40firebase_storage_dist_index_esm2017_46d20e3b.js" async=""></script><script src="/_next/static/chunks/node_modules_54207353._.js" async=""></script><script src="/_next/static/chunks/app_layout_78cdd4a3.js" async=""></script><script src="/_next/static/chunks/app_components_fe3de747._.js" async=""></script><script src="/_next/static/chunks/node_modules_lucide-react_dist_esm_icons_2df9fe07._.js" async=""></script><script src="/_next/static/chunks/app_resume-format-for_%5Bslug%5D_page_fb114cc8.js" async=""></script><meta name="next-size-adjust" content=""/><meta name="google-site-verification" content="MpKSykohaMeXQNw5vcppYGV5L8CMp_Qq32uZsc08Uz8"/><meta name="format-detection" content="telephone=no"/><meta name="theme-color" content="#1e3a8a"/><link rel="preconnect" href="https://va.vercel-scripts.com" crossorigin="anonymous"/><link rel="dns-prefetch" href="https://www.googletagmanager.com"/><link rel="dns-prefetch" href="https://www.google-analytics.com"/><link rel="dns-prefetch" href="https://firestore.googleapis.com"/><link rel="dns-prefetch" href="https://checkout.razorpay.com"/><link rel="preload" as="image" href="/resumegyani-logo-desktop-small.webp" type="image/webp" fetchPriority="high"/><link rel="preload" as="image" href="/resumegyani-logo-desktop-small.png" fetchPriority="high"/><link rel="icon" href="/favicon.ico" sizes="any"/><link rel="icon" href="/favicon.png" type="image/png"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"LayoutPage","mainEntity":[{"@type":"Question","name":"How do I create a professional resume for free?","acceptedAnswer":{"@type":"Answer","text":"You can use ResumeGyani, a free resume builder, to create a professional resume in minutes. Choose from ATS-friendly resume templates and download your resume as a PDF instantly."}},{"@type":"Question","name":"Are ResumeGyani templates ATS-friendly?","acceptedAnswer":{"@type":"Answer","text":"Yes! ResumeGyani provides ATS-friendly resume templates to ensure your resume is optimized for job application tracking systems."}},{"@type":"Question","name":"Can I download my resume as a PDF?","acceptedAnswer":{"@type":"Answer","text":"Absolutely! ResumeGyani allows you to download your resume as a PDF with just one click."}}]}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"Organization","name":"ResumeGyani","alternateName":"Resume Gyani","url":"https://resumegyani.in","logo":{"@type":"ImageObject","url":"https://resumegyani.in/resumegyani-logo-blue-transparent.png","width":"280","height":"96"},"description":"Free AI-powered resume builder for US job seekers. Create ATS-friendly resumes in 60 seconds with 50+ professional templates.","foundingDate":"2023","founder":{"@type":"Organization","name":"Nyquist Tech"},"areaServed":{"@type":"Country","name":"India"},"slogan":"Get 3x More Interviews with AI-Powered Resumes","sameAs":["https://www.linkedin.com/company/resumegyani/","https://twitter.com/nyquisttech","https://www.facebook.com/resumegyani","https://www.instagram.com/resumegyani"],"contactPoint":[{"@type":"ContactPoint","telephone":"+91-8431256903","contactType":"customer support","areaServed":["IN","US"],"availableLanguage":["English","Hindi"],"contactOption":"TollFree","availableTime":"Mo,Tu,We,Th,Fr 09:00-18:00"}],"address":{"@type":"PostalAddress","addressCountry":"IN","addressLocality":"India"},"aggregateRating":{"@type":"AggregateRating","ratingValue":"4.9","reviewCount":"50000","bestRating":"5","worstRating":"1"}}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"SoftwareApplication","name":"ResumeGyani","applicationCategory":"BusinessApplication","operatingSystem":"Web Browser","browserRequirements":"Requires JavaScript. Requires HTML5.","offers":{"@type":"Offer","price":"0","priceCurrency":"INR","availability":"https://schema.org/InStock","priceValidUntil":"2025-12-31","description":"Free plan available with premium options","seller":{"@type":"Organization","name":"ResumeGyani"}},"aggregateRating":{"@type":"AggregateRating","ratingValue":"4.9","reviewCount":"50000","bestRating":"5","worstRating":"1"},"author":{"@type":"Organization","name":"Nyquist Tech","url":"https://resumegyani.in"},"provider":{"@type":"Organization","name":"ResumeGyani"},"datePublished":"2023-01-01","dateModified":"2025-01-15","featureList":["AI-Powered Resume Builder","50+ ATS-Friendly Templates","Free ATS Score Checker","One-Page Resume Creator","Job Description Resume Builder","AI Bullet Point Generator","Salary Analyzer Tool","Interview Preparation Coach","Instant PDF Download","Mobile Responsive Builder"],"screenshot":"https://resumegyani.in/resumepreview.png","softwareVersion":"2.0","description":"Free AI-powered resume builder for US job seekers. Create ATS-friendly resumes in 60 seconds with professional templates, AI suggestions, and instant ATS scoring.","url":"https://resumegyani.in","inLanguage":["en","hi"],"audience":{"@type":"Audience","audienceType":"Job Seekers","geographicArea":{"@type":"AdministrativeArea","name":"India"}},"applicationSubCategory":"Resume Builder","downloadUrl":"https://resumegyani.in","installUrl":"https://resumegyani.in","permissions":"No installation required - Web based application"}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https://resumegyani.in"},{"@type":"ListItem","position":2,"name":"Resume Builder","item":"https://resumegyani.in/resume-builder"},{"@type":"ListItem","position":3,"name":"Templates","item":"https://resumegyani.in/templates"},{"@type":"ListItem","position":4,"name":"ATS Checker","item":"https://resumegyani.in/ats-score-checker"}]}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"WebSite","name":"ResumeGyani","alternateName":"Resume Gyani","url":"https://resumegyani.in","description":"Free AI-powered resume builder for US job seekers. Create ATS-friendly resumes with professional templates.","publisher":{"@type":"Organization","name":"ResumeGyani","logo":{"@type":"ImageObject","url":"https://resumegyani.in/resumegyani-logo-blue-transparent.png","width":"280","height":"96"}},"potentialAction":{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https://resumegyani.in/search?q={search_term_string}"},"query-input":"required name=search_term_string"}}</script><script src="/_next/static/chunks/node_modules_next_dist_build_polyfills_polyfill-nomodule.js" noModule=""></script></head><body class="poppins_62dcd493-module__8MNW6q__variable manrope_bf416764-module__ysqPka__variable antialiased bg-gradient-to-br from-gray-50 via-blue-50 to-teal-50 text-gray-900"><div hidden=""><!--$?--><template id="B:0"></template><!--/$--></div><!--$--><!--/$--><div id="_rht_toaster" style="position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none"></div><header style="height:72px" class="jsx-dc9dee5198da4ace bg-white/90 backdrop-blur-md shadow-xl sticky top-0 z-50 border-b border-blue-100/20"><div class="jsx-dc9dee5198da4ace max-w-8xl ml-[-1rem] mx-auto pl-0 pr-4 h-full flex items-center justify-between"><div class="jsx-dc9dee5198da4ace hidden md:flex items-center justify-between w-full h-full"><a class="flex items-center h-full py-2 hover:opacity-90 transition-opacity duration-200" href="/"><picture class="jsx-dc9dee5198da4ace"><source srcSet="/resumegyani-logo-desktop-small.webp" type="image/webp" class="jsx-dc9dee5198da4ace"/><img src="/resumegyani-logo-desktop-small.png" alt="ResumeGyani - Free AI Resume Builder India" width="200" height="127" fetchPriority="high" style="max-width:200px" decoding="async" class="jsx-dc9dee5198da4ace h-24 w-auto"/></picture></a><nav class="jsx-dc9dee5198da4ace flex-1 flex justify-center items-center h-full mx-2"><div class="jsx-dc9dee5198da4ace flex items-center space-x-1 h-full"><a class="h-full flex items-center px-3 text-gray-700 hover:text-blue-600 font-medium text-sm transition-colors duration-200 " href="/"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-house mr-1.5"><path d="M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8"></path><path d="M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path></svg>Home</a><div class="jsx-dc9dee5198da4ace relative h-full flex items-center"><button class="jsx-dc9dee5198da4ace h-full flex items-center px-3 text-gray-700 hover:text-blue-600 font-medium text-sm transition-colors duration-200 "><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-text mr-1.5"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"></path><path d="M14 2v4a2 2 0 0 0 2 2h4"></path><path d="M10 9H8"></path><path d="M16 13H8"></path><path d="M16 17H8"></path></svg>Resume Tools<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down ml-1"><path d="m6 9 6 6 6-6"></path></svg></button></div><div class="jsx-dc9dee5198da4ace relative h-full items-center hidden xl:flex"><button class="jsx-dc9dee5198da4ace h-full flex items-center px-3 text-gray-700 hover:text-blue-600 font-medium text-sm transition-colors duration-200 "><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open mr-1.5"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg>Resources<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down ml-1"><path d="m6 9 6 6 6-6"></path></svg></button></div><div class="jsx-dc9dee5198da4ace relative h-full items-center hidden xl:flex"><button class="jsx-dc9dee5198da4ace h-full flex items-center px-3 text-gray-700 hover:text-blue-600 font-medium text-sm transition-colors duration-200 "><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-settings mr-1.5"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>Other<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down ml-1"><path d="m6 9 6 6 6-6"></path></svg></button></div></div></nav><div class="jsx-dc9dee5198da4ace flex items-center gap-3 h-full"><a href="https://wa.me/918431256903?text=Hi%20ResumeGyani%20Team!%20%F0%9F%91%8B%0A%0AI&#x27;m%20visiting%20your%20website%20and%20would%20like%20assistance%20with%3A%0A%E2%80%A2%20Resume%20Building%20%26%20Optimization%0A%E2%80%A2%20ATS%20Score%20Improvement%0A%E2%80%A2%20Career%20Guidance%20%26%20Job%20Search%0A%E2%80%A2%20Premium%20Features%20%26%20Plans%0A%E2%80%A2%20Technical%20Support%0A%0APlease%20help%20me%20get%20started.%20Thank%20you!" target="_blank" rel="noopener noreferrer" title="Contact us on WhatsApp" class="jsx-dc9dee5198da4ace flex items-center gap-2 px-3 py-2 bg-[#25D366] hover:bg-[#20BA5A] text-white rounded-lg transition-colors duration-200 shadow-md hover:shadow-lg"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="jsx-dc9dee5198da4ace w-5 h-5 fill-current"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413z" class="jsx-dc9dee5198da4ace"></path></svg><span class="jsx-dc9dee5198da4ace hidden lg:inline text-sm font-medium">WhatsApp</span></a><div class="jsx-dc9dee5198da4ace relative h-full flex items-center"><div class="jsx-dc9dee5198da4ace flex items-center gap-2 h-full"><a class="hidden lg:flex items-center gap-1 bg-green-50 px-2 py-1 rounded-full border border-green-200 mr-2 hover:bg-green-100 transition-colors cursor-pointer" href="/resume-builder"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-check-big text-green-600"><path d="M21.801 10A10 10 0 1 1 17 3.335"></path><path d="m9 11 3 3L22 4"></path></svg><span class="jsx-dc9dee5198da4ace text-[10px] font-bold text-green-700">Build for Free</span></a><a class="px-3 py-1.5 text-gray-700 hover:text-blue-600 font-medium text-sm transition-colors duration-200" href="/login">Sign In</a><a class="px-3 py-1.5 bg-gradient-to-br from-blue-600 to-blue-500 text-white font-medium text-sm rounded-full transition-colors duration-200 shadow-sm hover:shadow-md" href="/signup">Sign Up</a></div></div></div></div><div class="jsx-dc9dee5198da4ace md:hidden flex items-center justify-between w-full h-full"><a class="flex items-center h-full hover:opacity-90 transition-opacity duration-200" href="/"><picture class="jsx-dc9dee5198da4ace"><source srcSet="/resumegyani-logo-mobile.webp" type="image/webp" class="jsx-dc9dee5198da4ace"/><img src="/resumegyani-logo-mobile.png" alt="ResumeGyani - Free AI Resume Builder India" width="220" height="140" fetchPriority="high" style="max-width:220px" decoding="async" class="jsx-dc9dee5198da4ace h-24 w-auto"/></picture></a><div class="jsx-dc9dee5198da4ace flex items-center gap-2"><a href="https://wa.me/918431256903?text=Hi%20ResumeGyani%20Team!%20%F0%9F%91%8B%0A%0AI&#x27;m%20visiting%20your%20website%20and%20would%20like%20assistance%20with%3A%0A%E2%80%A2%20Resume%20Building%20%26%20Optimization%0A%E2%80%A2%20ATS%20Score%20Improvement%0A%E2%80%A2%20Career%20Guidance%20%26%20Job%20Search%0A%E2%80%A2%20Premium%20Features%20%26%20Plans%0A%E2%80%A2%20Technical%20Support%0A%0APlease%20help%20me%20get%20started.%20Thank%20you!" target="_blank" rel="noopener noreferrer" title="Contact us on WhatsApp" class="jsx-dc9dee5198da4ace flex items-center justify-center w-9 h-9 bg-[#25D366] hover:bg-[#20BA5A] text-white rounded-lg transition-colors duration-200 shadow-md"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="jsx-dc9dee5198da4ace w-5 h-5 fill-current"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413z" class="jsx-dc9dee5198da4ace"></path></svg></a><div class="jsx-dc9dee5198da4ace relative h-full flex items-center"><a class="px-3 py-1.5 text-gray-700 hover:text-blue-600 font-medium text-sm transition-colors duration-200" href="/login">Sign In</a></div><button aria-label="Toggle menu" class="jsx-dc9dee5198da4ace w-10 h-10 flex items-center justify-center text-gray-700 hover:bg-blue-50 hover:text-blue-600 transition-all duration-200 rounded-lg active:scale-95"><svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="jsx-dc9dee5198da4ace w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" class="jsx-dc9dee5198da4ace"></path></svg></button></div></div></div></header><main class="flex-1 w-full overflow-y-auto min-h-screen relative"><div class="relative z-100"><script type="application/ld+json">{"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"How do I write a resume for a Project Manager?","acceptedAnswer":{"@type":"Answer","text":"Focus on your relevant experience and specific achievements. Use a reverse-chronological format."}},{"@type":"Question","name":"What skills are required for a Project Manager?","acceptedAnswer":{"@type":"Answer","text":"Key skills include technical proficiency in your domain, problem-solving, and communication."}}]}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Project Manager Resume Format (2026) | Download Free Template","description":"Download professional Project Manager resume format. Get salary insights, career path, and expert tips for Project Manager jobs in India.","author":{"@type":"Organization","name":"ResumeGyani","url":"https://resumegyani.in"},"publisher":{"@type":"Organization","name":"ResumeGyani","logo":{"@type":"ImageObject","url":"https://resumegyani.in/resumegyani-logo-blue-transparent.png"}},"datePublished":"2025-01-01","dateModified":"2025-01-01","mainEntityOfPage":{"@type":"WebPage","@id":"https://resumegyani.in/resume-format-for/project-manager-resume-india"}}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https://resumegyani.in"},{"@type":"ListItem","position":2,"name":"Resume Formats","item":"https://resumegyani.in/resume-format-for"},{"@type":"ListItem","position":3,"name":"Project Manager","item":"https://resumegyani.in/resume-format-for/project-manager-resume-india"}]}</script><div class="min-h-screen bg-gradient-to-b from-white to-gray-50"><section class="relative pt-20 pb-12 overflow-hidden"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 relative z-10"><div class="text-center max-w-3xl mx-auto"><div class="inline-flex items-center gap-2 bg-blue-50 text-blue-700 px-4 py-2 rounded-full mb-6 border border-blue-100"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-target w-4 h-4"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg><span class="font-semibold text-sm">ATS-Optimized for India</span></div><h1 class="text-4xl md:text-5xl lg:text-6xl font-bold text-gray-900 mb-6 leading-tight">Project Manager<!-- --> <span class="text-blue-600">Resume Format</span></h1><p class="text-xl text-gray-600 mb-8 leading-relaxed">Download professional Project Manager resume format. Get salary insights, career path, and expert tips for Project Manager jobs in India.</p><div class="flex flex-col sm:flex-row gap-4 justify-center items-center mb-12"><a class="w-full sm:w-auto px-8 py-4 bg-blue-600 text-white rounded-xl font-bold text-lg hover:bg-blue-700 transition-all shadow-lg hover:shadow-blue-200 flex items-center justify-center gap-2" href="/resume-builder"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-text w-5 h-5"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"></path><path d="M14 2v4a2 2 0 0 0 2 2h4"></path><path d="M10 9H8"></path><path d="M16 13H8"></path><path d="M16 17H8"></path></svg>Create My Resume</a><a class="w-full sm:w-auto px-8 py-4 bg-white text-gray-700 border-2 border-gray-200 rounded-xl font-bold text-lg hover:border-blue-200 hover:bg-blue-50 transition-all flex items-center justify-center gap-2" href="/resumes-list">View All Formats<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right w-5 h-5"><path d="M5 12h14"></path><path d="m12 5 7 7-7 7"></path></svg></a></div></div></div><div class="absolute top-0 left-0 w-full h-full overflow-hidden -z-0 opacity-40"><div class="absolute top-0 right-0 w-96 h-96 bg-blue-100 rounded-full blur-3xl transform translate-x-1/2 -translate-y-1/2"></div><div class="absolute bottom-0 left-0 w-96 h-96 bg-purple-100 rounded-full blur-3xl transform -translate-x-1/2 translate-y-1/2"></div></div></section><section class="py-12 bg-white border-b border-gray-200"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="grid grid-cols-2 md:grid-cols-4 gap-6"><div class="text-center"><div class="text-2xl font-bold text-gray-900">â‚¹15L - â‚¹35L</div><div class="text-sm text-gray-600">Avg Salary (India)</div></div><div class="text-center"><div class="text-2xl font-bold text-gray-900">Mid-Senior</div><div class="text-sm text-gray-600">Experience Level</div></div><div class="text-center"><div class="text-2xl font-bold text-gray-900">4<!-- -->+</div><div class="text-sm text-gray-600">Key Skills</div></div><div class="text-center"><div class="text-2xl font-bold text-gray-900">ATS</div><div class="text-sm text-gray-600">Optimized</div></div></div></div></section><section class="py-16 bg-gradient-to-b from-gray-50 to-white"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="max-w-4xl mx-auto"><div class="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-2xl p-8 border-2 border-blue-200"><div class="flex items-start gap-4 mb-4"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-text w-8 h-8 text-blue-600 flex-shrink-0 mt-1"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"></path><path d="M14 2v4a2 2 0 0 0 2 2h4"></path><path d="M10 9H8"></path><path d="M16 13H8"></path><path d="M16 17H8"></path></svg><div><h2 class="text-2xl font-bold text-gray-900 mb-3">Copy-Paste Professional Summary</h2><p class="text-gray-700 leading-relaxed mb-4">Use this professional summary for your <strong>Project Manager</strong> resume:</p><div class="bg-white rounded-xl p-6 border-l-4 border-blue-600 shadow-sm relative"><p class="text-gray-800 leading-relaxed italic">&quot;<!-- -->Passionate Project Manager seeking to leverage extensive background in enhancing business performance to contribute to organizational success.<!-- -->&quot;</p></div><button class="mt-4 text-blue-600 text-sm font-medium hover:underline flex items-center gap-2 transition-colors"><span>ðŸ“‹</span><span>Copy to clipboard</span></button><p class="text-sm text-gray-600 mt-2">ðŸ’¡ <strong>Tip:</strong> Customize this summary with your specific achievements and years of experience.</p></div></div></div></div></div></section><section class="py-16 bg-white"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="max-w-4xl mx-auto"><div class="bg-white rounded-2xl p-8 border-2 border-indigo-100 shadow-xl relative overflow-hidden"><div class="absolute top-0 right-0 w-32 h-32 bg-indigo-50 rounded-bl-full -mr-16 -mt-16 opacity-50"></div><div class="flex items-start gap-6 relative z-10"><div class="bg-indigo-100 p-3 rounded-full"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock w-8 h-8 text-indigo-600"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg></div><div><h2 class="text-3xl font-bold text-gray-900 mb-4">A Day in the Life of a <!-- -->Project Manager</h2><p class="text-lg text-gray-700 leading-relaxed">A typical day as a Project Manager is dynamic and engaging. You start by planning project timelines to set the tone for the day. Mid-day often involves planning project timelines and developing strategic roadmaps, ensuring alignment with team goals. In the afternoon, you focus on reviewing budget reports, which is critical for project success. The day wraps up with analyzing performance metrics to prepare for the next day&#x27;s challenges.</p></div></div></div></div></div></section><section class="py-16 bg-gradient-to-b from-white to-gray-50"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="text-center mb-12"><h2 class="text-4xl font-bold text-gray-900 mb-4">Career Roadmap</h2><p class="text-xl text-gray-600">Typical career progression for a <!-- -->Project Manager</p></div><div class="max-w-5xl mx-auto"><div class="flex flex-col md:flex-row justify-between items-center relative"><div class="hidden md:block absolute top-1/2 left-0 w-full h-1 bg-gray-200 -z-10 transform -translate-y-1/2"></div><div class="flex flex-col items-center mb-8 md:mb-0 relative group"><div class="w-12 h-12 rounded-full bg-white border-4 border-blue-600 flex items-center justify-center mb-4 shadow-md group-hover:scale-110 transition-transform"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trending-up w-6 h-6 text-blue-600"><polyline points="22 7 13.5 15.5 8.5 10.5 2 17"></polyline><polyline points="16 7 22 7 22 13"></polyline></svg></div><div class="bg-white p-4 rounded-xl border border-gray-200 shadow-sm text-center w-48 hover:shadow-md transition-shadow"><p class="font-bold text-gray-900">Project Manager</p></div></div><div class="flex flex-col items-center mb-8 md:mb-0 relative group"><div class="w-12 h-12 rounded-full bg-white border-4 border-blue-600 flex items-center justify-center mb-4 shadow-md group-hover:scale-110 transition-transform"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trending-up w-6 h-6 text-blue-600"><polyline points="22 7 13.5 15.5 8.5 10.5 2 17"></polyline><polyline points="16 7 22 7 22 13"></polyline></svg></div><div class="bg-white p-4 rounded-xl border border-gray-200 shadow-sm text-center w-48 hover:shadow-md transition-shadow"><p class="font-bold text-gray-900">Lead Manager</p></div></div><div class="flex flex-col items-center mb-8 md:mb-0 relative group"><div class="w-12 h-12 rounded-full bg-white border-4 border-blue-600 flex items-center justify-center mb-4 shadow-md group-hover:scale-110 transition-transform"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trending-up w-6 h-6 text-blue-600"><polyline points="22 7 13.5 15.5 8.5 10.5 2 17"></polyline><polyline points="16 7 22 7 22 13"></polyline></svg></div><div class="bg-white p-4 rounded-xl border border-gray-200 shadow-sm text-center w-48 hover:shadow-md transition-shadow"><p class="font-bold text-gray-900">Principal Manager</p></div></div></div></div></div></section><section class="py-16 bg-white"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="text-center mb-12"><h2 class="text-4xl font-bold text-gray-900 mb-4">Essential Skills for <!-- -->Project Manager</h2><p class="text-xl text-gray-600">Google uses these entities to understand relevance. Make sure to include these in your resume.</p></div><div class="grid md:grid-cols-2 gap-8 max-w-5xl mx-auto"><div class="bg-gradient-to-br from-blue-50 to-indigo-50 rounded-2xl p-8 border-2 border-blue-200"><div class="flex items-center gap-3 mb-6"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zap w-8 h-8 text-blue-600"><path d="M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z"></path></svg><h3 class="text-2xl font-bold text-gray-900">Hard Skills</h3></div><div class="flex flex-wrap gap-3"><span class="bg-white text-blue-700 px-4 py-2 rounded-full text-sm font-semibold border border-blue-200 shadow-sm hover:shadow-md transition-shadow">Project Expertise</span><span class="bg-white text-blue-700 px-4 py-2 rounded-full text-sm font-semibold border border-blue-200 shadow-sm hover:shadow-md transition-shadow">Project Management</span><span class="bg-white text-blue-700 px-4 py-2 rounded-full text-sm font-semibold border border-blue-200 shadow-sm hover:shadow-md transition-shadow">Communication</span><span class="bg-white text-blue-700 px-4 py-2 rounded-full text-sm font-semibold border border-blue-200 shadow-sm hover:shadow-md transition-shadow">Problem Solving</span></div></div><div class="bg-gradient-to-br from-purple-50 to-pink-50 rounded-2xl p-8 border-2 border-purple-200"><div class="flex items-center gap-3 mb-6"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users w-8 h-8 text-purple-600"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg><h3 class="text-2xl font-bold text-gray-900">Soft Skills</h3></div><div class="flex flex-wrap gap-3"><span class="bg-white text-purple-700 px-4 py-2 rounded-full text-sm font-semibold border border-purple-200 shadow-sm hover:shadow-md transition-shadow">Leadership</span><span class="bg-white text-purple-700 px-4 py-2 rounded-full text-sm font-semibold border border-purple-200 shadow-sm hover:shadow-md transition-shadow">Teamwork</span><span class="bg-white text-purple-700 px-4 py-2 rounded-full text-sm font-semibold border border-purple-200 shadow-sm hover:shadow-md transition-shadow">Adaptability</span><span class="bg-white text-purple-700 px-4 py-2 rounded-full text-sm font-semibold border border-purple-200 shadow-sm hover:shadow-md transition-shadow">Time Management</span><span class="bg-white text-purple-700 px-4 py-2 rounded-full text-sm font-semibold border border-purple-200 shadow-sm hover:shadow-md transition-shadow">Critical Thinking</span></div></div></div></div></section><section class="py-16 bg-white"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="text-center mb-12"><h2 class="text-4xl font-bold text-gray-900 mb-4">Salary Insights</h2><p class="text-xl text-gray-600">Market standards for <!-- -->Project Manager<!-- --> in India</p></div><div class="grid md:grid-cols-3 gap-6 max-w-5xl mx-auto"><div class="bg-green-50 rounded-xl p-6 border border-green-200 text-center"><div class="text-lg font-semibold text-green-800 mb-2">Entry Level</div><div class="text-3xl font-bold text-green-900">â‚¹13L - â‚¹15L</div><div class="text-sm text-green-600 mt-2">0-2 Years</div></div><div class="bg-blue-50 rounded-xl p-6 border-2 border-blue-500 transform scale-105 shadow-lg text-center relative"><div class="absolute top-0 right-0 bg-blue-600 text-white text-xs px-2 py-1 rounded-bl-lg font-bold">AVG</div><div class="text-lg font-semibold text-blue-800 mb-2">Mid Level</div><div class="text-3xl font-bold text-blue-900">â‚¹15L - â‚¹35L</div><div class="text-sm text-blue-600 mt-2">3-8 Years</div></div><div class="bg-purple-50 rounded-xl p-6 border border-purple-200 text-center"><div class="text-lg font-semibold text-purple-800 mb-2">Senior Level</div><div class="text-3xl font-bold text-purple-900">â‚¹35L - â‚¹50L+</div><div class="text-sm text-purple-600 mt-2">8+ Years</div></div></div></div></section><section class="py-16 bg-gradient-to-b from-gray-50 to-white"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="text-center mb-12"><h2 class="text-4xl font-bold text-gray-900 mb-4">Tech Stack We Recommend</h2><p class="text-xl text-gray-600">Tools you should master</p></div><div class="max-w-5xl mx-auto grid md:grid-cols-2 gap-8"><div class="bg-white rounded-xl p-6 shadow-sm border border-gray-100"><div class="flex items-center gap-3 mb-4 border-b border-gray-100 pb-3"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-layers w-6 h-6 text-indigo-600"><path d="M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z"></path><path d="M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12"></path><path d="M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17"></path></svg><h3 class="text-xl font-bold text-gray-800">Essential Tools</h3></div><div class="flex flex-wrap gap-2"><span class="bg-gray-100 text-gray-700 px-3 py-1 rounded-md text-sm font-medium">JIRA</span><span class="bg-gray-100 text-gray-700 px-3 py-1 rounded-md text-sm font-medium">Slack</span><span class="bg-gray-100 text-gray-700 px-3 py-1 rounded-md text-sm font-medium">Microsoft Office</span><span class="bg-gray-100 text-gray-700 px-3 py-1 rounded-md text-sm font-medium">Zoom</span></div></div><div class="bg-white rounded-xl p-6 shadow-sm border border-gray-100"><div class="flex items-center gap-3 mb-4 border-b border-gray-100 pb-3"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-layers w-6 h-6 text-indigo-600"><path d="M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z"></path><path d="M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12"></path><path d="M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17"></path></svg><h3 class="text-xl font-bold text-gray-800">Domain Skills</h3></div><div class="flex flex-wrap gap-2"><span class="bg-gray-100 text-gray-700 px-3 py-1 rounded-md text-sm font-medium">Core Competency A</span><span class="bg-gray-100 text-gray-700 px-3 py-1 rounded-md text-sm font-medium">Core Competency B</span></div></div></div></div></section><section class="py-16 bg-white"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="max-w-4xl mx-auto"><div class="bg-yellow-50 rounded-2xl p-8 border-2 border-yellow-200"><div class="flex items-start gap-4"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-award w-10 h-10 text-yellow-600 flex-shrink-0"><path d="m15.477 12.89 1.515 8.526a.5.5 0 0 1-.81.47l-3.58-2.687a1 1 0 0 0-1.197 0l-3.586 2.686a.5.5 0 0 1-.81-.469l1.514-8.526"></path><circle cx="12" cy="8" r="6"></circle></svg><div class="w-full"><h2 class="text-2xl font-bold text-gray-900 mb-6">Top Certifications to Boost Your Profile</h2><div class="grid gap-4"><div class="bg-white p-4 rounded-lg shadow-sm border border-yellow-100 flex items-center justify-between"><span class="font-semibold text-gray-800">Certified Manager Professional</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-check-big w-5 h-5 text-yellow-500"><path d="M21.801 10A10 10 0 1 1 17 3.335"></path><path d="m9 11 3 3L22 4"></path></svg></div><div class="bg-white p-4 rounded-lg shadow-sm border border-yellow-100 flex items-center justify-between"><span class="font-semibold text-gray-800">Project Management Professional (PMP)</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-check-big w-5 h-5 text-yellow-500"><path d="M21.801 10A10 10 0 1 1 17 3.335"></path><path d="m9 11 3 3L22 4"></path></svg></div></div></div></div></div></div></div></section><section class="py-16 bg-gradient-to-b from-red-50 to-orange-50"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="max-w-4xl mx-auto"><div class="bg-white rounded-2xl p-8 border-2 border-red-200 shadow-lg"><div class="flex items-start gap-4 mb-6"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-triangle-alert w-10 h-10 text-red-600 flex-shrink-0"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3"></path><path d="M12 9v4"></path><path d="M12 17h.01"></path></svg><div><h2 class="text-3xl font-bold text-gray-900 mb-4">Common Mistakes to Avoid</h2><p class="text-lg text-gray-700 leading-relaxed">Using generic templates that don&#x27;t highlight specific Project Manager achievements. Failing to quantify results (e.g., &#x27;improved efficiency by 20%&#x27;).</p></div></div></div></div></div></section><section class="py-16 bg-white"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="max-w-4xl mx-auto"><div class="text-center mb-12"><div class="inline-flex items-center gap-2 bg-green-100 text-green-700 px-4 py-2 rounded-full mb-4"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chart-no-axes-column w-5 h-5"><line x1="18" x2="18" y1="20" y2="10"></line><line x1="12" x2="12" y1="20" y2="4"></line><line x1="6" x2="6" y1="20" y2="14"></line></svg><span class="text-sm font-semibold">ATS Optimization Tips</span></div><h2 class="text-4xl font-bold text-gray-900 mb-4">How to Pass ATS Filters</h2></div><div class="grid md:grid-cols-2 gap-6"><div class="bg-gradient-to-br from-green-50 to-emerald-50 rounded-xl p-6 border-2 border-green-200"><div class="flex items-start gap-3"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-check-big w-6 h-6 text-green-600 flex-shrink-0 mt-1"><path d="M21.801 10A10 10 0 1 1 17 3.335"></path><path d="m9 11 3 3L22 4"></path></svg><p class="text-gray-800 leading-relaxed">Use standard fonts</p></div></div><div class="bg-gradient-to-br from-green-50 to-emerald-50 rounded-xl p-6 border-2 border-green-200"><div class="flex items-start gap-3"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-check-big w-6 h-6 text-green-600 flex-shrink-0 mt-1"><path d="M21.801 10A10 10 0 1 1 17 3.335"></path><path d="m9 11 3 3L22 4"></path></svg><p class="text-gray-800 leading-relaxed">Include relevant keywords</p></div></div><div class="bg-gradient-to-br from-green-50 to-emerald-50 rounded-xl p-6 border-2 border-green-200"><div class="flex items-start gap-3"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-check-big w-6 h-6 text-green-600 flex-shrink-0 mt-1"><path d="M21.801 10A10 10 0 1 1 17 3.335"></path><path d="m9 11 3 3L22 4"></path></svg><p class="text-gray-800 leading-relaxed">Save as PDF</p></div></div></div></div></div></section><section class="py-16 bg-gradient-to-b from-gray-50 to-white"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="max-w-4xl mx-auto"><div class="bg-gradient-to-r from-indigo-50 to-purple-50 rounded-2xl p-8 border-2 border-indigo-200"><div class="flex items-start gap-4"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-briefcase w-10 h-10 text-indigo-600 flex-shrink-0"><path d="M16 20V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path><rect width="20" height="14" x="2" y="6" rx="2"></rect></svg><div><h2 class="text-2xl font-bold text-gray-900 mb-4">Industry Context</h2><p class="text-gray-700 leading-relaxed text-lg">The demand for Project Manager professionals is growing rapidly in India&#x27;s evolving market.</p></div></div></div></div></div></section><section class="py-16 bg-white"><div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8"><div class="text-center mb-12"><h2 class="text-4xl font-bold text-gray-900 mb-4">Frequently Asked Questions</h2><p class="text-xl text-gray-600">Common questions about <!-- -->Project Manager<!-- --> resumes in India</p></div><div class="space-y-6"><div class="bg-white rounded-xl p-6 shadow-sm border border-gray-200 hover:shadow-md transition-shadow"><h3 class="text-lg font-bold text-gray-900 mb-3">How do I write a resume for a Project Manager?</h3><p class="text-gray-700 leading-relaxed">Focus on your relevant experience and specific achievements. Use a reverse-chronological format.</p></div><div class="bg-white rounded-xl p-6 shadow-sm border border-gray-200 hover:shadow-md transition-shadow"><h3 class="text-lg font-bold text-gray-900 mb-3">What skills are required for a Project Manager?</h3><p class="text-gray-700 leading-relaxed">Key skills include technical proficiency in your domain, problem-solving, and communication.</p></div></div></div></section><section class="py-16 bg-gradient-to-b from-gray-50 to-white"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="text-center mb-12"><h2 class="text-4xl font-bold text-gray-900 mb-4">Similar Resume Templates</h2><p class="text-xl text-gray-600">Explore resume formats for related roles</p></div><div class="grid md:grid-cols-2 lg:grid-cols-3 gap-6"><a class="group bg-white rounded-xl p-6 border-2 border-gray-200 hover:border-blue-500 hover:shadow-lg transition-all duration-300" href="/resume-format-for/operations-manager-resume-india"><div class="flex items-start justify-between mb-3"><h3 class="text-lg font-bold text-gray-900 group-hover:text-blue-600 transition-colors">Operations Manager</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right w-5 h-5 text-gray-400 group-hover:text-blue-600 group-hover:translate-x-1 transition-all"><path d="M5 12h14"></path><path d="m12 5 7 7-7 7"></path></svg></div><p class="text-sm text-gray-600 mb-3">Mid-Senior<!-- --> â€¢ <!-- -->â‚¹8L - â‚¹20L</p><div class="flex flex-wrap gap-2"><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Operations Management</span><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Process Improvement</span><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Supply Chain</span></div></a><a class="group bg-white rounded-xl p-6 border-2 border-gray-200 hover:border-blue-500 hover:shadow-lg transition-all duration-300" href="/resume-format-for/supply-chain-manager-resume-india"><div class="flex items-start justify-between mb-3"><h3 class="text-lg font-bold text-gray-900 group-hover:text-blue-600 transition-colors">Supply Chain Manager</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right w-5 h-5 text-gray-400 group-hover:text-blue-600 group-hover:translate-x-1 transition-all"><path d="M5 12h14"></path><path d="m12 5 7 7-7 7"></path></svg></div><p class="text-sm text-gray-600 mb-3">Mid-Senior<!-- --> â€¢ <!-- -->â‚¹8L - â‚¹20L</p><div class="flex flex-wrap gap-2"><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Supply Chain Management</span><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Logistics</span><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Inventory Management</span></div></a><a class="group bg-white rounded-xl p-6 border-2 border-gray-200 hover:border-blue-500 hover:shadow-lg transition-all duration-300" href="/resume-format-for/java-developer-resume-india"><div class="flex items-start justify-between mb-3"><h3 class="text-lg font-bold text-gray-900 group-hover:text-blue-600 transition-colors">Java Developer</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right w-5 h-5 text-gray-400 group-hover:text-blue-600 group-hover:translate-x-1 transition-all"><path d="M5 12h14"></path><path d="m12 5 7 7-7 7"></path></svg></div><p class="text-sm text-gray-600 mb-3">Mid-Senior<!-- --> â€¢ <!-- -->â‚¹6L - â‚¹20L</p><div class="flex flex-wrap gap-2"><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Java 8/11/17</span><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Spring Boot</span><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Hibernate/JPA</span></div></a><a class="group bg-white rounded-xl p-6 border-2 border-gray-200 hover:border-blue-500 hover:shadow-lg transition-all duration-300" href="/resume-format-for/python-developer-resume-india"><div class="flex items-start justify-between mb-3"><h3 class="text-lg font-bold text-gray-900 group-hover:text-blue-600 transition-colors">Python Developer</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right w-5 h-5 text-gray-400 group-hover:text-blue-600 group-hover:translate-x-1 transition-all"><path d="M5 12h14"></path><path d="m12 5 7 7-7 7"></path></svg></div><p class="text-sm text-gray-600 mb-3">Mid-Senior<!-- --> â€¢ <!-- -->â‚¹7L - â‚¹25L</p><div class="flex flex-wrap gap-2"><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Python 3.x</span><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Django/Flask/FastAPI</span><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">RESTful APIs</span></div></a><a class="group bg-white rounded-xl p-6 border-2 border-gray-200 hover:border-blue-500 hover:shadow-lg transition-all duration-300" href="/resume-format-for/mern-stack-developer-resume-india"><div class="flex items-start justify-between mb-3"><h3 class="text-lg font-bold text-gray-900 group-hover:text-blue-600 transition-colors">MERN Stack Developer</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right w-5 h-5 text-gray-400 group-hover:text-blue-600 group-hover:translate-x-1 transition-all"><path d="M5 12h14"></path><path d="m12 5 7 7-7 7"></path></svg></div><p class="text-sm text-gray-600 mb-3">Mid-Senior<!-- --> â€¢ <!-- -->â‚¹8L - â‚¹22L</p><div class="flex flex-wrap gap-2"><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">React.js</span><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Node.js</span><span class="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded-full">Express.js</span></div></a></div></div></section><section class="py-20 bg-gradient-to-br from-blue-600 via-indigo-600 to-purple-600 text-white"><div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 text-center"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-award w-16 h-16 mx-auto mb-6 text-yellow-300"><path d="m15.477 12.89 1.515 8.526a.5.5 0 0 1-.81.47l-3.58-2.687a1 1 0 0 0-1.197 0l-3.586 2.686a.5.5 0 0 1-.81-.469l1.514-8.526"></path><circle cx="12" cy="8" r="6"></circle></svg><h2 class="text-4xl sm:text-5xl font-bold mb-6">Ready to Build Your <!-- -->Project Manager<!-- --> Resume?</h2><p class="text-xl text-blue-100 mb-8 max-w-2xl mx-auto">Use our AI-powered resume builder to create an ATS-optimized resume in minutes. Get instant suggestions, professional templates, and guaranteed 90%+ ATS score.</p><div class="flex flex-col sm:flex-row gap-4 justify-center items-center"><a class="group bg-white text-blue-600 px-8 py-4 rounded-full font-bold text-lg hover:bg-yellow-300 hover:text-blue-700 transition-all duration-300 shadow-2xl hover:shadow-yellow-300/50 flex items-center gap-2" href="/resume-builder"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-text w-6 h-6"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"></path><path d="M14 2v4a2 2 0 0 0 2 2h4"></path><path d="M10 9H8"></path><path d="M16 13H8"></path><path d="M16 17H8"></path></svg>Build Resume Now<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right w-5 h-5 group-hover:translate-x-1 transition-transform"><path d="M5 12h14"></path><path d="m12 5 7 7-7 7"></path></svg></a><a class="bg-transparent border-2 border-white text-white px-8 py-4 rounded-full font-bold text-lg hover:bg-white hover:text-blue-600 transition-all duration-300" href="/free-ats-resume-checker-india">Check ATS Score</a></div></div></section></div><!--$?--><template id="B:1"></template><!--/$--></div></main><footer class="relative bg-gradient-to-br from-blue-900 via-blue-800 to-indigo-900 text-white"><div class="absolute inset-0 bg-gradient-to-br from-blue-900/10 via-transparent to-indigo-900/10"></div><div class="absolute inset-0 bg-gradient-to-t from-blue-900/90 to-transparent"></div><div class="relative max-w-7xl mx-auto px-3 sm:px-6 lg:px-8 py-6 sm:py-12"><div class="mb-6 sm:mb-10 pb-4 sm:pb-8 border-b border-blue-700"><div class="flex flex-col items-center text-center md:flex-row md:items-center md:justify-between md:text-left gap-3 sm:gap-6"><div class="flex flex-col items-center md:items-start gap-2"><img alt="ResumeGyani - Free AI Resume Builder India" loading="lazy" width="300" height="191" decoding="async" data-nimg="1" class="h-20 sm:h-24 md:h-28 lg:h-32 w-auto" style="color:transparent;max-width:280px" srcSet="/_next/image?url=%2Fresumegyani-footer-logo.png&amp;w=384&amp;q=75 1x, /_next/image?url=%2Fresumegyani-footer-logo.png&amp;w=640&amp;q=75 2x" src="/_next/image?url=%2Fresumegyani-footer-logo.png&amp;w=640&amp;q=75"/><div class="flex items-center gap-1.5 md:hidden"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star text-yellow-400"><path d="M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"></path></svg><span class="text-xs text-white font-medium">Trusted by 100,000+ Job Seekers</span></div></div><div class="hidden md:flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star text-yellow-400"><path d="M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"></path></svg><span class="text-xs sm:text-sm text-white font-medium">Trusted by 100,000+ Job Seekers</span></div></div><p class="text-blue-200 text-xs sm:text-sm leading-relaxed mt-3 sm:mt-4 max-w-2xl text-center md:text-left">Create professional, ATS-friendly resumes with our AI-powered resume builder. Get hired 3x faster with optimized templates and smart suggestions.</p></div><div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-x-4 gap-y-4 sm:gap-6 lg:gap-8 mb-6 sm:mb-10"><div class="space-y-1.5 sm:space-y-3"><h4 class="font-semibold text-xs sm:text-sm lg:text-base text-white mb-1.5 sm:mb-3 pb-1 sm:pb-2 border-b border-blue-700">Resume Tools</h4><ul class="space-y-1 sm:space-y-2"><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/resume-builder">Resume Builder</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/ats-score-checker">ATS Checker</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/upload-resume">Upload Resume</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/templates">Templates</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/cover-letter-builder">Cover Letter</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/cv-maker-india">CV Maker India</a></li></ul></div><div class="space-y-1.5 sm:space-y-3"><h4 class="font-semibold text-xs sm:text-sm lg:text-base text-white mb-1.5 sm:mb-3 pb-1 sm:pb-2 border-b border-blue-700">By Role</h4><ul class="space-y-1 sm:space-y-2"><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block font-semibold" href="/resume-format-for">Browse Resume Formats (7000+)</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/resume-builder-software-engineer">Software Engineer</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/resume-format-freshers-india">Freshers</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/resume-builder-it-professionals">IT Professionals</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/resume-builder-mba-freshers">MBA Freshers</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/resume-builder-college-students">Students</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/resume-format-for-freshers">Fresher Formats</a></li></ul></div><div class="space-y-1.5 sm:space-y-3"><h4 class="font-semibold text-xs sm:text-sm lg:text-base text-white mb-1.5 sm:mb-3 pb-1 sm:pb-2 border-b border-blue-700">Specialized</h4><ul class="space-y-1 sm:space-y-2"><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/resume-builder-government-jobs-india">Government</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/resume-builder-us-jobs">US Jobs</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/resume-builder-internships">Internships</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/resume-builder-remote-jobs">Remote Jobs</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/one-page-resume-builder">One Page</a></li></ul></div><div class="space-y-1.5 sm:space-y-3"><h4 class="font-semibold text-xs sm:text-sm lg:text-base text-white mb-1.5 sm:mb-3 pb-1 sm:pb-2 border-b border-blue-700">Resources</h4><ul class="space-y-1 sm:space-y-2"><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/ai-resume-builder-india">AI Resume Builder</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/free-ats-resume-checker-india">Free ATS Checker</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/job-specific-resume-builder-india">JD-Based Builder</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/resume-upload-enhancement-india">Upload &amp; Enhance</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/professional-cover-letter-builder-india">Cover Letter AI</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/blog">Blog</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/blog/how-to-make-an-ats-friendly-resume-in-2025">ATS Resume Guide</a></li></ul></div><div class="space-y-1.5 sm:space-y-3"><h4 class="font-semibold text-xs sm:text-sm lg:text-base text-white mb-1.5 sm:mb-3 pb-1 sm:pb-2 border-b border-blue-700">Company</h4><ul class="space-y-1 sm:space-y-2"><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/pricing">Pricing</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/features">Features</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/about-us">About Us</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/contact-us">Contact</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/faqs">FAQs</a></li></ul></div><div class="space-y-1.5 sm:space-y-3"><h4 class="font-semibold text-xs sm:text-sm lg:text-base text-white mb-1.5 sm:mb-3 pb-1 sm:pb-2 border-b border-blue-700">Legal &amp; Blog</h4><ul class="space-y-1 sm:space-y-2"><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/terms">Terms of Service</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/privacy">Privacy Policy</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/refund">Refund Policy</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/blog">Career Blog</a></li><li><a class="text-blue-200 hover:text-white transition-colors text-xs sm:text-sm block" href="/blog/how-to-optimize-your-resume-for-applicant-tracking-systems">Resume Tips</a></li></ul></div></div><div class="pt-6 sm:pt-8 border-t border-blue-700"><div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 sm:gap-4"><div class="flex flex-col sm:flex-row sm:flex-wrap items-start sm:items-center gap-3 sm:gap-4"><a href="mailto:support@resumegyani.com" class="flex items-center gap-2 text-xs sm:text-sm text-blue-200 hover:text-white transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail sm:w-4 sm:h-4"><rect width="20" height="16" x="2" y="4" rx="2"></rect><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path></svg><span>support@resumegyani.com</span></a><a href="tel:+918431256903" class="flex items-center gap-2 text-xs sm:text-sm text-blue-200 hover:text-white transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-phone sm:w-4 sm:h-4"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg><span>+91 84312 56903</span></a><a href="https://wa.me/918431256903?text=Hi%20ResumeGyani%20Team!%20%F0%9F%91%8B%0A%0AI&#x27;m%20visiting%20your%20website%20and%20would%20like%20assistance%20with%3A%0A%E2%80%A2%20Resume%20Building%20%26%20Optimization%0A%E2%80%A2%20ATS%20Score%20Improvement%0A%E2%80%A2%20Career%20Guidance%20%26%20Job%20Search%0A%E2%80%A2%20Premium%20Features%20%26%20Plans%0A%E2%80%A2%20Technical%20Support%0A%0APlease%20help%20me%20get%20started.%20Thank%20you!" target="_blank" rel="noopener noreferrer" class="flex items-center gap-2 text-xs sm:text-sm text-green-300 hover:text-green-100 transition-colors"><svg class="w-4 h-4 sm:w-4 sm:h-4 fill-current" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413z"></path></svg><span>WhatsApp</span></a><div class="flex items-center gap-2 text-xs sm:text-sm text-blue-200"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-map-pin sm:w-4 sm:h-4"><path d="M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0"></path><circle cx="12" cy="10" r="3"></circle></svg><span>Bangalore, India</span></div></div></div></div></div><div class="relative border-t border-blue-700"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6"><div class="flex flex-col md:flex-row justify-between items-center gap-4"><div class="text-sm text-blue-200">Â© <!-- -->2025<!-- --> <a href="https://www.nyquisttech.com/" target="_blank" rel="noopener noreferrer" class="text-blue-100 hover:text-white transition-colors font-medium underline">Nyquist Tech</a> <!-- -->â€¢ All Rights Reserved â€¢<!-- --> <a href="https://resumegyani.com/privacy" target="_blank" rel="noopener noreferrer" class="text-blue-200 hover:text-white transition-colors underline">Privacy</a> | <a href="https://resumegyani.com/terms" target="_blank" rel="noopener noreferrer" class="text-blue-200 hover:text-white transition-colors underline">Terms</a></div><div class="flex items-center gap-6 text-sm text-blue-200"><span>AI-Powered Resume Builder</span><span class="hidden md:inline">â€¢</span><span>ATS-Friendly Templates</span><span class="hidden md:inline">â€¢</span><span>Trusted Worldwide</span></div></div></div></div></footer><script>requestAnimationFrame(function(){$RT=performance.now()});</script><script id="_R_">self.__next_r="RuudD8ehO3vem4L4ri78-"</script><script src="/_next/static/chunks/%5Bturbopack%5D_browser_dev_hmr-client_hmr-client_ts_bae88007._.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"9:I[\"[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-client] (ecmascript)\",[\"/_next/static/chunks/node_modules_next_dist_094231d7._.js\",\"/_next/static/chunks/app_favicon_ico_mjs_756560dc._.js\"],\"SegmentViewNode\"]\nb:\"$Sreact.fragment\"\n36:I[\"[project]/node_modules/next/dist/client/components/layout-router.js [app-client] (ecmascript)\",[\"/_next/static/chunks/node_modules_next_dist_094231d7._.js\",\"/_next/static/chunks/app_favicon_ico_mjs_756560dc._.js\"],\"default\"]\n38:I[\"[project]/node_modules/next/dist/client/components/render-from-template-context.js [app-client] (ecmascript)\",[\"/_next/static/chunks/node_modules_next_dist_094231d7._.js\",\"/_next/static/chunks/app_favicon_ico_mjs_756560dc._.js\"],\"default\"]\n48:I[\"[project]/node_modules/next/dist/lib/framework/boundary-components.js [app-client] (ecmascript)\",[\"/_next/static/chunks/node_modules_next_dist_094231d7._.js\",\"/_next/static/chunks/app_favicon_ico_mjs_756560dc._.js\"],\"OutletBoundary\"]\n4a:\"$Sreact.suspense\"\n53:I[\"[project]/node_modules/next/dist/lib/framework/boundary-components.js [app-client] (ecmascript)\",[\"/_next/static/chunks/node_modules_next_dist_094231d7._.js\",\"/_next/static/chunks/app_favicon_ico_mjs_756560dc._.js\"],\"ViewportBoundary\"]\n59:I[\"[project]/node_modules/next/dist/lib/framework/boundary-components.js [app-client] (ecmascript)\",[\"/_next/static/chunks/node_modules_next_dist_094231d7._.js\",\"/_next/static/chunks/app_favicon_ico_mjs_756560dc._.js\"],\"MetadataBoundary\"]\n5e:I[\"[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-client] (ecmascript)\",[\"/_next/static/chunks/node_modules_next_dist_client_components_builtin_global-error_78cdd4a3.js\"],\"default\"]\n66:I[\"[project]/app/context/LocationContext.js [app-client] (ecmascript)\",[\"/_next/static/chunks/app_5c0ccaa8._.js\",\"/_next/static/chunks/node_modules_next_d56e9ccf._.js\",\"/_next/static/chunks/node_modules_%40firebase_auth_dist_esm2017_fc9ae2b4._.js\",\"/_next/static/chunks/node_modules_%40firebase_firestore_dist_index_esm2017_d9c36ae7.js\",\"/_next/static/chunks/node_modules_%40firebase_storage_dist_index_esm2017_46d20e3b.js\",\"/_next/static/chunks/node_modules_54207353._.js\",\"/_next/static/chunks/app_layout_78cdd4a3.js\"],\"LocationProvider\"]\n69:I[\"[project]/app/components/ReferralCodeCapture.js [app-client] (ecmascript)\",[\"/_next/static/chunks/app_5c0ccaa8._.js\",\"/_next/static/chunks/node_modules_next_d56e9ccf._.js\",\"/_next/static/chunks/node_modules_%40firebase_auth_dist_esm2017_fc9ae2b4._.js\",\"/_next/static/chunks/node_modules_%40firebase_firestore_dist_index_esm2017_d9c36ae7.js\",\"/_next/static/chunks/node_modules_%40firebase_storage_dist_index_esm2017_46d20e3b.js\",\"/_next/static/chunks/node_modules_54207353._.js\",\"/_next/static/chunks/app_layout_78cdd4a3.js\"],\"default\"]\n6b:I[\"[project]/app/context/AuthContext.js [app-client] (ecmascript)\",[\"/_next/static/chunks/app_5c0ccaa8._.js\",\"/_next/static/chunks/node_modules_next_d56e9ccf._.js\",\"/_next/static/chunks/node_modules_%40firebase_auth_dist_esm2017_fc9ae2b4._.js\",\"/_next/static/chunks/node_modules_%40firebase_firestore_dist_index_esm2017_d9c36ae7.js\",\"/_next/static/chunks/node_modules_%40firebase_storage_dist_index_esm2017_46d20e3b.js\",\"/_next/static/chunks/node_modules_54207353._.js\",\"/_next/static/chunks/app_layout_78cdd4a3.js\"],\"AuthProvider\"]\n6d:I[\"[project]/app/ClientLayout.js [app-client] (ecmascript)\",[\"/_next/static/chunks/app_5c0ccaa8._.js\",\"/_next/static/chunks/node_modules_next_d56e9ccf._.js\",\"/_next/static/chunks/node_modules_%40firebase_auth_dist_esm2017_fc9ae2b4._.js\",\"/_next/static/chunks/node_modules_%40firebase_firestore_dist_index_esm2017_d9c36ae7.js\",\"/_next/static/chunks/node_modules_%40firebase_storage_dist_index_esm2017_46d20e3b.js\",\"/_next/static/chunks/node_modules_54207353._.js\",\"/_next/static/chunks/app_layout_78cdd4a3.js\"],\"default\"]\n7e:I[\"[project]/node_modules/next/dist/client/script.js [app-client] (ecmascript)\",[\"/_next/static/chunks/app_5c0ccaa8._.js\",\"/_next/static/chunks/node_modules_next_d56e9ccf._.js\",\"/_next/static/chunks/node_modules_%40firebase_auth_"])</script><script>self.__next_f.push([1,"dist_esm2017_fc9ae2b4._.js\",\"/_next/static/chunks/node_modules_%40firebase_firestore_dist_index_esm2017_d9c36ae7.js\",\"/_next/static/chunks/node_modules_%40firebase_storage_dist_index_esm2017_46d20e3b.js\",\"/_next/static/chunks/node_modules_54207353._.js\",\"/_next/static/chunks/app_layout_78cdd4a3.js\"],\"\"]\n:HL[\"/_next/static/chunks/%5Broot-of-the-server%5D__de87d4e7._.css\",\"style\"]\n:HL[\"/_next/static/media/47fe1b7cd6e6ed85-s.p.855a563b.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/a218039a3287bcfd-s.p.4a23d71b.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/a343f882a40d2cc9-s.p.71e1367e.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/e2334d715941921e-s.p.d82a9aff.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/resumegyani-logo-desktop-small.webp\",\"image\",{\"type\":\"image/webp\",\"fetchPriority\":\"high\"}]\n:HL[\"/resumegyani-logo-desktop-small.png\",\"image\",{\"fetchPriority\":\"high\"}]\n:N1766030882363.6416\n3:\"$EObject.defineProperty(()=\u003e{ctx.componentMod.preloadStyle(fullHref,ctx.renderOpts.crossOrigin,ctx.nonce)},\\\"name\\\",{value:\\\"\\\"})\"\n4:\"$EObject.defineProperty(()=\u003e{ctx.componentMod.preloadFont(href,type,ctx.renderOpts.crossOrigin,ctx.nonce)},\\\"name\\\",{value:\\\"\\\"})\"\n5:\"$EObject.defineProperty(()=\u003e{ctx.componentMod.preloadFont(href,type,ctx.renderOpts.crossOrigin,ctx.nonce)},\\\"name\\\",{value:\\\"\\\"})\"\n6:\"$EObject.defineProperty(()=\u003e{ctx.componentMod.preloadFont(href,type,ctx.renderOpts.crossOrigin,ctx.nonce)},\\\"name\\\",{value:\\\"\\\"})\"\n7:\"$EObject.defineProperty(()=\u003e{ctx.componentMod.preloadFont(href,type,ctx.renderOpts.crossOrigin,ctx.nonce)},\\\"name\\\",{value:\\\"\\\"})\"\n2:{\"name\":\"Preloads\",\"key\":null,\"env\":\"Server\",\"stack\":[],\"props\":{\"preloadCallbacks\":[\"$3\",\"$4\",\"$5\",\"$6\",\"$7\"]}}\n8:[]\na:[]\nc:[[\"Array.map\",\"\",0,0,0,0,false]]\nd:[[\"Array.map\",\"\",0,0,0,0,false]]\ne:[[\"Array.map\",\"\",0,0,0,0,false]]\nf:[[\"Array.map\",\"\",0,0,0,0,false]]\n10:[[\"Array.map\",\"\",0,0,0,0,false]]\n11:[[\"Array.map\",\"\",0,0,0,0,false]]\n12:[[\"Array.map\",\"\",0,0,0,0,false]]\n13:[[\"Array.map\",\"\",0,0,0,0,false]]\n16:I[\"[project]/node_modules/next/dist/client/components/layout-router.js [app-client] (ecmascript)\",[\"/_next/static/chunks/node_modules_next_dist_094231d7._.js\",\"/_next/static/chunks/app_favicon_ico_mjs_756560dc._.js\"],\"default\"]\n19:I[\"[project]/node_modules/next/dist/client/components/render-from-template-context.js [app-client] (ecmascript)\",[\"/_next/static/chunks/node_modules_next_dist_094231d7._.js\",\"/_next/static/chunks/app_favicon_ico_mjs_756560dc._.js\"],\"default\"]\n1a:{}\n1b:[[\"Function.all\",\"\",0,0,0,0,true]]\n18:{\"children\":[\"$\",\"$L19\",null,\"$1a\",null,\"$1b\",1]}\n1c:[[\"Function.all\",\"\",0,0,0,0,true]]\n17:{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$b\",null,\"$18\",null,\"$1c\",0],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$Y\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\",\"segmentViewBoundaries\":\"$Y\"}\n1d:[[\"Function.all\",\"\",0,0,0,0,true]]\n15:{\"name\":\"RootLayout\",\"key\":null,\"env\":\"Server\",\"stack\":[],\"props\":{\"children\":[\"$\",\"$L16\",null,\"$17\",null,\"$1d\",1],\"params\":\"$Y\"}}\n1e:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",563,263,558,1,false]]\n1f:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",566,264,558,1,false]]\n20:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",568,272,558,1,false]]\n21:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",576,272,558,1,false]]\n22:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",584,272,558,1,false]]\n23:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",592,272,558,1,false]]\n24:[[\"Root"])</script><script>self.__next_f.push([1,"Layout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",600,272,558,1,false]]\n25:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",609,272,558,1,false]]\n26:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",617,272,558,1,false]]\n27:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",625,272,558,1,false]]\n28:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",633,272,558,1,false]]\n29:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",641,272,558,1,false]]\n2a:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",652,272,558,1,false]]\n2b:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",662,272,558,1,false]]\n2c:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",671,272,558,1,false]]\n2d:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",680,272,558,1,false]]\n2e:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",690,272,558,1,false]]\n34:[[\"Function.all\",\"\",0,0,0,0,true]]\n35:[[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true]]\n37:[[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true]]\n39:[[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true]]\n3a:[[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true]]\n3b:[[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true]]\n3c:[[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true]]\n3d:[[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true]]\n3f:{\"name\":\"ResumeFormatPage\",\"key\":null,\"env\":\"Server\",\"stack\":[[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true]],\"props\":{\"params\":\"$@40\",\"searchParams\":\"$@41\"}}\n42:[[\"Array.map\",\"\",0,0,0,0,false],[\"Array.map\",\"\",0,0,0,0,false],[\"Function.all\",\"\",0,0,0,0,true]]\n43:[[\"Array.map\",\"\",0,0,0,0,false],[\"Array.map\",\"\",0,0,0,0,false],[\"Function.all\",\"\",0,0,0,0,true]]\n44:[[\"Array.map\",\"\",0,0,0,0,false],[\"Array.map\",\"\",0,0,0,0,false],[\"Function.all\",\"\",0,0,0,0,true]]\n46:{\"name\":\"Next.MetadataOutlet\",\"key\":null,\"env\":\"Server\",\"stack\":[[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true]],\"props\":{}}\n47:[]\n49:[]\n4c:[]\n"])</script><script>self.__next_f.push([1,"4f:\"$EObject.defineProperty(function(type,config,children){for(var propName,i=2;i\u003carguments.length;i++)validateChildKeys(arguments[i]);i={};var key=null;if(null!=config)for(propName in didWarnAboutOldJSXRuntime||!(\\\"__self\\\"in config)||\\\"key\\\"in config||(didWarnAboutOldJSXRuntime=!0,console.warn(\\\"Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform\\\")),hasValidKey(config)\u0026\u0026(checkKeyStringCoercion(config.key),key=\\\"\\\"+config.key),config)hasOwnProperty.call(config,propName)\u0026\u0026\\\"key\\\"!==propName\u0026\u0026\\\"__self\\\"!==propName\u0026\u0026\\\"__source\\\"!==propName\u0026\u0026(i[propName]=config[propName]);var childrenLength=arguments.length-2;if(1===childrenLength)i.children=children;else if(1\u003cchildrenLength){for(var childArray=Array(childrenLength),_i=0;_i\u003cchildrenLength;_i++)childArray[_i]=arguments[_i+2];Object.freeze\u0026\u0026Object.freeze(childArray),i.children=childArray}if(type\u0026\u0026type.defaultProps)for(propName in childrenLength=type.defaultProps)void 0===i[propName]\u0026\u0026(i[propName]=childrenLength[propName]);return key\u0026\u0026function(props,displayName){function warnAboutAccessingKey(){specialPropKeyWarningShown||(specialPropKeyWarningShown=!0,console.error(\\\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\\\",displayName))}warnAboutAccessingKey.isReactWarning=!0,Object.defineProperty(props,\\\"key\\\",{get:warnAboutAccessingKey,configurable:!0})}(i,\\\"function\\\"==typeof type?type.displayName||type.name||\\\"Unknown\\\":type),(propName=1e4\u003eReactSharedInternals.recentlyCreatedOwnerStacks++)?(childArray=Error.stackTraceLimit,Error.stackTraceLimit=10,childrenLength=Error(\\\"react-stack-top-frame\\\"),Error.stackTraceLimit=childArray):childrenLength=unknownOwnerDebugStack,ReactElement(type,key,i,getOwner(),childrenLength,propName?createTask(getTaskName(type)):unknownOwnerDebugTask)},\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"4e:{\"name\":\"NonIndex\",\"key\":null,\"env\":\"Server\",\"stack\":[],\"props\":{\"createElement\":\"$4f\",\"pagePath\":\"/resume-format-for/[slug]\",\"statusCode\":200,\"isPossibleServerAction\":false}}\n51:{\"name\":\"Next.Viewport\",\"key\":null,\"env\":\"Server\",\"stack\":[],\"props\":{}}\n52:[]\n56:{\"name\":\"Next.Metadata\",\"key\":null,\"env\":\"Server\",\"stack\":[],\"props\":{}}\n57:[]\n58:[]\n5a:[]\n5c:[]\n5f:[]\n60:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",700,272,558,1,false]]\n62:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",710,272,558,1,false]]\n63:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",720,272,558,1,false]]\n64:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",736,264,558,1,false]]\n65:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",803,272,558,1,false]]\n67:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",805,280,558,1,false]]\n68:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",807,294,558,1,false]]\n6a:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",817,280,558,1,false]]\n6c:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",818,294,558,1,false]]\n6e:[[\"Function.all\",\"\",0,0,0,0,true]]\n6f:[[\"Function.all\",\"\",0,0,0,0,true]]\n70:[]\n72:{\"name\":\"NotFound\",\"key\":null,\"env\":\"Server\",\"stack\":[],\"props\":{}}\n73:{\"name\":\"HTTPAccessErrorFallback\",\"key\":null,\"env\":\"Server\",\"owner\":\"$72\",\"stack\":[],\"props\":{\"status\":404,\"message\":\"This page could not be found.\"}}\n74:[]\n75:[]\n76:[]\n77:[]\n78:[]\n79:[]\n7a:[]\n7b:[[\"Function.all\",\"\",0,0,0,0,true]]\n7c:[[\"Function.all\",\"\",0,0,0,0,true]]\n7d:[[\"RootLayout\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/[root-of-the-server]__d74539ad._.js\",836,272,558,1,false]]\n40:{\"slug\":\"project-manager-resume-india\"}\n41:\n80:[]\n81:[]\n1:D{\"time\":0.4325829967856407}\n1:D\"$2\"\n1:D{\"time\":0.5155829936265945}\n1:null\n14:D{\"time\":1.0790419951081276}\n14:D\"$15\"\n14:D{\"time\":5.935166999697685}\n2f:T4c2,{\"@context\":\"https://schema.org\",\"@type\":\"Organization\",\"name\":\"ResumeGyani\",\"alternateName\":\"Resume Gyani\",\"url\":\"https://resumegyani.in\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://resumegyani.in/resumegyani-logo-blue-transparent.png\",\"width\":\"280\",\"height\":\"96\"},\"description\":\"Free AI-powered resume builder for US job seekers. Create ATS-friendly resumes in 60 seconds with 50+ professional templates.\",\"foundingDate\":\"2023\",\"founder\":{\"@type\":\"Organization\",\"name\":\"Nyquist Tech\"},\"areaServed\":{\"@type\":\"Country\",\"name\":\"India\"},\"slogan\":\"Get 3x More Interviews with AI-Powered Resumes\",\"sameAs\":[\"https://www.linkedin.com/company/resumegyani/\",\"https://twitter.com/nyquisttech\",\"https://www.facebook.com/resumegyani\",\"https://www.instagram.com/resumegyani\"],\"contactPoint\":[{\"@type\":\"ContactPoint\",\"telephone\":\"+91-8431256903\",\"contactType\":\"customer support\",\"areaServed\":[\"IN\",\"US\"],\"availableLanguage\":[\"English\",\"Hindi\"],\"contactOption\":\"TollFree\",\"availableTime\":\"Mo,Tu,We,Th,Fr 09:00-18:00\"}],\"address\":{\"@type\":\"PostalAddress\",\"addressCountry\":\"IN\",\"addressLocality\":\"India\"},\"aggregateRating\":{\"@type\":\"AggregateRating\",\"ratingValue\":\"4.9\",\"reviewCount\":\"50000\",\"bestRating\":\"5\",\"worstRating\":\"1\"}}"])</script><script>self.__next_f.push([1,"14:[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"google-site-verification\",\"content\":\"MpKSykohaMeXQNw5vcppYGV5L8CMp_Qq32uZsc08Uz8\"},\"$15\",\"$20\",1],[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"},\"$15\",\"$21\",1],[\"$\",\"meta\",null,{\"name\":\"format-detection\",\"content\":\"telephone=no\"},\"$15\",\"$22\",1],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#1e3a8a\"},\"$15\",\"$23\",1],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://va.vercel-scripts.com\",\"crossOrigin\":\"anonymous\"},\"$15\",\"$24\",1],[\"$\",\"link\",null,{\"rel\":\"dns-prefetch\",\"href\":\"https://www.googletagmanager.com\"},\"$15\",\"$25\",1],[\"$\",\"link\",null,{\"rel\":\"dns-prefetch\",\"href\":\"https://www.google-analytics.com\"},\"$15\",\"$26\",1],[\"$\",\"link\",null,{\"rel\":\"dns-prefetch\",\"href\":\"https://firestore.googleapis.com\"},\"$15\",\"$27\",1],[\"$\",\"link\",null,{\"rel\":\"dns-prefetch\",\"href\":\"https://checkout.razorpay.com\"},\"$15\",\"$28\",1],[\"$\",\"link\",null,{\"rel\":\"preload\",\"as\":\"image\",\"href\":\"/resumegyani-logo-desktop-small.webp\",\"type\":\"image/webp\",\"fetchPriority\":\"high\"},\"$15\",\"$29\",1],[\"$\",\"link\",null,{\"rel\":\"preload\",\"as\":\"image\",\"href\":\"/resumegyani-logo-desktop-small.png\",\"fetchPriority\":\"high\"},\"$15\",\"$2a\",1],[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"sizes\":\"any\"},\"$15\",\"$2b\",1],[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.png\",\"type\":\"image/png\"},\"$15\",\"$2c\",1],[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"LayoutPage\\\",\\\"mainEntity\\\":[{\\\"@type\\\":\\\"Question\\\",\\\"name\\\":\\\"How do I create a professional resume for free?\\\",\\\"acceptedAnswer\\\":{\\\"@type\\\":\\\"Answer\\\",\\\"text\\\":\\\"You can use ResumeGyani, a free resume builder, to create a professional resume in minutes. Choose from ATS-friendly resume templates and download your resume as a PDF instantly.\\\"}},{\\\"@type\\\":\\\"Question\\\",\\\"name\\\":\\\"Are ResumeGyani templates ATS-friendly?\\\",\\\"acceptedAnswer\\\":{\\\"@type\\\":\\\"Answer\\\",\\\"text\\\":\\\"Yes! ResumeGyani provides ATS-friendly resume templates to ensure your resume is optimized for job application tracking systems.\\\"}},{\\\"@type\\\":\\\"Question\\\",\\\"name\\\":\\\"Can I download my resume as a PDF?\\\",\\\"acceptedAnswer\\\":{\\\"@type\\\":\\\"Answer\\\",\\\"text\\\":\\\"Absolutely! ResumeGyani allows you to download your resume as a PDF with just one click.\\\"}}]}\"}},\"$15\",\"$2d\",1],[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"$2f\"}},\"$15\",\"$2e\",1],\"$L30\",\"$L31\",\"$L32\"]},\"$15\",\"$1f\",1],\"$L33\"]},\"$15\",\"$1e\",1]\n"])</script><script>self.__next_f.push([1,"3e:D{\"time\":7.467041999101639}\n3e:D\"$3f\"\n45:D{\"time\":8.492749996483326}\n45:D\"$46\"\n45:D{\"time\":12.82345799356699}\n45:[\"$\",\"$L48\",null,{\"children\":[\"$\",\"$4a\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@4b\"},\"$46\",\"$49\",1]},\"$46\",\"$47\",1]\n4d:D{\"time\":13.347457997500896}\n4d:D\"$4e\"\n4d:D{\"time\":13.358291998505592}\n4d:null\n50:D{\"time\":15.981082998216152}\n50:D\"$51\"\n50:D{\"time\":16.055583000183105}\n50:[\"$\",\"$L53\",null,{\"children\":\"$@54\"},\"$51\",\"$52\",1]\n55:D{\"time\":16.205541998147964}\n55:D\"$56\"\n55:D{\"time\":16.265832997858524}\n55:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$L59\",null,{\"children\":[\"$\",\"$4a\",null,{\"name\":\"Next.Metadata\",\"children\":\"$@5b\"},\"$56\",\"$5a\",1]},\"$56\",\"$58\",1]},\"$56\",\"$57\",1]\n5d:[]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":\"$1\",\"b\":\"development\",\"c\":[\"\",\"resume-format-for\",\"project-manager-resume-india\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"resume-format-for\",{\"children\":[[\"slug\",\"project-manager-resume-india\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$L9\",\"layout\",{\"type\":\"layout\",\"pagePath\":\"layout.js\",\"children\":[\"$\",\"$b\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/chunks/%5Broot-of-the-server%5D__de87d4e7._.css\",\"precedence\":\"next_static/chunks/[root-of-the-server]__de87d4e7._.css\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"},null,\"$c\",0],[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/app_5c0ccaa8._.js\",\"async\":true,\"nonce\":\"$undefined\"},null,\"$d\",0],[\"$\",\"script\",\"script-1\",{\"src\":\"/_next/static/chunks/node_modules_next_d56e9ccf._.js\",\"async\":true,\"nonce\":\"$undefined\"},null,\"$e\",0],[\"$\",\"script\",\"script-2\",{\"src\":\"/_next/static/chunks/node_modules_%40firebase_auth_dist_esm2017_fc9ae2b4._.js\",\"async\":true,\"nonce\":\"$undefined\"},null,\"$f\",0],[\"$\",\"script\",\"script-3\",{\"src\":\"/_next/static/chunks/node_modules_%40firebase_firestore_dist_index_esm2017_d9c36ae7.js\",\"async\":true,\"nonce\":\"$undefined\"},null,\"$10\",0],[\"$\",\"script\",\"script-4\",{\"src\":\"/_next/static/chunks/node_modules_%40firebase_storage_dist_index_esm2017_46d20e3b.js\",\"async\":true,\"nonce\":\"$undefined\"},null,\"$11\",0],[\"$\",\"script\",\"script-5\",{\"src\":\"/_next/static/chunks/node_modules_54207353._.js\",\"async\":true,\"nonce\":\"$undefined\"},null,\"$12\",0],[\"$\",\"script\",\"script-6\",{\"src\":\"/_next/static/chunks/app_layout_78cdd4a3.js\",\"async\":true,\"nonce\":\"$undefined\"},null,\"$13\",0]],\"$14\"]},null,\"$a\",1]},null,\"$8\",0],{\"children\":[[\"$\",\"$b\",\"c\",{\"children\":[null,[\"$\",\"$L36\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L38\",null,{},null,\"$37\",1],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\",\"segmentViewBoundaries\":[\"$undefined\",\"$undefined\",\"$undefined\",\"$undefined\"]},null,\"$35\",1]]},null,\"$34\",0],{\"children\":[[\"$\",\"$b\",\"c\",{\"children\":[null,[\"$\",\"$L36\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L38\",null,{},null,\"$3b\",1],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\",\"segmentViewBoundaries\":[\"$undefined\",\"$undefined\",\"$undefined\",\"$undefined\"]},null,\"$3a\",1]]},null,\"$39\",0],{\"children\":[[\"$\",\"$b\",\"c\",{\"children\":[[\"$\",\"$L9\",\"c-page\",{\"type\":\"page\",\"pagePath\":\"resume-format-for/[slug]/page.js\",\"children\":\"$L3e\"},null,\"$3d\",1],[[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/app_components_fe3de747._.js\",\"async\":true,\"nonce\":\"$undefined\"},null,\"$42\",0],[\"$\",\"script\",\"script-1\",{\"src\":\"/_next/static/chunks/node_modules_lucide-react_dist_esm_icons_2df9fe07._.js\",\"async\":true,\"nonce\":\"$undefined\"},null,\"$43\",0],[\"$\",\"script\",\"script-2\",{\"src\":\"/_next/static/chunks/app_resume-format-for_%5Bslug%5D_page_fb114cc8.js\",\"async\":true,\"nonce\":\"$undefined\"},null,\"$44\",0]],\"$45\"]},null,\"$3c\",0],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$b\",\"h\",{\"children\":[\"$4d\",\"$50\",\"$55\",[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"},null,\"$5c\",1]]},null,\"$4c\",0],false]],\"m\":\"$W5d\",\"G\":[\"$5e\",[\"$\",\"$L9\",\"ge-svn\",{\"type\":\"global-error\",\"pagePath\":\"__next_builtin__global-error.js\",\"children\":[]},null,\"$5f\",0]],\"S\":false}\n"])</script><script>self.__next_f.push([1,"30:D{\"time\":17.29074999690056}\n61:T6ad,"])</script><script>self.__next_f.push([1,"{\"@context\":\"https://schema.org\",\"@type\":\"SoftwareApplication\",\"name\":\"ResumeGyani\",\"applicationCategory\":\"BusinessApplication\",\"operatingSystem\":\"Web Browser\",\"browserRequirements\":\"Requires JavaScript. Requires HTML5.\",\"offers\":{\"@type\":\"Offer\",\"price\":\"0\",\"priceCurrency\":\"INR\",\"availability\":\"https://schema.org/InStock\",\"priceValidUntil\":\"2025-12-31\",\"description\":\"Free plan available with premium options\",\"seller\":{\"@type\":\"Organization\",\"name\":\"ResumeGyani\"}},\"aggregateRating\":{\"@type\":\"AggregateRating\",\"ratingValue\":\"4.9\",\"reviewCount\":\"50000\",\"bestRating\":\"5\",\"worstRating\":\"1\"},\"author\":{\"@type\":\"Organization\",\"name\":\"Nyquist Tech\",\"url\":\"https://resumegyani.in\"},\"provider\":{\"@type\":\"Organization\",\"name\":\"ResumeGyani\"},\"datePublished\":\"2023-01-01\",\"dateModified\":\"2025-01-15\",\"featureList\":[\"AI-Powered Resume Builder\",\"50+ ATS-Friendly Templates\",\"Free ATS Score Checker\",\"One-Page Resume Creator\",\"Job Description Resume Builder\",\"AI Bullet Point Generator\",\"Salary Analyzer Tool\",\"Interview Preparation Coach\",\"Instant PDF Download\",\"Mobile Responsive Builder\"],\"screenshot\":\"https://resumegyani.in/resumepreview.png\",\"softwareVersion\":\"2.0\",\"description\":\"Free AI-powered resume builder for US job seekers. Create ATS-friendly resumes in 60 seconds with professional templates, AI suggestions, and instant ATS scoring.\",\"url\":\"https://resumegyani.in\",\"inLanguage\":[\"en\",\"hi\"],\"audience\":{\"@type\":\"Audience\",\"audienceType\":\"Job Seekers\",\"geographicArea\":{\"@type\":\"AdministrativeArea\",\"name\":\"India\"}},\"applicationSubCategory\":\"Resume Builder\",\"downloadUrl\":\"https://resumegyani.in\",\"installUrl\":\"https://resumegyani.in\",\"permissions\":\"No installation required - Web based application\"}"])</script><script>self.__next_f.push([1,"30:[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"$61\"}},\"$15\",\"$60\",1]\n31:D{\"time\":17.343041993677616}\n31:[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"BreadcrumbList\\\",\\\"itemListElement\\\":[{\\\"@type\\\":\\\"ListItem\\\",\\\"position\\\":1,\\\"name\\\":\\\"Home\\\",\\\"item\\\":\\\"https://resumegyani.in\\\"},{\\\"@type\\\":\\\"ListItem\\\",\\\"position\\\":2,\\\"name\\\":\\\"Resume Builder\\\",\\\"item\\\":\\\"https://resumegyani.in/resume-builder\\\"},{\\\"@type\\\":\\\"ListItem\\\",\\\"position\\\":3,\\\"name\\\":\\\"Templates\\\",\\\"item\\\":\\\"https://resumegyani.in/templates\\\"},{\\\"@type\\\":\\\"ListItem\\\",\\\"position\\\":4,\\\"name\\\":\\\"ATS Checker\\\",\\\"item\\\":\\\"https://resumegyani.in/ats-score-checker\\\"}]}\"}},\"$15\",\"$62\",1]\n32:D{\"time\":17.38324999809265}\n32:[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"WebSite\\\",\\\"name\\\":\\\"ResumeGyani\\\",\\\"alternateName\\\":\\\"Resume Gyani\\\",\\\"url\\\":\\\"https://resumegyani.in\\\",\\\"description\\\":\\\"Free AI-powered resume builder for US job seekers. Create ATS-friendly resumes with professional templates.\\\",\\\"publisher\\\":{\\\"@type\\\":\\\"Organization\\\",\\\"name\\\":\\\"ResumeGyani\\\",\\\"logo\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"url\\\":\\\"https://resumegyani.in/resumegyani-logo-blue-transparent.png\\\",\\\"width\\\":\\\"280\\\",\\\"height\\\":\\\"96\\\"}},\\\"potentialAction\\\":{\\\"@type\\\":\\\"SearchAction\\\",\\\"target\\\":{\\\"@type\\\":\\\"EntryPoint\\\",\\\"urlTemplate\\\":\\\"https://resumegyani.in/search?q={search_term_string}\\\"},\\\"query-input\\\":\\\"required name=search_term_string\\\"}}\"}},\"$15\",\"$63\",1]\n33:D{\"time\":17.991916999220848}\n71:D{\"time\":18.514207996428013}\n71:D\"$72\"\n71:D{\"time\":18.617874994874}\n71:D\"$73\"\n71:D{\"time\":18.724999994039536}\n71:[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"},\"$73\",\"$74\",1],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}},\"$73\",\"$77\",1],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404},\"$73\",\"$78\",1],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"},\"$73\",\"$7a\",1]},\"$73\",\"$79\",1]]},\"$73\",\"$76\",1]},\"$73\",\"$75\",1]]\n7f:T14c8,"])</script><script>self.__next_f.push([1,"\n            (function() {\n              try {\n                const STORAGE_KEY = 'resumegyani_referrer';\n                const SESSION_KEY = 'resumegyani_session_start';\n                \n                // Parse referrer data\n                const parseReferrer = function(referrer, urlParams) {\n                  const data = {\n                    source: 'direct',\n                    medium: 'none',\n                    campaign: null,\n                    term: null,\n                    content: null,\n                    referrerUrl: referrer || 'direct',\n                    landingPage: window.location.href,\n                    timestamp: new Date().toISOString()\n                  };\n                  \n                  // Check UTM parameters\n                  if (urlParams.has('utm_source')) {\n                    data.source = urlParams.get('utm_source');\n                    data.medium = urlParams.get('utm_medium') || 'unknown';\n                    data.campaign = urlParams.get('utm_campaign');\n                    data.term = urlParams.get('utm_term');\n                    data.content = urlParams.get('utm_content');\n                    return data;\n                  }\n                  \n                  // Check for Google Ads\n                  if (urlParams.has('gclid')) {\n                    data.source = 'google';\n                    data.medium = 'cpc';\n                    data.campaign = urlParams.get('utm_campaign') || 'google_ads';\n                    data.gclid = urlParams.get('gclid');\n                    return data;\n                  }\n                  \n                  // Check for Facebook Ads\n                  if (urlParams.has('fbclid')) {\n                    data.source = 'facebook';\n                    data.medium = 'cpc';\n                    data.campaign = urlParams.get('utm_campaign') || 'facebook_ads';\n                    data.fbclid = urlParams.get('fbclid');\n                    return data;\n                  }\n                  \n                  // Parse referrer URL\n                  if (referrer \u0026\u0026 referrer !== '') {\n                    try {\n                      const refUrl = new URL(referrer);\n                      const hostname = refUrl.hostname.toLowerCase();\n                      \n                      if (hostname.includes('resumegyani')) {\n                        data.source = 'resumegyani';\n                        data.medium = 'internal';\n                        return data;\n                      }\n                      \n                      if (hostname.includes('google.')) {\n                        data.source = 'google';\n                        data.medium = 'organic';\n                        const q = refUrl.searchParams.get('q');\n                        if (q) data.term = q;\n                        return data;\n                      }\n                      \n                      if (hostname.includes('facebook.') || hostname.includes('fb.')) {\n                        data.source = 'facebook';\n                        data.medium = 'social';\n                        return data;\n                      }\n                      \n                      if (hostname.includes('linkedin.')) {\n                        data.source = 'linkedin';\n                        data.medium = 'social';\n                        return data;\n                      }\n                      \n                      // Other referrals\n                      data.source = hostname;\n                      data.medium = 'referral';\n                      return data;\n                    } catch (e) {\n                      console.error('Error parsing referrer:', e);\n                    }\n                  }\n                  \n                  return data;\n                };\n                \n                // Track referrer\n                const lastSession = localStorage.getItem(SESSION_KEY);\n                const now = Date.now();\n                const isNewSession = !lastSession || (now - parseInt(lastSession)) \u003e 30 * 60 * 1000;\n                \n                localStorage.setItem(SESSION_KEY, now.toString());\n                \n                const existingData = localStorage.getItem(STORAGE_KEY);\n                const urlParams = new URLSearchParams(window.location.search);\n                const currentReferrer = parseReferrer(document.referrer, urlParams);\n                \n                let shouldUpdate = false;\n                \n                if (!existingData) {\n                  shouldUpdate = true;\n                } else if (isNewSession) {\n                  const stored = JSON.parse(existingData);\n                  if (stored.source !== currentReferrer.source || \n                      (currentReferrer.campaign \u0026\u0026 currentReferrer.campaign !== stored.campaign) ||\n                      (stored.source === 'direct' \u0026\u0026 currentReferrer.source !== 'direct')) {\n                    shouldUpdate = true;\n                  }\n                }\n                \n                if (shouldUpdate) {\n                  localStorage.setItem(STORAGE_KEY, JSON.stringify(currentReferrer));\n                  console.log('ðŸ“Š Referrer tracked:', currentReferrer);\n                }\n              } catch (error) {\n                console.error('Referrer tracking error:', error);\n              }\n            })();\n          "])</script><script>self.__next_f.push([1,"33:[\"$\",\"body\",null,{\"className\":\"poppins_62dcd493-module__8MNW6q__variable manrope_bf416764-module__ysqPka__variable antialiased bg-gradient-to-br from-gray-50 via-blue-50 to-teal-50 text-gray-900\",\"children\":[false,[\"$\",\"$L66\",null,{\"children\":[[\"$\",\"$4a\",null,{\"fallback\":null,\"children\":[\"$\",\"$L69\",null,{},\"$15\",\"$68\",1]},\"$15\",\"$67\",1],[\"$\",\"$L6b\",null,{\"children\":[\"$\",\"$L6d\",null,{\"children\":[\"$\",\"$L36\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L38\",null,{},null,\"$6f\",1],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"$L9\",\"c-not-found\",{\"type\":\"not-found\",\"pagePath\":\"__next_builtin__not-found.js\",\"children\":[\"$71\",[]]},null,\"$70\",0],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\",\"segmentViewBoundaries\":[[\"$\",\"$L9\",null,{\"type\":\"boundary:not-found\",\"pagePath\":\"__next_builtin__not-found.js@boundary\"},null,\"$7b\",1],\"$undefined\",\"$undefined\",[\"$\",\"$L9\",null,{\"type\":\"boundary:global-error\",\"pagePath\":\"__next_builtin__global-error.js\"},null,\"$7c\",1]]},null,\"$6e\",1]},\"$15\",\"$6c\",1]},\"$15\",\"$6a\",1]]},\"$15\",\"$65\",1],[\"$\",\"$L7e\",null,{\"id\":\"referrer-tracker\",\"strategy\":\"afterInteractive\",\"children\":\"$7f\"},\"$15\",\"$7d\",1]]},\"$15\",\"$64\",1]\n54:D{\"time\":44.93366699665785}\n54:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"},\"$46\",\"$80\",0],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"},\"$46\",\"$81\",0]]\n"])</script><script>self.__next_f.push([1,"152:\"$Sreact.forward_ref\"\n157:I[\"[project]/node_modules/next/dist/client/app-dir/link.js [app-client] (ecmascript)\",[\"/_next/static/chunks/app_5c0ccaa8._.js\",\"/_next/static/chunks/node_modules_next_d56e9ccf._.js\",\"/_next/static/chunks/node_modules_%40firebase_auth_dist_esm2017_fc9ae2b4._.js\",\"/_next/static/chunks/node_modules_%40firebase_firestore_dist_index_esm2017_d9c36ae7.js\",\"/_next/static/chunks/node_modules_%40firebase_storage_dist_index_esm2017_46d20e3b.js\",\"/_next/static/chunks/node_modules_54207353._.js\",\"/_next/static/chunks/app_layout_78cdd4a3.js\",\"/_next/static/chunks/app_components_fe3de747._.js\",\"/_next/static/chunks/node_modules_lucide-react_dist_esm_icons_2df9fe07._.js\",\"/_next/static/chunks/app_resume-format-for_%5Bslug%5D_page_fb114cc8.js\"],\"\"]\n164:\"$Sreact.forward_ref\"\n173:I[\"[project]/app/components/SlugPageLazyWrapper.js [app-client] (ecmascript)\",[\"/_next/static/chunks/app_5c0ccaa8._.js\",\"/_next/static/chunks/node_modules_next_d56e9ccf._.js\",\"/_next/static/chunks/node_modules_%40firebase_auth_dist_esm2017_fc9ae2b4._.js\",\"/_next/static/chunks/node_modules_%40firebase_firestore_dist_index_esm2017_d9c36ae7.js\",\"/_next/static/chunks/node_modules_%40firebase_storage_dist_index_esm2017_46d20e3b.js\",\"/_next/static/chunks/node_modules_54207353._.js\",\"/_next/static/chunks/app_layout_78cdd4a3.js\",\"/_next/static/chunks/app_components_fe3de747._.js\",\"/_next/static/chunks/node_modules_lucide-react_dist_esm_icons_2df9fe07._.js\",\"/_next/static/chunks/app_resume-format-for_%5Bslug%5D_page_fb114cc8.js\"],\"default\"]\n82:{\"name\":\"ResumeFormatPage\",\"key\":null,\"env\":\"Server\",\"stack\":[[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true],[\"Function.all\",\"\",0,0,0,0,true]],\"props\":{\"params\":\"$@83\",\"searchParams\":\"$@84\"}}\n85:J{\"name\":\"\",\"start\":-70256.52258300036,\"end\":390.6135829985142,\"env\":\"Server\",\"owner\":\"$82\",\"value\":\"$@86\"}\n87:[[\"getRoleBySlug\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",94,38,90,1,false],[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",577,169,574,1,false]]\n83:{\"slug\":\"software-engineer-resume\"}\n84:{}\n88:{\"slug\":{\"stringValue\":\"project-manager-resume-india\",\"valueType\":\"stringValue\"},\"job_title\":{\"stringValue\":\"Project Manager\",\"valueType\":\"stringValue\"},\"experience_level\":{\"stringValue\":\"Mid-Senior\",\"valueType\":\"stringValue\"},\"avg_salary_india\":{\"stringValue\":\"â‚¹15L - â‚¹35L\",\"valueType\":\"stringValue\"},\"summary_text\":{\"stringValue\":\"Passionate Project Manager seeking to leverage extensive background in enhancing business performance to contribute to organizational success.\",\"valueType\":\"stringValue\"},\"hard_skills\":{\"arrayValue\":{\"values\":\"$Y\"},\"valueType\":\"arrayValue\"},\"soft_skills\":\"$Y\",\"common_mistakes\":\"$Y\",\"seo_title\":\"$Y\",\"meta_description\":\"$Y\",\"keywords\":\"$Y\",\"faqs\":\"$Y\",\"industry_context\":\"$Y\",\"ats_tips\":\"$Y\",\"day_in_life\":\"$Y\",\"career_path\":\"$Y\",\"salary_breakdown\":\"$Y\",\"top_certifications\":\"$Y\",\"tech_stack_breakdown\":\"$Y\"}\n8c:\"$EObject.defineProperty(function () {\\n            const temp = Object.assign({}, this);\\n            if (temp.credentials) {\\n                temp.credentials = { private_key: '***', client_email: '***' };\\n            }\\n            return temp;\\n        },\\\"name\\\",{value:\\\"\\\"})\"\n8b:{\"credentials\":{\"private_key\":\"$Y\",\"client_email\":\"firebase-adminsdk-fbsvc@resumemaker-b590f.iam.gserviceaccount.com\"},\"projectId\":\"resumemaker-b590f\",\"firebaseVersion\":\"13.2.0\",\"firebaseAdminVersion\":\"13.2.0\",\"preferRest\":\"$undefined\",\"databaseId\":\"(default)\",\"libName\":\"gccl\",\"libVersion\":\"7.11.0 fire/13.2.0 fire-admin/13.2.0\",\"toJSON\":\"$8c\"}\n8e:\"$EObject.defineProperty(path =\u003e firestore.doc(path),\\\"name\\\",{value:\\\"\\\"})\"\n8f:\"$EObject.defineProperty(n =\u003e firestore._settings.useBigInt ? BigInt(n) : Number(n),\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"91:\"$EObject.defineProperty(class Serializer {\\n    constructor(firestore) {\\n        // Instead of storing the `firestore` object, we store just a reference to\\n        // its `.doc()` method. This avoid a circular reference, which breaks\\n        // JSON.stringify().\\n        this.createReference = path =\u003e firestore.doc(path);\\n        this.createInteger = n =\u003e firestore._settings.useBigInt ? BigInt(n) : Number(n);\\n        this.allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\\n    }\\n    /**\\n     * Encodes a JavaScript object into the Firestore 'Fields' representation.\\n     *\\n     * @private\\n     * @internal\\n     * @param obj The object to encode.\\n     * @returns The Firestore 'Fields' representation\\n     */\\n    encodeFields(obj) {\\n        const fields = {};\\n        for (const prop of Object.keys(obj)) {\\n            const val = this.encodeValue(obj[prop]);\\n            if (val) {\\n                fields[prop] = val;\\n            }\\n        }\\n        return fields;\\n    }\\n    /**\\n     * Encodes a JavaScript value into the Firestore 'Value' representation.\\n     *\\n     * @private\\n     * @internal\\n     * @param val The object to encode\\n     * @returns The Firestore Proto or null if we are deleting a field.\\n     */\\n    encodeValue(val) {\\n        if (val instanceof field_value_1.FieldTransform) {\\n            return null;\\n        }\\n        if (typeof val === 'string') {\\n            return {\\n                stringValue: val,\\n            };\\n        }\\n        if (typeof val === 'boolean') {\\n            return {\\n                booleanValue: val,\\n            };\\n        }\\n        if (typeof val === 'number') {\\n            const isNegativeZero = val === 0 \u0026\u0026 1 / val === 1 / -0;\\n            if (Number.isSafeInteger(val) \u0026\u0026 !isNegativeZero) {\\n                return {\\n                    integerValue: val,\\n                };\\n            }\\n            else {\\n                return {\\n                    doubleValue: val,\\n                };\\n            }\\n        }\\n        if (typeof val === 'bigint') {\\n            return {\\n                integerValue: val.toString(),\\n            };\\n        }\\n        if (val instanceof Date) {\\n            const timestamp = timestamp_1.Timestamp.fromDate(val);\\n            return {\\n                timestampValue: {\\n                    seconds: timestamp.seconds,\\n                    nanos: timestamp.nanoseconds,\\n                },\\n            };\\n        }\\n        if (isMomentJsType(val)) {\\n            const timestamp = timestamp_1.Timestamp.fromDate(val.toDate());\\n            return {\\n                timestampValue: {\\n                    seconds: timestamp.seconds,\\n                    nanos: timestamp.nanoseconds,\\n                },\\n            };\\n        }\\n        if (val === null) {\\n            return {\\n                nullValue: 'NULL_VALUE',\\n            };\\n        }\\n        if (val instanceof Buffer || val instanceof Uint8Array) {\\n            return {\\n                bytesValue: val,\\n            };\\n        }\\n        if (val instanceof field_value_1.VectorValue) {\\n            return val._toProto(this);\\n        }\\n        if ((0, util_1.isObject)(val)) {\\n            const toProto = val['toProto'];\\n            if (typeof toProto === 'function') {\\n                return toProto.bind(val)();\\n            }\\n        }\\n        if (Array.isArray(val)) {\\n            const array = {\\n                arrayValue: {},\\n            };\\n            if (val.length \u003e 0) {\\n                array.arrayValue.values = [];\\n                for (let i = 0; i \u003c val.length; ++i) {\\n                    const enc = this.encodeValue(val[i]);\\n                    if (enc) {\\n                        array.arrayValue.values.push(enc);\\n                    }\\n                }\\n            }\\n            return array;\\n        }\\n        if (typeof val === 'object' \u0026\u0026 (0, util_1.isPlainObject)(val)) {\\n            const map = {\\n                mapValue: {},\\n            };\\n            // If we encounter an empty object, we always need to send it to make sure\\n            // the server creates a map entry.\\n            if (!(0, util_1.isEmpty)(val)) {\\n                map.mapValue.fields = this.encodeFields(val);\\n                if ((0, util_1.isEmpty)(map.mapValue.fields)) {\\n                    return null;\\n                }\\n            }\\n            return map;\\n        }\\n        if (val === undefined \u0026\u0026 this.allowUndefined) {\\n            return null;\\n        }\\n        throw new Error(`Cannot encode value: ${val}`);\\n    }\\n    /**\\n     * @private\\n     */\\n    encodeVector(rawVector) {\\n        // A Firestore Vector is a map with reserved key/value pairs.\\n        return {\\n            mapValue: {\\n                fields: {\\n                    [map_type_1.RESERVED_MAP_KEY]: {\\n                        stringValue: map_type_1.RESERVED_MAP_KEY_VECTOR_VALUE,\\n                    },\\n                    [map_type_1.VECTOR_MAP_VECTORS_KEY]: {\\n                        arrayValue: {\\n                            values: rawVector.map(value =\u003e {\\n                                return {\\n                                    doubleValue: value,\\n                                };\\n                            }),\\n                        },\\n                    },\\n                },\\n            },\\n        };\\n    }\\n    /**\\n     * Decodes a single Firestore 'Value' Protobuf.\\n     *\\n     * @private\\n     * @internal\\n     * @param proto A Firestore 'Value' Protobuf.\\n     * @returns The converted JS type.\\n     */\\n    decodeValue(proto) {\\n        const valueType = (0, convert_1.detectValueType)(proto);\\n        switch (valueType) {\\n            case 'stringValue': {\\n                return proto.stringValue;\\n            }\\n            case 'booleanValue': {\\n                return proto.booleanValue;\\n            }\\n            case 'integerValue': {\\n                return this.createInteger(proto.integerValue);\\n            }\\n            case 'doubleValue': {\\n                return proto.doubleValue;\\n            }\\n            case 'timestampValue': {\\n                return timestamp_1.Timestamp.fromProto(proto.timestampValue);\\n            }\\n            case 'referenceValue': {\\n                const resourcePath = path_1.QualifiedResourcePath.fromSlashSeparatedString(proto.referenceValue);\\n                return this.createReference(resourcePath.relativeName);\\n            }\\n            case 'arrayValue': {\\n                const array = [];\\n                if (Array.isArray(proto.arrayValue.values)) {\\n                    for (const value of proto.arrayValue.values) {\\n                        array.push(this.decodeValue(value));\\n                    }\\n                }\\n                return array;\\n            }\\n            case 'nullValue': {\\n                return null;\\n            }\\n            case 'mapValue': {\\n                const fields = proto.mapValue.fields;\\n                if (fields) {\\n                    const obj = {};\\n                    for (const prop of Object.keys(fields)) {\\n                        obj[prop] = this.decodeValue(fields[prop]);\\n                    }\\n                    return obj;\\n                }\\n                else {\\n                    return {};\\n                }\\n            }\\n            case 'vectorValue': {\\n                const fields = proto.mapValue.fields;\\n                return field_value_1.VectorValue._fromProto(fields[map_type_1.VECTOR_MAP_VECTORS_KEY]);\\n            }\\n            case 'geoPointValue': {\\n                return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);\\n            }\\n            case 'bytesValue': {\\n                return proto.bytesValue;\\n            }\\n            default: {\\n                throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));\\n            }\\n        }\\n    }\\n    /**\\n     * Decodes a google.protobuf.Value\\n     *\\n     * @private\\n     * @internal\\n     * @param proto A Google Protobuf 'Value'.\\n     * @returns The converted JS type.\\n     */\\n    decodeGoogleProtobufValue(proto) {\\n        switch ((0, convert_1.detectGoogleProtobufValueType)(proto)) {\\n            case 'nullValue': {\\n                return null;\\n            }\\n            case 'numberValue': {\\n                return proto.numberValue;\\n            }\\n            case 'stringValue': {\\n                return proto.stringValue;\\n            }\\n            case 'boolValue': {\\n                return proto.boolValue;\\n            }\\n            case 'listValue': {\\n                return this.decodeGoogleProtobufList(proto.listValue);\\n            }\\n            case 'structValue': {\\n                return this.decodeGoogleProtobufStruct(proto.structValue);\\n            }\\n            default: {\\n                throw new Error('Cannot decode type from google.protobuf.Value: ' +\\n                    JSON.stringify(proto));\\n            }\\n        }\\n    }\\n    /**\\n     * Decodes a google.protobuf.ListValue\\n     *\\n     * @private\\n     * @internal\\n     * @param proto A Google Protobuf 'ListValue'.\\n     * @returns The converted JS type.\\n     */\\n    decodeGoogleProtobufList(proto) {\\n        const result = [];\\n        if (proto \u0026\u0026 proto.values \u0026\u0026 Array.isArray(proto.values)) {\\n            for (const value of proto.values) {\\n                result.push(this.decodeGoogleProtobufValue(value));\\n            }\\n        }\\n        return result;\\n    }\\n    /**\\n     * Decodes a google.protobuf.Struct\\n     *\\n     * @private\\n     * @internal\\n     * @param proto A Google Protobuf 'Struct'.\\n     * @returns The converted JS type.\\n     */\\n    decodeGoogleProtobufStruct(proto) {\\n        const result = {};\\n        if (proto \u0026\u0026 proto.fields) {\\n            for (const prop of Object.keys(proto.fields)) {\\n                result[prop] = this.decodeGoogleProtobufValue(proto.fields[prop]);\\n            }\\n        }\\n        return result;\\n    }\\n},\\\"name\\\",{value:\\\"Serializer\\\"})\"\n"])</script><script>self.__next_f.push([1,"90:\"$91\"\n8d:{\"createReference\":\"$8e\",\"createInteger\":\"$8f\",\"allowUndefined\":false,\"\":\"$P90\"}\n95:\"$EObject.defineProperty(class ProxyTracerProvider {\\n    /**\\n     * Get a {@link ProxyTracer}\\n     */\\n    getTracer(name, version, options) {\\n        var _a;\\n        return ((_a = this.getDelegateTracer(name, version, options)) !== null \u0026\u0026 _a !== void 0 ? _a : new ProxyTracer_1.ProxyTracer(this, name, version, options));\\n    }\\n    getDelegate() {\\n        var _a;\\n        return (_a = this._delegate) !== null \u0026\u0026 _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;\\n    }\\n    /**\\n     * Set the delegate tracer provider\\n     */\\n    setDelegate(delegate) {\\n        this._delegate = delegate;\\n    }\\n    getDelegateTracer(name, version, options) {\\n        var _a;\\n        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);\\n    }\\n},\\\"name\\\",{value:\\\"ProxyTracerProvider\\\"})\"\n94:\"$95\"\n93:{\"\":\"$P94\"}\n98:\"$EObject.defineProperty(class ProxyTracer {\\n    constructor(_provider, name, version, options) {\\n        this._provider = _provider;\\n        this.name = name;\\n        this.version = version;\\n        this.options = options;\\n    }\\n    startSpan(name, options, context) {\\n        return this._getTracer().startSpan(name, options, context);\\n    }\\n    startActiveSpan(_name, _options, _context, _fn) {\\n        const tracer = this._getTracer();\\n        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\\n    }\\n    /**\\n     * Try to get a tracer from the proxy tracer provider.\\n     * If the proxy tracer provider has no delegate, return a noop tracer.\\n     */\\n    _getTracer() {\\n        if (this._delegate) {\\n            return this._delegate;\\n        }\\n        const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);\\n        if (!tracer) {\\n            return NOOP_TRACER;\\n        }\\n        this._delegate = tracer;\\n        return this._delegate;\\n    }\\n},\\\"name\\\",{value:\\\"ProxyTracer\\\"})\"\n97:\"$98\"\n96:{\"_provider\":\"$93\",\"name\":\"@google-cloud/firestore\",\"version\":\"7.11.0\",\"options\":\"$undefined\",\"\":\"$P97\"}\n99:{\"otel.scope.name\":\"@google-cloud/firestore\",\"otel.scope.version\":\"7.11.0\",\"gcp.firestore.settings.project_id\":\"resumemaker-b590f\",\"gcp.firestore.settings.database_id\":\"(default)\",\"gcp.firestore.settings.host\":\"firestore.googleapis.com:443\",\"gcp.firestore.settings.max_idle_channels\":1,\"gcp.firestore.settings.initial_retry_delay\":\"0.1s\",\"gcp.firestore.settings.initial_rpc_timeout\":\"60s\",\"gcp.firestore.settings.total_timeout\":\"600s\",\"gcp.firestore.settings.max_retry_delay\":\"60s\",\"gcp.firestore.settings.max_rpc_timeout\":\"60s\",\"gcp.firestore.settings.retry_delay_multiplier\":\"1.3\",\"gcp.firestore.settings.rpc_timeout_multiplier\":\"1\"}\n"])</script><script>self.__next_f.push([1,"9b:\"$EObject.defineProperty(class EnabledTraceUtil {\\n    constructor(settings) {\\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\\n        let provider = (_a = settings.openTelemetry) === null || _a === void 0 ? void 0 : _a.tracerProvider;\\n        // If a TracerProvider has not been given to us, we try to use the global one.\\n        if (!provider) {\\n            const { trace } = require('@opentelemetry/api');\\n            provider = trace.getTracerProvider();\\n        }\\n        // At this point provider is guaranteed to be defined because\\n        // `trace.getTracerProvider()` does not return null or undefined.\\n        this.tracerProvider = provider;\\n        const libVersion = require('../../../package.json').version;\\n        const libName = require('../../../package.json').name;\\n        try {\\n            this.tracer = this.tracerProvider.getTracer(libName, libVersion);\\n        }\\n        catch (e) {\\n            throw new Error(\\\"The object provided for 'tracerProvider' does not conform to the TracerProvider interface.\\\");\\n        }\\n        this.settingsAttributes = {};\\n        this.settingsAttributes['otel.scope.name'] = libName;\\n        this.settingsAttributes['otel.scope.version'] = libVersion;\\n        if (settings.projectId) {\\n            this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.project_id`] =\\n                settings.projectId;\\n        }\\n        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.database_id`] =\\n            settings.databaseId || path_1.DEFAULT_DATABASE_ID;\\n        const host = (_c = (_b = settings.servicePath) !== null \u0026\u0026 _b !== void 0 ? _b : settings.host) !== null \u0026\u0026 _c !== void 0 ? _c : 'firestore.googleapis.com';\\n        const port = (_d = settings.port) !== null \u0026\u0026 _d !== void 0 ? _d : v1_1.FirestoreClient.port;\\n        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.host`] =\\n            `${host}:${port}`;\\n        if (settings.preferRest !== undefined) {\\n            this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.prefer_REST`] =\\n                settings.preferRest;\\n        }\\n        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.max_idle_channels`] =\\n            (_e = settings.maxIdleChannels) !== null \u0026\u0026 _e !== void 0 ? _e : index_1.DEFAULT_MAX_IDLE_CHANNELS;\\n        const defaultRetrySettings = serviceConfig.retry_params.default;\\n        const customRetrySettings = (_j = (_h = (_g = (_f = settings.clientConfig) === null || _f === void 0 ? void 0 : _f.interfaces) === null || _g === void 0 ? void 0 : _g['google.firestore.v1.Firestore']) === null || _h === void 0 ? void 0 : _h['retry_params']) === null || _j === void 0 ? void 0 : _j['default'];\\n        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.initial_retry_delay`] = this.millisToSecondString((_k = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.initial_retry_delay_millis) !== null \u0026\u0026 _k !== void 0 ? _k : defaultRetrySettings.initial_retry_delay_millis);\\n        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.initial_rpc_timeout`] = this.millisToSecondString((_l = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.initial_rpc_timeout_millis) !== null \u0026\u0026 _l !== void 0 ? _l : defaultRetrySettings.initial_rpc_timeout_millis);\\n        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.total_timeout`] =\\n            this.millisToSecondString((_m = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.total_timeout_millis) !== null \u0026\u0026 _m !== void 0 ? _m : defaultRetrySettings.total_timeout_millis);\\n        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.max_retry_delay`] =\\n            this.millisToSecondString((_o = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.max_retry_delay_millis) !== null \u0026\u0026 _o !== void 0 ? _o : defaultRetrySettings.max_retry_delay_millis);\\n        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.max_rpc_timeout`] =\\n            this.millisToSecondString((_p = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.max_rpc_timeout_millis) !== null \u0026\u0026 _p !== void 0 ? _p : defaultRetrySettings.max_rpc_timeout_millis);\\n        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.retry_delay_multiplier`] =\\n            (_q = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.retry_delay_multiplier.toString()) !== null \u0026\u0026 _q !== void 0 ? _q : defaultRetrySettings.retry_delay_multiplier.toString();\\n        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.rpc_timeout_multiplier`] =\\n            (_r = customRetrySettings === null || customRetrySettings === void 0 ? void 0 : customRetrySettings.rpc_timeout_multiplier.toString()) !== null \u0026\u0026 _r !== void 0 ? _r : defaultRetrySettings.rpc_timeout_multiplier.toString();\\n    }\\n    recordProjectId(projectId) {\\n        this.settingsAttributes[`${trace_util_1.ATTRIBUTE_SETTINGS_PREFIX}.project_id`] =\\n            projectId;\\n        this.currentSpan().setAttributes(this.settingsAttributes);\\n    }\\n    millisToSecondString(millis) {\\n        return `${millis / 1000}s`;\\n    }\\n    endSpan(otelSpan, error) {\\n        otelSpan.setStatus({\\n            code: api_1.SpanStatusCode.ERROR,\\n            message: error.message,\\n        });\\n        otelSpan.recordException(error);\\n        otelSpan.end();\\n    }\\n    startActiveSpan(name, fn, attributes) {\\n        return this.tracer.startActiveSpan(name, {\\n            attributes: attributes,\\n        }, (otelSpan) =\u003e {\\n            this.addCommonAttributes(otelSpan);\\n            // Note that if `fn` returns a `Promise`, we want the otelSpan to end\\n            // after the `Promise` has resolved, NOT after the `fn` has returned.\\n            // Therefore, we should not use a `finally` clause to end the otelSpan.\\n            try {\\n                let result = fn(new span_1.Span(otelSpan));\\n                if (result instanceof Promise) {\\n                    result = result\\n                        .then(value =\u003e {\\n                        otelSpan.end();\\n                        return value;\\n                    })\\n                        .catch(error =\u003e {\\n                        this.endSpan(otelSpan, error);\\n                        // Returns a Promise.reject the same as the underlying function.\\n                        return Promise.reject(error);\\n                    });\\n                }\\n                else {\\n                    otelSpan.end();\\n                }\\n                return result;\\n            }\\n            catch (error) {\\n                this.endSpan(otelSpan, error);\\n                // Re-throw the exception to maintain normal error handling.\\n                throw error;\\n            }\\n        });\\n    }\\n    startSpan(name) {\\n        const otelSpan = this.tracer.startSpan(name, undefined, api_1.context.active());\\n        this.addCommonAttributes(otelSpan);\\n        return new span_1.Span(otelSpan);\\n    }\\n    currentSpan() {\\n        return new span_1.Span(api_1.trace.getActiveSpan());\\n    }\\n    addCommonAttributes(otelSpan) {\\n        otelSpan.setAttributes(this.settingsAttributes);\\n    }\\n},\\\"name\\\",{value:\\\"EnabledTraceUtil\\\"})\"\n"])</script><script>self.__next_f.push([1,"9a:\"$9b\"\n92:{\"tracerProvider\":\"$93\",\"tracer\":\"$96\",\"settingsAttributes\":\"$99\",\"\":\"$P9a\"}\n9c:{\"initialDelayMs\":100,\"maxDelayMs\":60000,\"backoffFactor\":1.3}\n"])</script><script>self.__next_f.push([1,"9e:\"$EObject.defineProperty((requiresGrpc) =\u003e {\\n            var _a;\\n            let client;\\n            // Use the rest fallback if enabled and if the method does not require GRPC\\n            const useFallback = !this._settings.preferRest || requiresGrpc ? false : 'rest';\\n            let gax;\\n            if (useFallback) {\\n                if (!this._gaxFallback) {\\n                    gax = this._gaxFallback = require('google-gax/build/src/fallback');\\n                }\\n                else {\\n                    gax = this._gaxFallback;\\n                }\\n            }\\n            else {\\n                if (!this._gax) {\\n                    gax = this._gax = require('google-gax');\\n                }\\n                else {\\n                    gax = this._gax;\\n                }\\n            }\\n            if (this._settings.ssl === false) {\\n                const grpcModule = (_a = this._settings.grpc) !== null \u0026\u0026 _a !== void 0 ? _a : require('google-gax').grpc;\\n                const sslCreds = grpcModule.credentials.createInsecure();\\n                const settings = {\\n                    sslCreds,\\n                    ...this._settings,\\n                    fallback: useFallback,\\n                };\\n                // Since `ssl === false`, if we're using the GAX fallback then\\n                // also set the `protocol` option for GAX fallback to force http\\n                if (useFallback) {\\n                    settings.protocol = 'http';\\n                }\\n                client = new module.exports.v1(settings, gax);\\n            }\\n            else {\\n                client = new module.exports.v1({\\n                    ...this._settings,\\n                    fallback: useFallback,\\n                }, gax);\\n            }\\n            (0, logger_1.logger)('clientFactory', null, 'Initialized Firestore GAPIC Client (useFallback: %s)', useFallback);\\n            return client;\\n        },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"9f:\"$EObject.defineProperty(client =\u003e client.close(),\\\"name\\\",{value:\\\"\\\"})\"\na2:{\"page\":\"$Y\",\"stream\":\"$Y\",\"longrunning\":\"$Y\",\"batching\":\"$Y\"}\n"])</script><script>self.__next_f.push([1,"a4:\"$EObject.defineProperty(class GoogleAuth {\\n    // Note:  this properly is only public to satisfy unit tests.\\n    // https://github.com/Microsoft/TypeScript/issues/5228\\n    get isGCE() {\\n        return this.checkIsGCE;\\n    }\\n    /**\\n     * Configuration is resolved in the following order of precedence:\\n     * - {@link GoogleAuthOptions.credentials `credentials`}\\n     * - {@link GoogleAuthOptions.keyFilename `keyFilename`}\\n     * - {@link GoogleAuthOptions.keyFile `keyFile`}\\n     *\\n     * {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the\\n     * {@link AuthClient `AuthClient`s}.\\n     *\\n     * @param opts\\n     */\\n    constructor(opts = {}) {\\n        _GoogleAuth_instances.add(this);\\n        /**\\n         * Caches a value indicating whether the auth layer is running on Google\\n         * Compute Engine.\\n         * @private\\n         */\\n        this.checkIsGCE = undefined;\\n        // To save the contents of the JSON credential file\\n        this.jsonContent = null;\\n        this.cachedCredential = null;\\n        /**\\n         * A pending {@link AuthClient}. Used for concurrent {@link GoogleAuth.getClient} calls.\\n         */\\n        _GoogleAuth_pendingAuthClient.set(this, null);\\n        this.clientOptions = {};\\n        this._cachedProjectId = opts.projectId || null;\\n        this.cachedCredential = opts.authClient || null;\\n        this.keyFilename = opts.keyFilename || opts.keyFile;\\n        this.scopes = opts.scopes;\\n        this.clientOptions = opts.clientOptions || {};\\n        this.jsonContent = opts.credentials || null;\\n        this.apiKey = opts.apiKey || this.clientOptions.apiKey || null;\\n        // Cannot use both API Key + Credentials\\n        if (this.apiKey \u0026\u0026 (this.jsonContent || this.clientOptions.credentials)) {\\n            throw new RangeError(exports.GoogleAuthExceptionMessages.API_KEY_WITH_CREDENTIALS);\\n        }\\n        if (opts.universeDomain) {\\n            this.clientOptions.universeDomain = opts.universeDomain;\\n        }\\n    }\\n    // GAPIC client libraries should always use self-signed JWTs. The following\\n    // variables are set on the JWT client in order to indicate the type of library,\\n    // and sign the JWT with the correct audience and scopes (if not supplied).\\n    setGapicJWTValues(client) {\\n        client.defaultServicePath = this.defaultServicePath;\\n        client.useJWTAccessWithScope = this.useJWTAccessWithScope;\\n        client.defaultScopes = this.defaultScopes;\\n    }\\n    getProjectId(callback) {\\n        if (callback) {\\n            this.getProjectIdAsync().then(r =\u003e callback(null, r), callback);\\n        }\\n        else {\\n            return this.getProjectIdAsync();\\n        }\\n    }\\n    /**\\n     * A temporary method for internal `getProjectId` usages where `null` is\\n     * acceptable. In a future major release, `getProjectId` should return `null`\\n     * (as the `Promise\u003cstring | null\u003e` base signature describes) and this private\\n     * method should be removed.\\n     *\\n     * @returns Promise that resolves with project id (or `null`)\\n     */\\n    async getProjectIdOptional() {\\n        try {\\n            return await this.getProjectId();\\n        }\\n        catch (e) {\\n            if (e instanceof Error \u0026\u0026\\n                e.message === exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {\\n                return null;\\n            }\\n            else {\\n                throw e;\\n            }\\n        }\\n    }\\n    /**\\n     * A private method for finding and caching a projectId.\\n     *\\n     * Supports environments in order of precedence:\\n     * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\\n     * - GOOGLE_APPLICATION_CREDENTIALS JSON file\\n     * - Cloud SDK: `gcloud config config-helper --format json`\\n     * - GCE project ID from metadata server\\n     *\\n     * @returns projectId\\n     */\\n    async findAndCacheProjectId() {\\n        let projectId = null;\\n        projectId || (projectId = await this.getProductionProjectId());\\n        projectId || (projectId = await this.getFileProjectId());\\n        projectId || (projectId = await this.getDefaultServiceProjectId());\\n        projectId || (projectId = await this.getGCEProjectId());\\n        projectId || (projectId = await this.getExternalAccountClientProjectId());\\n        if (projectId) {\\n            this._cachedProjectId = projectId;\\n            return projectId;\\n        }\\n        else {\\n            throw new Error(exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);\\n        }\\n    }\\n    async getProjectIdAsync() {\\n        if (this._cachedProjectId) {\\n            return this._cachedProjectId;\\n        }\\n        if (!this._findProjectIdPromise) {\\n            this._findProjectIdPromise = this.findAndCacheProjectId();\\n        }\\n        return this._findProjectIdPromise;\\n    }\\n    /**\\n     * Retrieves a universe domain from the metadata server via\\n     * {@link gcpMetadata.universe}.\\n     *\\n     * @returns a universe domain\\n     */\\n    async getUniverseDomainFromMetadataServer() {\\n        var _a;\\n        let universeDomain;\\n        try {\\n            universeDomain = await gcpMetadata.universe('universe-domain');\\n            universeDomain || (universeDomain = authclient_1.DEFAULT_UNIVERSE);\\n        }\\n        catch (e) {\\n            if (e \u0026\u0026 ((_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {\\n                universeDomain = authclient_1.DEFAULT_UNIVERSE;\\n            }\\n            else {\\n                throw e;\\n            }\\n        }\\n        return universeDomain;\\n    }\\n    /**\\n     * Retrieves, caches, and returns the universe domain in the following order\\n     * of precedence:\\n     * - The universe domain in {@link GoogleAuth.clientOptions}\\n     * - An existing or ADC {@link AuthClient}'s universe domain\\n     * - {@link gcpMetadata.universe}, if {@link Compute} client\\n     *\\n     * @returns The universe domain\\n     */\\n    async getUniverseDomain() {\\n        let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get('universe_domain');\\n        try {\\n            universeDomain !== null \u0026\u0026 universeDomain !== void 0 ? universeDomain : (universeDomain = (await this.getClient()).universeDomain);\\n        }\\n        catch (_a) {\\n            // client or ADC is not available\\n            universeDomain !== null \u0026\u0026 universeDomain !== void 0 ? universeDomain : (universeDomain = authclient_1.DEFAULT_UNIVERSE);\\n        }\\n        return universeDomain;\\n    }\\n    /**\\n     * @returns Any scopes (user-specified or default scopes specified by the\\n     *   client library) that need to be set on the current Auth client.\\n     */\\n    getAnyScopes() {\\n        return this.scopes || this.defaultScopes;\\n    }\\n    getApplicationDefault(optionsOrCallback = {}, callback) {\\n        let options;\\n        if (typeof optionsOrCallback === 'function') {\\n            callback = optionsOrCallback;\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        if (callback) {\\n            this.getApplicationDefaultAsync(options).then(r =\u003e callback(null, r.credential, r.projectId), callback);\\n        }\\n        else {\\n            return this.getApplicationDefaultAsync(options);\\n        }\\n    }\\n    async getApplicationDefaultAsync(options = {}) {\\n        // If we've already got a cached credential, return it.\\n        // This will also preserve one's configured quota project, in case they\\n        // set one directly on the credential previously.\\n        if (this.cachedCredential) {\\n            // cache, while preserving existing quota project preferences\\n            return await __classPrivateFieldGet(this, _GoogleAuth_instances, \\\"m\\\", _GoogleAuth_prepareAndCacheClient).call(this, this.cachedCredential, null);\\n        }\\n        let credential;\\n        // Check for the existence of a local environment variable pointing to the\\n        // location of the credential file. This is typically used in local\\n        // developer scenarios.\\n        credential =\\n            await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\\n        if (credential) {\\n            if (credential instanceof jwtclient_1.JWT) {\\n                credential.scopes = this.scopes;\\n            }\\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\\n                credential.scopes = this.getAnyScopes();\\n            }\\n            return await __classPrivateFieldGet(this, _GoogleAuth_instances, \\\"m\\\", _GoogleAuth_prepareAndCacheClient).call(this, credential);\\n        }\\n        // Look in the well-known credential file location.\\n        credential =\\n            await this._tryGetApplicationCredentialsFromWellKnownFile(options);\\n        if (credential) {\\n            if (credential instanceof jwtclient_1.JWT) {\\n                credential.scopes = this.scopes;\\n            }\\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\\n                credential.scopes = this.getAnyScopes();\\n            }\\n            return await __classPrivateFieldGet(this, _GoogleAuth_instances, \\\"m\\\", _GoogleAuth_prepareAndCacheClient).call(this, credential);\\n        }\\n        // Determine if we're running on GCE.\\n        if (await this._checkIsGCE()) {\\n            options.scopes = this.getAnyScopes();\\n            return await __classPrivateFieldGet(this, _GoogleAuth_instances, \\\"m\\\", _GoogleAuth_prepareAndCacheClient).call(this, new computeclient_1.Compute(options));\\n        }\\n        throw new Error(exports.GoogleAuthExceptionMessages.NO_ADC_FOUND);\\n    }\\n    /**\\n     * Determines whether the auth layer is running on Google Compute Engine.\\n     * Checks for GCP Residency, then fallback to checking if metadata server\\n     * is available.\\n     *\\n     * @returns A promise that resolves with the boolean.\\n     * @api private\\n     */\\n    async _checkIsGCE() {\\n        if (this.checkIsGCE === undefined) {\\n            this.checkIsGCE =\\n                gcpMetadata.getGCPResidency() || (await gcpMetadata.isAvailable());\\n        }\\n        return this.checkIsGCE;\\n    }\\n    /**\\n     * Attempts to load default credentials from the environment variable path..\\n     * @returns Promise that resolves with the OAuth2Client or null.\\n     * @api private\\n     */\\n    async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\\n        const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] ||\\n            process.env['google_application_credentials'];\\n        if (!credentialsPath || credentialsPath.length === 0) {\\n            return null;\\n        }\\n        try {\\n            return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\\n        }\\n        catch (e) {\\n            if (e instanceof Error) {\\n                e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\\n            }\\n            throw e;\\n        }\\n    }\\n    /**\\n     * Attempts to load default credentials from a well-known file location\\n     * @return Promise that resolves with the OAuth2Client or null.\\n     * @api private\\n     */\\n    async _tryGetApplicationCredentialsFromWellKnownFile(options) {\\n        // First, figure out the location of the file, depending upon the OS type.\\n        let location = null;\\n        if (this._isWindows()) {\\n            // Windows\\n            location = process.env['APPDATA'];\\n        }\\n        else {\\n            // Linux or Mac\\n            const home = process.env['HOME'];\\n            if (home) {\\n                location = path.join(home, '.config');\\n            }\\n        }\\n        // If we found the root path, expand it.\\n        if (location) {\\n            location = path.join(location, 'gcloud', 'application_default_credentials.json');\\n            if (!fs.existsSync(location)) {\\n                location = null;\\n            }\\n        }\\n        // The file does not exist.\\n        if (!location) {\\n            return null;\\n        }\\n        // The file seems to exist. Try to use it.\\n        const client = await this._getApplicationCredentialsFromFilePath(location, options);\\n        return client;\\n    }\\n    /**\\n     * Attempts to load default credentials from a file at the given path..\\n     * @param filePath The path to the file to read.\\n     * @returns Promise that resolves with the OAuth2Client\\n     * @api private\\n     */\\n    async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\\n        // Make sure the path looks like a string.\\n        if (!filePath || filePath.length === 0) {\\n            throw new Error('The file path is invalid.');\\n        }\\n        // Make sure there is a file at the path. lstatSync will throw if there is\\n        // nothing there.\\n        try {\\n            // Resolve path to actual file in case of symlink. Expect a thrown error\\n            // if not resolvable.\\n            filePath = fs.realpathSync(filePath);\\n            if (!fs.lstatSync(filePath).isFile()) {\\n                throw new Error();\\n            }\\n        }\\n        catch (err) {\\n            if (err instanceof Error) {\\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\\n            }\\n            throw err;\\n        }\\n        // Now open a read stream on the file, and parse it.\\n        const readStream = fs.createReadStream(filePath);\\n        return this.fromStream(readStream, options);\\n    }\\n    /**\\n     * Create a credentials instance using a given impersonated input options.\\n     * @param json The impersonated input object.\\n     * @returns JWT or UserRefresh Client with data\\n     */\\n    fromImpersonatedJSON(json) {\\n        var _a, _b, _c, _d;\\n        if (!json) {\\n            throw new Error('Must pass in a JSON object containing an  impersonated refresh token');\\n        }\\n        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\\n            throw new Error(`The incoming JSON object does not have the \\\"${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}\\\" type`);\\n        }\\n        if (!json.source_credentials) {\\n            throw new Error('The incoming JSON object does not contain a source_credentials field');\\n        }\\n        if (!json.service_account_impersonation_url) {\\n            throw new Error('The incoming JSON object does not contain a service_account_impersonation_url field');\\n        }\\n        const sourceClient = this.fromJSON(json.source_credentials);\\n        if (((_a = json.service_account_impersonation_url) === null || _a === void 0 ? void 0 : _a.length) \u003e 256) {\\n            /**\\n             * Prevents DOS attacks.\\n             * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/85}\\n             **/\\n            throw new RangeError(`Target principal is too long: ${json.service_account_impersonation_url}`);\\n        }\\n        // Extract service account from service_account_impersonation_url\\n        const targetPrincipal = (_c = (_b = /(?\u003ctarget\u003e[^/]+):(generateAccessToken|generateIdToken)$/.exec(json.service_account_impersonation_url)) === null || _b === void 0 ? void 0 : _b.groups) === null || _c === void 0 ? void 0 : _c.target;\\n        if (!targetPrincipal) {\\n            throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);\\n        }\\n        const targetScopes = (_d = this.getAnyScopes()) !== null \u0026\u0026 _d !== void 0 ? _d : [];\\n        return new impersonated_1.Impersonated({\\n            ...json,\\n            sourceClient,\\n            targetPrincipal,\\n            targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes],\\n        });\\n    }\\n    /**\\n     * Create a credentials instance using the given input options.\\n     * This client is not cached.\\n     *\\n     * **Important**: If you accept a credential configuration (credential JSON/File/Stream) from an external source for authentication to Google Cloud, you must validate it before providing it to any Google API or library. Providing an unvalidated credential configuration to Google APIs can compromise the security of your systems and data. For more information, refer to {@link https://cloud.google.com/docs/authentication/external/externally-sourced-credentials Validate credential configurations from external sources}.\\n     *\\n     * @param json The input object.\\n     * @param options The JWT or UserRefresh options for the client\\n     * @returns JWT or UserRefresh Client with data\\n     */\\n    fromJSON(json, options = {}) {\\n        let client;\\n        // user's preferred universe domain\\n        const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get('universe_domain');\\n        if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {\\n            client = new refreshclient_1.UserRefreshClient(options);\\n            client.fromJSON(json);\\n        }\\n        else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\\n            client = this.fromImpersonatedJSON(json);\\n        }\\n        else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\\n            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\\n            client.scopes = this.getAnyScopes();\\n        }\\n        else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {\\n            client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);\\n        }\\n        else {\\n            options.scopes = this.scopes;\\n            client = new jwtclient_1.JWT(options);\\n            this.setGapicJWTValues(client);\\n            client.fromJSON(json);\\n        }\\n        if (preferredUniverseDomain) {\\n            client.universeDomain = preferredUniverseDomain;\\n        }\\n        return client;\\n    }\\n    /**\\n     * Return a JWT or UserRefreshClient from JavaScript object, caching both the\\n     * object used to instantiate and the client.\\n     * @param json The input object.\\n     * @param options The JWT or UserRefresh options for the client\\n     * @returns JWT or UserRefresh Client with data\\n     */\\n    _cacheClientFromJSON(json, options) {\\n        const client = this.fromJSON(json, options);\\n        // cache both raw data used to instantiate client and client itself.\\n        this.jsonContent = json;\\n        this.cachedCredential = client;\\n        return client;\\n    }\\n    fromStream(inputStream, optionsOrCallback = {}, callback) {\\n        let options = {};\\n        if (typeof optionsOrCallback === 'function') {\\n            callback = optionsOrCallback;\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        if (callback) {\\n            this.fromStreamAsync(inputStream, options).then(r =\u003e callback(null, r), callback);\\n        }\\n        else {\\n            return this.fromStreamAsync(inputStream, options);\\n        }\\n    }\\n    fromStreamAsync(inputStream, options) {\\n        return new Promise((resolve, reject) =\u003e {\\n            if (!inputStream) {\\n                throw new Error('Must pass in a stream containing the Google auth settings.');\\n            }\\n            const chunks = [];\\n            inputStream\\n                .setEncoding('utf8')\\n                .on('error', reject)\\n                .on('data', chunk =\u003e chunks.push(chunk))\\n                .on('end', () =\u003e {\\n                try {\\n                    try {\\n                        const data = JSON.parse(chunks.join(''));\\n                        const r = this._cacheClientFromJSON(data, options);\\n                        return resolve(r);\\n                    }\\n                    catch (err) {\\n                        // If we failed parsing this.keyFileName, assume that it\\n                        // is a PEM or p12 certificate:\\n                        if (!this.keyFilename)\\n                            throw err;\\n                        const client = new jwtclient_1.JWT({\\n                            ...this.clientOptions,\\n                            keyFile: this.keyFilename,\\n                        });\\n                        this.cachedCredential = client;\\n                        this.setGapicJWTValues(client);\\n                        return resolve(client);\\n                    }\\n                }\\n                catch (err) {\\n                    return reject(err);\\n                }\\n            });\\n        });\\n    }\\n    /**\\n     * Create a credentials instance using the given API key string.\\n     * The created client is not cached. In order to create and cache it use the {@link GoogleAuth.getClient `getClient`} method after first providing an {@link GoogleAuth.apiKey `apiKey`}.\\n     *\\n     * @param apiKey The API key string\\n     * @param options An optional options object.\\n     * @returns A JWT loaded from the key\\n     */\\n    fromAPIKey(apiKey, options = {}) {\\n        return new jwtclient_1.JWT({ ...options, apiKey });\\n    }\\n    /**\\n     * Determines whether the current operating system is Windows.\\n     * @api private\\n     */\\n    _isWindows() {\\n        const sys = os.platform();\\n        if (sys \u0026\u0026 sys.length \u003e= 3) {\\n            if (sys.substring(0, 3).toLowerCase() === 'win') {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    /**\\n     * Run the Google Cloud SDK command that prints the default project ID\\n     */\\n    async getDefaultServiceProjectId() {\\n        return new Promise(resolve =\u003e {\\n            (0, child_process_1.exec)('gcloud config config-helper --format json', (err, stdout) =\u003e {\\n                if (!err \u0026\u0026 stdout) {\\n                    try {\\n                        const projectId = JSON.parse(stdout).configuration.properties.core.project;\\n                        resolve(projectId);\\n                        return;\\n                    }\\n                    catch (e) {\\n                        // ignore errors\\n                    }\\n                }\\n                resolve(null);\\n            });\\n        });\\n    }\\n    /**\\n     * Loads the project id from environment variables.\\n     * @api private\\n     */\\n    getProductionProjectId() {\\n        return (process.env['GCLOUD_PROJECT'] ||\\n            process.env['GOOGLE_CLOUD_PROJECT'] ||\\n            process.env['gcloud_project'] ||\\n            process.env['google_cloud_project']);\\n    }\\n    /**\\n     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\\n     * @api private\\n     */\\n    async getFileProjectId() {\\n        if (this.cachedCredential) {\\n            // Try to read the project ID from the cached credentials file\\n            return this.cachedCredential.projectId;\\n        }\\n        // Ensure the projectId is loaded from the keyFile if available.\\n        if (this.keyFilename) {\\n            const creds = await this.getClient();\\n            if (creds \u0026\u0026 creds.projectId) {\\n                return creds.projectId;\\n            }\\n        }\\n        // Try to load a credentials file and read its project ID\\n        const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\\n        if (r) {\\n            return r.projectId;\\n        }\\n        else {\\n            return null;\\n        }\\n    }\\n    /**\\n     * Gets the project ID from external account client if available.\\n     */\\n    async getExternalAccountClientProjectId() {\\n        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\\n            return null;\\n        }\\n        const creds = await this.getClient();\\n        // Do not suppress the underlying error, as the error could contain helpful\\n        // information for debugging and fixing. This is especially true for\\n        // external account creds as in order to get the project ID, the following\\n        // operations have to succeed:\\n        // 1. Valid credentials file should be supplied.\\n        // 2. Ability to retrieve access tokens from STS token exchange API.\\n        // 3. Ability to exchange for service account impersonated credentials (if\\n        //    enabled).\\n        // 4. Ability to get project info using the access token from step 2 or 3.\\n        // Without surfacing the error, it is harder for developers to determine\\n        // which step went wrong.\\n        return await creds.getProjectId();\\n    }\\n    /**\\n     * Gets the Compute Engine project ID if it can be inferred.\\n     */\\n    async getGCEProjectId() {\\n        try {\\n            const r = await gcpMetadata.project('project-id');\\n            return r;\\n        }\\n        catch (e) {\\n            // Ignore any errors\\n            return null;\\n        }\\n    }\\n    getCredentials(callback) {\\n        if (callback) {\\n            this.getCredentialsAsync().then(r =\u003e callback(null, r), callback);\\n        }\\n        else {\\n            return this.getCredentialsAsync();\\n        }\\n    }\\n    async getCredentialsAsync() {\\n        const client = await this.getClient();\\n        if (client instanceof impersonated_1.Impersonated) {\\n            return { client_email: client.getTargetPrincipal() };\\n        }\\n        if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {\\n            const serviceAccountEmail = client.getServiceAccountEmail();\\n            if (serviceAccountEmail) {\\n                return {\\n                    client_email: serviceAccountEmail,\\n                    universe_domain: client.universeDomain,\\n                };\\n            }\\n        }\\n        if (this.jsonContent) {\\n            return {\\n                client_email: this.jsonContent.client_email,\\n                private_key: this.jsonContent.private_key,\\n                universe_domain: this.jsonContent.universe_domain,\\n            };\\n        }\\n        if (await this._checkIsGCE()) {\\n            const [client_email, universe_domain] = await Promise.all([\\n                gcpMetadata.instance('service-accounts/default/email'),\\n                this.getUniverseDomain(),\\n            ]);\\n            return { client_email, universe_domain };\\n        }\\n        throw new Error(exports.GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);\\n    }\\n    /**\\n     * Automatically obtain an {@link AuthClient `AuthClient`} based on the\\n     * provided configuration. If no options were passed, use Application\\n     * Default Credentials.\\n     */\\n    async getClient() {\\n        if (this.cachedCredential) {\\n            return this.cachedCredential;\\n        }\\n        // Use an existing auth client request, or cache a new one\\n        __classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, \\\"f\\\") || __classPrivateFieldGet(this, _GoogleAuth_instances, \\\"m\\\", _GoogleAuth_determineClient).call(this), \\\"f\\\");\\n        try {\\n            return await __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, \\\"f\\\");\\n        }\\n        finally {\\n            // reset the pending auth client in case it is changed later\\n            __classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, null, \\\"f\\\");\\n        }\\n    }\\n    /**\\n     * Creates a client which will fetch an ID token for authorization.\\n     * @param targetAudience the audience for the fetched ID token.\\n     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\\n     */\\n    async getIdTokenClient(targetAudience) {\\n        const client = await this.getClient();\\n        if (!('fetchIdToken' in client)) {\\n            throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\\n        }\\n        return new idtokenclient_1.IdTokenClient({ targetAudience, idTokenProvider: client });\\n    }\\n    /**\\n     * Automatically obtain application default credentials, and return\\n     * an access token for making requests.\\n     */\\n    async getAccessToken() {\\n        const client = await this.getClient();\\n        return (await client.getAccessToken()).token;\\n    }\\n    /**\\n     * Obtain the HTTP headers that will provide authorization for a given\\n     * request.\\n     */\\n    async getRequestHeaders(url) {\\n        const client = await this.getClient();\\n        return client.getRequestHeaders(url);\\n    }\\n    /**\\n     * Obtain credentials for a request, then attach the appropriate headers to\\n     * the request options.\\n     * @param opts Axios or Request options on which to attach the headers\\n     */\\n    async authorizeRequest(opts) {\\n        opts = opts || {};\\n        const url = opts.url || opts.uri;\\n        const client = await this.getClient();\\n        const headers = await client.getRequestHeaders(url);\\n        opts.headers = Object.assign(opts.headers || {}, headers);\\n        return opts;\\n    }\\n    /**\\n     * Automatically obtain application default credentials, and make an\\n     * HTTP request using the given options.\\n     * @param opts Axios request options for the HTTP request.\\n     */\\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    async request(opts) {\\n        const client = await this.getClient();\\n        return client.request(opts);\\n    }\\n    /**\\n     * Determine the compute environment in which the code is running.\\n     */\\n    getEnv() {\\n        return (0, envDetect_1.getEnv)();\\n    }\\n    /**\\n     * Sign the given data with the current private key, or go out\\n     * to the IAM API to sign it.\\n     * @param data The data to be signed.\\n     * @param endpoint A custom endpoint to use.\\n     *\\n     * @example\\n     * ```\\n     * sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');\\n     * ```\\n     */\\n    async sign(data, endpoint) {\\n        const client = await this.getClient();\\n        const universe = await this.getUniverseDomain();\\n        endpoint =\\n            endpoint ||\\n                `https://iamcredentials.${universe}/v1/projects/-/serviceAccounts/`;\\n        if (client instanceof impersonated_1.Impersonated) {\\n            const signed = await client.sign(data);\\n            return signed.signedBlob;\\n        }\\n        const crypto = (0, crypto_1.createCrypto)();\\n        if (client instanceof jwtclient_1.JWT \u0026\u0026 client.key) {\\n            const sign = await crypto.sign(client.key, data);\\n            return sign;\\n        }\\n        const creds = await this.getCredentials();\\n        if (!creds.client_email) {\\n            throw new Error('Cannot sign data without `client_email`.');\\n        }\\n        return this.signBlob(crypto, creds.client_email, data, endpoint);\\n    }\\n    async signBlob(crypto, emailOrUniqueId, data, endpoint) {\\n        const url = new URL(endpoint + `${emailOrUniqueId}:signBlob`);\\n        const res = await this.request({\\n            method: 'POST',\\n            url: url.href,\\n            data: {\\n                payload: crypto.encodeBase64StringUtf8(data),\\n            },\\n            retry: true,\\n            retryConfig: {\\n                httpMethodsToRetry: ['POST'],\\n            },\\n        });\\n        return res.data.signedBlob;\\n    }\\n},\\\"name\\\",{value:\\\"GoogleAuth\\\"})\"\n"])</script><script>self.__next_f.push([1,"a5:\"$EObject.defineProperty(class Metadata {\\n    constructor(options = {}) {\\n        this.internalRepr = new Map();\\n        this.options = options;\\n    }\\n    /**\\n     * Sets the given value for the given key by replacing any other values\\n     * associated with that key. Normalizes the key.\\n     * @param key The key to whose value should be set.\\n     * @param value The value to set. Must be a buffer if and only\\n     *   if the normalized key ends with '-bin'.\\n     */\\n    set(key, value) {\\n        key = normalizeKey(key);\\n        validate(key, value);\\n        this.internalRepr.set(key, [value]);\\n    }\\n    /**\\n     * Adds the given value for the given key by appending to a list of previous\\n     * values associated with that key. Normalizes the key.\\n     * @param key The key for which a new value should be appended.\\n     * @param value The value to add. Must be a buffer if and only\\n     *   if the normalized key ends with '-bin'.\\n     */\\n    add(key, value) {\\n        key = normalizeKey(key);\\n        validate(key, value);\\n        const existingValue = this.internalRepr.get(key);\\n        if (existingValue === undefined) {\\n            this.internalRepr.set(key, [value]);\\n        }\\n        else {\\n            existingValue.push(value);\\n        }\\n    }\\n    /**\\n     * Removes the given key and any associated values. Normalizes the key.\\n     * @param key The key whose values should be removed.\\n     */\\n    remove(key) {\\n        key = normalizeKey(key);\\n        // validate(key);\\n        this.internalRepr.delete(key);\\n    }\\n    /**\\n     * Gets a list of all values associated with the key. Normalizes the key.\\n     * @param key The key whose value should be retrieved.\\n     * @return A list of values associated with the given key.\\n     */\\n    get(key) {\\n        key = normalizeKey(key);\\n        // validate(key);\\n        return this.internalRepr.get(key) || [];\\n    }\\n    /**\\n     * Gets a plain object mapping each key to the first value associated with it.\\n     * This reflects the most common way that people will want to see metadata.\\n     * @return A key/value mapping of the metadata.\\n     */\\n    getMap() {\\n        const result = {};\\n        for (const [key, values] of this.internalRepr) {\\n            if (values.length \u003e 0) {\\n                const v = values[0];\\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\\n            }\\n        }\\n        return result;\\n    }\\n    /**\\n     * Clones the metadata object.\\n     * @return The newly cloned object.\\n     */\\n    clone() {\\n        const newMetadata = new Metadata(this.options);\\n        const newInternalRepr = newMetadata.internalRepr;\\n        for (const [key, value] of this.internalRepr) {\\n            const clonedValue = value.map(v =\u003e {\\n                if (Buffer.isBuffer(v)) {\\n                    return Buffer.from(v);\\n                }\\n                else {\\n                    return v;\\n                }\\n            });\\n            newInternalRepr.set(key, clonedValue);\\n        }\\n        return newMetadata;\\n    }\\n    /**\\n     * Merges all key-value pairs from a given Metadata object into this one.\\n     * If both this object and the given object have values in the same key,\\n     * values from the other Metadata object will be appended to this object's\\n     * values.\\n     * @param other A Metadata object.\\n     */\\n    merge(other) {\\n        for (const [key, values] of other.internalRepr) {\\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\\n            this.internalRepr.set(key, mergedValue);\\n        }\\n    }\\n    setOptions(options) {\\n        this.options = options;\\n    }\\n    getOptions() {\\n        return this.options;\\n    }\\n    /**\\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\\n     */\\n    toHttp2Headers() {\\n        // NOTE: Node \u003c8.9 formats http2 headers incorrectly.\\n        const result = {};\\n        for (const [key, values] of this.internalRepr) {\\n            // We assume that the user's interaction with this object is limited to\\n            // through its public API (i.e. keys and values are already validated).\\n            result[key] = values.map(bufToString);\\n        }\\n        return result;\\n    }\\n    /**\\n     * This modifies the behavior of JSON.stringify to show an object\\n     * representation of the metadata map.\\n     */\\n    toJSON() {\\n        const result = {};\\n        for (const [key, values] of this.internalRepr) {\\n            result[key] = values;\\n        }\\n        return result;\\n    }\\n    /**\\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\\n     * object.\\n     * @param headers An IncomingHttpHeaders object.\\n     */\\n    static fromHttp2Headers(headers) {\\n        const result = new Metadata();\\n        for (const key of Object.keys(headers)) {\\n            // Reserved headers (beginning with `:`) are not valid keys.\\n            if (key.charAt(0) === ':') {\\n                continue;\\n            }\\n            const values = headers[key];\\n            try {\\n                if (isBinaryKey(key)) {\\n                    if (Array.isArray(values)) {\\n                        values.forEach(value =\u003e {\\n                            result.add(key, Buffer.from(value, 'base64'));\\n                        });\\n                    }\\n                    else if (values !== undefined) {\\n                        if (isCustomMetadata(key)) {\\n                            values.split(',').forEach(v =\u003e {\\n                                result.add(key, Buffer.from(v.trim(), 'base64'));\\n                            });\\n                        }\\n                        else {\\n                            result.add(key, Buffer.from(values, 'base64'));\\n                        }\\n                    }\\n                }\\n                else {\\n                    if (Array.isArray(values)) {\\n                        values.forEach(value =\u003e {\\n                            result.add(key, value);\\n                        });\\n                    }\\n                    else if (values !== undefined) {\\n                        result.add(key, values);\\n                    }\\n                }\\n            }\\n            catch (error) {\\n                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);\\n            }\\n        }\\n        return result;\\n    }\\n},\\\"name\\\",{value:\\\"Metadata\\\"})\"\n"])</script><script>self.__next_f.push([1,"a6:\"$EObject.defineProperty(class Client {\\n    constructor(address, credentials, options = {}) {\\n        var _a, _b;\\n        options = Object.assign({}, options);\\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null \u0026\u0026 _a !== void 0 ? _a : [];\\n        delete options.interceptors;\\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null \u0026\u0026 _b !== void 0 ? _b : [];\\n        delete options.interceptor_providers;\\n        if (this[INTERCEPTOR_SYMBOL].length \u003e 0 \u0026\u0026\\n            this[INTERCEPTOR_PROVIDER_SYMBOL].length \u003e 0) {\\n            throw new Error('Both interceptors and interceptor_providers were passed as options ' +\\n                'to the client constructor. Only one of these is allowed.');\\n        }\\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =\\n            options.callInvocationTransformer;\\n        delete options.callInvocationTransformer;\\n        if (options.channelOverride) {\\n            this[CHANNEL_SYMBOL] = options.channelOverride;\\n        }\\n        else if (options.channelFactoryOverride) {\\n            const channelFactoryOverride = options.channelFactoryOverride;\\n            delete options.channelFactoryOverride;\\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\\n        }\\n        else {\\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\\n        }\\n    }\\n    close() {\\n        this[CHANNEL_SYMBOL].close();\\n    }\\n    getChannel() {\\n        return this[CHANNEL_SYMBOL];\\n    }\\n    waitForReady(deadline, callback) {\\n        const checkState = (err) =\u003e {\\n            if (err) {\\n                callback(new Error('Failed to connect before the deadline'));\\n                return;\\n            }\\n            let newState;\\n            try {\\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\\n            }\\n            catch (e) {\\n                callback(new Error('The channel has been closed'));\\n                return;\\n            }\\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\\n                callback();\\n            }\\n            else {\\n                try {\\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\\n                }\\n                catch (e) {\\n                    callback(new Error('The channel has been closed'));\\n                }\\n            }\\n        };\\n        setImmediate(checkState);\\n    }\\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\\n        if (isFunction(arg1)) {\\n            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };\\n        }\\n        else if (isFunction(arg2)) {\\n            if (arg1 instanceof metadata_1.Metadata) {\\n                return { metadata: arg1, options: {}, callback: arg2 };\\n            }\\n            else {\\n                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };\\n            }\\n        }\\n        else {\\n            if (!(arg1 instanceof metadata_1.Metadata \u0026\u0026\\n                arg2 instanceof Object \u0026\u0026\\n                isFunction(arg3))) {\\n                throw new Error('Incorrect arguments passed');\\n            }\\n            return { metadata: arg1, options: arg2, callback: arg3 };\\n        }\\n    }\\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\\n        var _a, _b;\\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\\n        const methodDefinition = {\\n            path: method,\\n            requestStream: false,\\n            responseStream: false,\\n            requestSerialize: serialize,\\n            responseDeserialize: deserialize,\\n        };\\n        let callProperties = {\\n            argument: argument,\\n            metadata: checkedArguments.metadata,\\n            call: new call_1.ClientUnaryCallImpl(),\\n            channel: this[CHANNEL_SYMBOL],\\n            methodDefinition: methodDefinition,\\n            callOptions: checkedArguments.options,\\n            callback: checkedArguments.callback,\\n        };\\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\\n        }\\n        const emitter = callProperties.call;\\n        const interceptorArgs = {\\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null \u0026\u0026 _a !== void 0 ? _a : [],\\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null \u0026\u0026 _b !== void 0 ? _b : [],\\n        };\\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\\n        /* This needs to happen before the emitter is used. Unfortunately we can't\\n         * enforce this with the type system. We need to construct this emitter\\n         * before calling the CallInvocationTransformer, and we need to create the\\n         * call after that. */\\n        emitter.call = call;\\n        let responseMessage = null;\\n        let receivedStatus = false;\\n        let callerStackError = new Error();\\n        call.start(callProperties.metadata, {\\n            onReceiveMetadata: metadata =\u003e {\\n                emitter.emit('metadata', metadata);\\n            },\\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n            onReceiveMessage(message) {\\n                if (responseMessage !== null) {\\n                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');\\n                }\\n                responseMessage = message;\\n            },\\n            onReceiveStatus(status) {\\n                if (receivedStatus) {\\n                    return;\\n                }\\n                receivedStatus = true;\\n                if (status.code === constants_1.Status.OK) {\\n                    if (responseMessage === null) {\\n                        const callerStack = getErrorStackString(callerStackError);\\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\\n                            code: constants_1.Status.UNIMPLEMENTED,\\n                            details: 'No message received',\\n                            metadata: status.metadata,\\n                        }, callerStack));\\n                    }\\n                    else {\\n                        callProperties.callback(null, responseMessage);\\n                    }\\n                }\\n                else {\\n                    const callerStack = getErrorStackString(callerStackError);\\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\\n                }\\n                /* Avoid retaining the callerStackError object in the call context of\\n                 * the status event handler. */\\n                callerStackError = null;\\n                emitter.emit('status', status);\\n            },\\n        });\\n        call.sendMessage(argument);\\n        call.halfClose();\\n        return emitter;\\n    }\\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\\n        var _a, _b;\\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\\n        const methodDefinition = {\\n            path: method,\\n            requestStream: true,\\n            responseStream: false,\\n            requestSerialize: serialize,\\n            responseDeserialize: deserialize,\\n        };\\n        let callProperties = {\\n            metadata: checkedArguments.metadata,\\n            call: new call_1.ClientWritableStreamImpl(serialize),\\n            channel: this[CHANNEL_SYMBOL],\\n            methodDefinition: methodDefinition,\\n            callOptions: checkedArguments.options,\\n            callback: checkedArguments.callback,\\n        };\\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\\n        }\\n        const emitter = callProperties.call;\\n        const interceptorArgs = {\\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null \u0026\u0026 _a !== void 0 ? _a : [],\\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null \u0026\u0026 _b !== void 0 ? _b : [],\\n        };\\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\\n        /* This needs to happen before the emitter is used. Unfortunately we can't\\n         * enforce this with the type system. We need to construct this emitter\\n         * before calling the CallInvocationTransformer, and we need to create the\\n         * call after that. */\\n        emitter.call = call;\\n        let responseMessage = null;\\n        let receivedStatus = false;\\n        let callerStackError = new Error();\\n        call.start(callProperties.metadata, {\\n            onReceiveMetadata: metadata =\u003e {\\n                emitter.emit('metadata', metadata);\\n            },\\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n            onReceiveMessage(message) {\\n                if (responseMessage !== null) {\\n                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');\\n                }\\n                responseMessage = message;\\n                call.startRead();\\n            },\\n            onReceiveStatus(status) {\\n                if (receivedStatus) {\\n                    return;\\n                }\\n                receivedStatus = true;\\n                if (status.code === constants_1.Status.OK) {\\n                    if (responseMessage === null) {\\n                        const callerStack = getErrorStackString(callerStackError);\\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\\n                            code: constants_1.Status.UNIMPLEMENTED,\\n                            details: 'No message received',\\n                            metadata: status.metadata,\\n                        }, callerStack));\\n                    }\\n                    else {\\n                        callProperties.callback(null, responseMessage);\\n                    }\\n                }\\n                else {\\n                    const callerStack = getErrorStackString(callerStackError);\\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\\n                }\\n                /* Avoid retaining the callerStackError object in the call context of\\n                 * the status event handler. */\\n                callerStackError = null;\\n                emitter.emit('status', status);\\n            },\\n        });\\n        return emitter;\\n    }\\n    checkMetadataAndOptions(arg1, arg2) {\\n        let metadata;\\n        let options;\\n        if (arg1 instanceof metadata_1.Metadata) {\\n            metadata = arg1;\\n            if (arg2) {\\n                options = arg2;\\n            }\\n            else {\\n                options = {};\\n            }\\n        }\\n        else {\\n            if (arg1) {\\n                options = arg1;\\n            }\\n            else {\\n                options = {};\\n            }\\n            metadata = new metadata_1.Metadata();\\n        }\\n        return { metadata, options };\\n    }\\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\\n        var _a, _b;\\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\\n        const methodDefinition = {\\n            path: method,\\n            requestStream: false,\\n            responseStream: true,\\n            requestSerialize: serialize,\\n            responseDeserialize: deserialize,\\n        };\\n        let callProperties = {\\n            argument: argument,\\n            metadata: checkedArguments.metadata,\\n            call: new call_1.ClientReadableStreamImpl(deserialize),\\n            channel: this[CHANNEL_SYMBOL],\\n            methodDefinition: methodDefinition,\\n            callOptions: checkedArguments.options,\\n        };\\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\\n        }\\n        const stream = callProperties.call;\\n        const interceptorArgs = {\\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null \u0026\u0026 _a !== void 0 ? _a : [],\\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null \u0026\u0026 _b !== void 0 ? _b : [],\\n        };\\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\\n        /* This needs to happen before the emitter is used. Unfortunately we can't\\n         * enforce this with the type system. We need to construct this emitter\\n         * before calling the CallInvocationTransformer, and we need to create the\\n         * call after that. */\\n        stream.call = call;\\n        let receivedStatus = false;\\n        let callerStackError = new Error();\\n        call.start(callProperties.metadata, {\\n            onReceiveMetadata(metadata) {\\n                stream.emit('metadata', metadata);\\n            },\\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n            onReceiveMessage(message) {\\n                stream.push(message);\\n            },\\n            onReceiveStatus(status) {\\n                if (receivedStatus) {\\n                    return;\\n                }\\n                receivedStatus = true;\\n                stream.push(null);\\n                if (status.code !== constants_1.Status.OK) {\\n                    const callerStack = getErrorStackString(callerStackError);\\n                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\\n                }\\n                /* Avoid retaining the callerStackError object in the call context of\\n                 * the status event handler. */\\n                callerStackError = null;\\n                stream.emit('status', status);\\n            },\\n        });\\n        call.sendMessage(argument);\\n        call.halfClose();\\n        return stream;\\n    }\\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\\n        var _a, _b;\\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\\n        const methodDefinition = {\\n            path: method,\\n            requestStream: true,\\n            responseStream: true,\\n            requestSerialize: serialize,\\n            responseDeserialize: deserialize,\\n        };\\n        let callProperties = {\\n            metadata: checkedArguments.metadata,\\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\\n            channel: this[CHANNEL_SYMBOL],\\n            methodDefinition: methodDefinition,\\n            callOptions: checkedArguments.options,\\n        };\\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\\n        }\\n        const stream = callProperties.call;\\n        const interceptorArgs = {\\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null \u0026\u0026 _a !== void 0 ? _a : [],\\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null \u0026\u0026 _b !== void 0 ? _b : [],\\n        };\\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\\n        /* This needs to happen before the emitter is used. Unfortunately we can't\\n         * enforce this with the type system. We need to construct this emitter\\n         * before calling the CallInvocationTransformer, and we need to create the\\n         * call after that. */\\n        stream.call = call;\\n        let receivedStatus = false;\\n        let callerStackError = new Error();\\n        call.start(callProperties.metadata, {\\n            onReceiveMetadata(metadata) {\\n                stream.emit('metadata', metadata);\\n            },\\n            onReceiveMessage(message) {\\n                stream.push(message);\\n            },\\n            onReceiveStatus(status) {\\n                if (receivedStatus) {\\n                    return;\\n                }\\n                receivedStatus = true;\\n                stream.push(null);\\n                if (status.code !== constants_1.Status.OK) {\\n                    const callerStack = getErrorStackString(callerStackError);\\n                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\\n                }\\n                /* Avoid retaining the callerStackError object in the call context of\\n                 * the status event handler. */\\n                callerStackError = null;\\n                stream.emit('status', status);\\n            },\\n        });\\n        return stream;\\n    }\\n},\\\"name\\\",{value:\\\"Client\\\"})\"\n"])</script><script>self.__next_f.push([1,"a7:\"$EObject.defineProperty(function loadPackageDefinition(packageDef) {\\n    const result = {};\\n    for (const serviceFqn in packageDef) {\\n        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\\n            const service = packageDef[serviceFqn];\\n            const nameComponents = serviceFqn.split('.');\\n            if (nameComponents.some((comp) =\u003e isPrototypePolluted(comp))) {\\n                continue;\\n            }\\n            const serviceName = nameComponents[nameComponents.length - 1];\\n            let current = result;\\n            for (const packageName of nameComponents.slice(0, -1)) {\\n                if (!current[packageName]) {\\n                    current[packageName] = {};\\n                }\\n                current = current[packageName];\\n            }\\n            if (isProtobufTypeDefinition(service)) {\\n                current[serviceName] = service;\\n            }\\n            else {\\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\\n            }\\n        }\\n    }\\n    return result;\\n},\\\"name\\\",{value:\\\"loadPackageDefinition\\\"})\"\n"])</script><script>self.__next_f.push([1,"a8:\"$EObject.defineProperty(function makeClientConstructor(methods, serviceName, classOptions) {\\n    if (!classOptions) {\\n        classOptions = {};\\n    }\\n    class ServiceClientImpl extends client_1.Client {\\n    }\\n    Object.keys(methods).forEach(name =\u003e {\\n        if (isPrototypePolluted(name)) {\\n            return;\\n        }\\n        const attrs = methods[name];\\n        let methodType;\\n        // TODO(murgatroid99): Verify that we don't need this anymore\\n        if (typeof name === 'string' \u0026\u0026 name.charAt(0) === '$') {\\n            throw new Error('Method names cannot start with $');\\n        }\\n        if (attrs.requestStream) {\\n            if (attrs.responseStream) {\\n                methodType = 'bidi';\\n            }\\n            else {\\n                methodType = 'client_stream';\\n            }\\n        }\\n        else {\\n            if (attrs.responseStream) {\\n                methodType = 'server_stream';\\n            }\\n            else {\\n                methodType = 'unary';\\n            }\\n        }\\n        const serialize = attrs.requestSerialize;\\n        const deserialize = attrs.responseDeserialize;\\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\\n        ServiceClientImpl.prototype[name] = methodFunc;\\n        // Associate all provided attributes with the method\\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\\n        if (attrs.originalName \u0026\u0026 !isPrototypePolluted(attrs.originalName)) {\\n            ServiceClientImpl.prototype[attrs.originalName] =\\n                ServiceClientImpl.prototype[name];\\n        }\\n    });\\n    ServiceClientImpl.service = methods;\\n    ServiceClientImpl.serviceName = serviceName;\\n    return ServiceClientImpl;\\n},\\\"name\\\",{value:\\\"makeClientConstructor\\\"})\"\n"])</script><script>self.__next_f.push([1,"a9:\"$EObject.defineProperty(class ChannelImplementation {\\n    constructor(target, credentials, options) {\\n        if (typeof target !== 'string') {\\n            throw new TypeError('Channel target must be a string');\\n        }\\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\\n        }\\n        if (options) {\\n            if (typeof options !== 'object') {\\n                throw new TypeError('Channel options must be an object');\\n            }\\n        }\\n        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);\\n    }\\n    close() {\\n        this.internalChannel.close();\\n    }\\n    getTarget() {\\n        return this.internalChannel.getTarget();\\n    }\\n    getConnectivityState(tryToConnect) {\\n        return this.internalChannel.getConnectivityState(tryToConnect);\\n    }\\n    watchConnectivityState(currentState, deadline, callback) {\\n        this.internalChannel.watchConnectivityState(currentState, deadline, callback);\\n    }\\n    /**\\n     * Get the channelz reference object for this channel. The returned value is\\n     * garbage if channelz is disabled for this channel.\\n     * @returns\\n     */\\n    getChannelzRef() {\\n        return this.internalChannel.getChannelzRef();\\n    }\\n    createCall(method, deadline, host, parentCall, propagateFlags) {\\n        if (typeof method !== 'string') {\\n            throw new TypeError('Channel#createCall: method must be a string');\\n        }\\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\\n        }\\n        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);\\n    }\\n},\\\"name\\\",{value:\\\"ChannelImplementation\\\"})\"\n"])</script><script>self.__next_f.push([1,"aa:\"$EObject.defineProperty((client) =\u003e client.close(),\\\"name\\\",{value:\\\"closeClient\\\"})\"\nab:\"$EObject.defineProperty((client, deadline, callback) =\u003e client.waitForReady(deadline, callback),\\\"name\\\",{value:\\\"waitForClientReady\\\"})\"\n"])</script><script>self.__next_f.push([1,"ac:\"$EObject.defineProperty(class ChannelCredentials {\\n    /**\\n     * Returns a copy of this object with the included set of per-call credentials\\n     * expanded to include callCredentials.\\n     * @param callCredentials A CallCredentials object to associate with this\\n     * instance.\\n     */\\n    compose(callCredentials) {\\n        return new ComposedChannelCredentialsImpl(this, callCredentials);\\n    }\\n    /**\\n     * Return a new ChannelCredentials instance with a given set of credentials.\\n     * The resulting instance can be used to construct a Channel that communicates\\n     * over TLS.\\n     * @param rootCerts The root certificate data.\\n     * @param privateKey The client certificate private key, if available.\\n     * @param certChain The client certificate key chain, if available.\\n     * @param verifyOptions Additional options to modify certificate verification\\n     */\\n    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\\n        var _a;\\n        verifyIsBufferOrNull(rootCerts, 'Root certificate');\\n        verifyIsBufferOrNull(privateKey, 'Private key');\\n        verifyIsBufferOrNull(certChain, 'Certificate chain');\\n        if (privateKey \u0026\u0026 !certChain) {\\n            throw new Error('Private key must be given with accompanying certificate chain');\\n        }\\n        if (!privateKey \u0026\u0026 certChain) {\\n            throw new Error('Certificate chain must be given with accompanying private key');\\n        }\\n        const secureContext = (0, tls_1.createSecureContext)({\\n            ca: (_a = rootCerts !== null \u0026\u0026 rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null \u0026\u0026 _a !== void 0 ? _a : undefined,\\n            key: privateKey !== null \u0026\u0026 privateKey !== void 0 ? privateKey : undefined,\\n            cert: certChain !== null \u0026\u0026 certChain !== void 0 ? certChain : undefined,\\n            ciphers: tls_helpers_1.CIPHER_SUITES,\\n        });\\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null \u0026\u0026 verifyOptions !== void 0 ? verifyOptions : {});\\n    }\\n    /**\\n     * Return a new ChannelCredentials instance with credentials created using\\n     * the provided secureContext. The resulting instances can be used to\\n     * construct a Channel that communicates over TLS. gRPC will not override\\n     * anything in the provided secureContext, so the environment variables\\n     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\\n     * not be applied.\\n     * @param secureContext The return value of tls.createSecureContext()\\n     * @param verifyOptions Additional options to modify certificate verification\\n     */\\n    static createFromSecureContext(secureContext, verifyOptions) {\\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null \u0026\u0026 verifyOptions !== void 0 ? verifyOptions : {});\\n    }\\n    /**\\n     * Return a new ChannelCredentials instance with no credentials.\\n     */\\n    static createInsecure() {\\n        return new InsecureChannelCredentialsImpl();\\n    }\\n},\\\"name\\\",{value:\\\"ChannelCredentials\\\"})\"\n"])</script><script>self.__next_f.push([1,"ad:\"$EObject.defineProperty(class CallCredentials {\\n    /**\\n     * Creates a new CallCredentials object from a given function that generates\\n     * Metadata objects.\\n     * @param metadataGenerator A function that accepts a set of options, and\\n     * generates a Metadata object based on these options, which is passed back\\n     * to the caller via a supplied (err, metadata) callback.\\n     */\\n    static createFromMetadataGenerator(metadataGenerator) {\\n        return new SingleCallCredentials(metadataGenerator);\\n    }\\n    /**\\n     * Create a gRPC credential from a Google credential object.\\n     * @param googleCredentials The authentication client to use.\\n     * @return The resulting CallCredentials object.\\n     */\\n    static createFromGoogleCredential(googleCredentials) {\\n        return CallCredentials.createFromMetadataGenerator((options, callback) =\u003e {\\n            let getHeaders;\\n            if (isCurrentOauth2Client(googleCredentials)) {\\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\\n            }\\n            else {\\n                getHeaders = new Promise((resolve, reject) =\u003e {\\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) =\u003e {\\n                        if (err) {\\n                            reject(err);\\n                            return;\\n                        }\\n                        if (!headers) {\\n                            reject(new Error('Headers not set by metadata plugin'));\\n                            return;\\n                        }\\n                        resolve(headers);\\n                    });\\n                });\\n            }\\n            getHeaders.then(headers =\u003e {\\n                const metadata = new metadata_1.Metadata();\\n                for (const key of Object.keys(headers)) {\\n                    metadata.add(key, headers[key]);\\n                }\\n                callback(null, metadata);\\n            }, err =\u003e {\\n                callback(err);\\n            });\\n        });\\n    }\\n    static createEmpty() {\\n        return new EmptyCallCredentials();\\n    }\\n},\\\"name\\\",{value:\\\"CallCredentials\\\"})\"\n"])</script><script>self.__next_f.push([1,"ae:\"$EObject.defineProperty((value, options) =\u003e {\\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\\n},\\\"name\\\",{value:\\\"loadObject\\\"})\"\naf:\"$EObject.defineProperty((filename, format, options) =\u003e {\\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\\n},\\\"name\\\",{value:\\\"load\\\"})\"\nb0:\"$EObject.defineProperty((logger) =\u003e {\\n    logging.setLogger(logger);\\n},\\\"name\\\",{value:\\\"setLogger\\\"})\"\nb1:\"$EObject.defineProperty((verbosity) =\u003e {\\n    logging.setLoggerVerbosity(verbosity);\\n},\\\"name\\\",{value:\\\"setLogVerbosity\\\"})\"\n"])</script><script>self.__next_f.push([1,"b2:\"$EObject.defineProperty(class Server {\\n            constructor(options) {\\n                var _b, _c, _d, _e, _f, _g;\\n                this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), new Map());\\n                this.http2Servers = new Map();\\n                this.sessionIdleTimeouts = new Map();\\n                this.handlers = new Map();\\n                this.sessions = new Map();\\n                /**\\n                 * This field only exists to ensure that the start method throws an error if\\n                 * it is called twice, as it did previously.\\n                 */\\n                this.started = false;\\n                this.shutdown = false;\\n                this.serverAddressString = 'null';\\n                // Channelz Info\\n                this.channelzEnabled = true;\\n                this.options = options !== null \u0026\u0026 options !== void 0 ? options : {};\\n                if (this.options['grpc.enable_channelz'] === 0) {\\n                    this.channelzEnabled = false;\\n                    this.channelzTrace = new channelz_1.ChannelzTraceStub();\\n                    this.callTracker = new channelz_1.ChannelzCallTrackerStub();\\n                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\\n                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();\\n                }\\n                else {\\n                    this.channelzTrace = new channelz_1.ChannelzTrace();\\n                    this.callTracker = new channelz_1.ChannelzCallTracker();\\n                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\\n                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\\n                }\\n                this.channelzRef = (0, channelz_1.registerChannelzServer)('server', () =\u003e this.getChannelzInfo(), this.channelzEnabled);\\n                this.channelzTrace.addTrace('CT_INFO', 'Server created');\\n                this.maxConnectionAgeMs =\\n                    (_b = this.options['grpc.max_connection_age_ms']) !== null \u0026\u0026 _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;\\n                this.maxConnectionAgeGraceMs =\\n                    (_c = this.options['grpc.max_connection_age_grace_ms']) !== null \u0026\u0026 _c !== void 0 ? _c : UNLIMITED_CONNECTION_AGE_MS;\\n                this.keepaliveTimeMs =\\n                    (_d = this.options['grpc.keepalive_time_ms']) !== null \u0026\u0026 _d !== void 0 ? _d : KEEPALIVE_MAX_TIME_MS;\\n                this.keepaliveTimeoutMs =\\n                    (_e = this.options['grpc.keepalive_timeout_ms']) !== null \u0026\u0026 _e !== void 0 ? _e : KEEPALIVE_TIMEOUT_MS;\\n                this.sessionIdleTimeout =\\n                    (_f = this.options['grpc.max_connection_idle_ms']) !== null \u0026\u0026 _f !== void 0 ? _f : MAX_CONNECTION_IDLE_MS;\\n                this.commonServerOptions = {\\n                    maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,\\n                };\\n                if ('grpc-node.max_session_memory' in this.options) {\\n                    this.commonServerOptions.maxSessionMemory =\\n                        this.options['grpc-node.max_session_memory'];\\n                }\\n                else {\\n                    /* By default, set a very large max session memory limit, to effectively\\n                     * disable enforcement of the limit. Some testing indicates that Node's\\n                     * behavior degrades badly when this limit is reached, so we solve that\\n                     * by disabling the check entirely. */\\n                    this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\\n                }\\n                if ('grpc.max_concurrent_streams' in this.options) {\\n                    this.commonServerOptions.settings = {\\n                        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\\n                    };\\n                }\\n                this.interceptors = (_g = this.options.interceptors) !== null \u0026\u0026 _g !== void 0 ? _g : [];\\n                this.trace('Server constructed');\\n            }\\n            getChannelzInfo() {\\n                return {\\n                    trace: this.channelzTrace,\\n                    callTracker: this.callTracker,\\n                    listenerChildren: this.listenerChildrenTracker.getChildLists(),\\n                    sessionChildren: this.sessionChildrenTracker.getChildLists(),\\n                };\\n            }\\n            getChannelzSessionInfo(session) {\\n                var _b, _c, _d;\\n                const sessionInfo = this.sessions.get(session);\\n                const sessionSocket = session.socket;\\n                const remoteAddress = sessionSocket.remoteAddress\\n                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)\\n                    : null;\\n                const localAddress = sessionSocket.localAddress\\n                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)\\n                    : null;\\n                let tlsInfo;\\n                if (session.encrypted) {\\n                    const tlsSocket = sessionSocket;\\n                    const cipherInfo = tlsSocket.getCipher();\\n                    const certificate = tlsSocket.getCertificate();\\n                    const peerCertificate = tlsSocket.getPeerCertificate();\\n                    tlsInfo = {\\n                        cipherSuiteStandardName: (_b = cipherInfo.standardName) !== null \u0026\u0026 _b !== void 0 ? _b : null,\\n                        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\\n                        localCertificate: certificate \u0026\u0026 'raw' in certificate ? certificate.raw : null,\\n                        remoteCertificate: peerCertificate \u0026\u0026 'raw' in peerCertificate\\n                            ? peerCertificate.raw\\n                            : null,\\n                    };\\n                }\\n                else {\\n                    tlsInfo = null;\\n                }\\n                const socketInfo = {\\n                    remoteAddress: remoteAddress,\\n                    localAddress: localAddress,\\n                    security: tlsInfo,\\n                    remoteName: null,\\n                    streamsStarted: sessionInfo.streamTracker.callsStarted,\\n                    streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\\n                    streamsFailed: sessionInfo.streamTracker.callsFailed,\\n                    messagesSent: sessionInfo.messagesSent,\\n                    messagesReceived: sessionInfo.messagesReceived,\\n                    keepAlivesSent: sessionInfo.keepAlivesSent,\\n                    lastLocalStreamCreatedTimestamp: null,\\n                    lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\\n                    lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\\n                    lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\\n                    localFlowControlWindow: (_c = session.state.localWindowSize) !== null \u0026\u0026 _c !== void 0 ? _c : null,\\n                    remoteFlowControlWindow: (_d = session.state.remoteWindowSize) !== null \u0026\u0026 _d !== void 0 ? _d : null,\\n                };\\n                return socketInfo;\\n            }\\n            trace(text) {\\n                logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\\n            }\\n            keepaliveTrace(text) {\\n                logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + text);\\n            }\\n            addProtoService() {\\n                throw new Error('Not implemented. Use addService() instead');\\n            }\\n            addService(service, implementation) {\\n                if (service === null ||\\n                    typeof service !== 'object' ||\\n                    implementation === null ||\\n                    typeof implementation !== 'object') {\\n                    throw new Error('addService() requires two objects as arguments');\\n                }\\n                const serviceKeys = Object.keys(service);\\n                if (serviceKeys.length === 0) {\\n                    throw new Error('Cannot add an empty service to a server');\\n                }\\n                serviceKeys.forEach(name =\u003e {\\n                    const attrs = service[name];\\n                    let methodType;\\n                    if (attrs.requestStream) {\\n                        if (attrs.responseStream) {\\n                            methodType = 'bidi';\\n                        }\\n                        else {\\n                            methodType = 'clientStream';\\n                        }\\n                    }\\n                    else {\\n                        if (attrs.responseStream) {\\n                            methodType = 'serverStream';\\n                        }\\n                        else {\\n                            methodType = 'unary';\\n                        }\\n                    }\\n                    let implFn = implementation[name];\\n                    let impl;\\n                    if (implFn === undefined \u0026\u0026 typeof attrs.originalName === 'string') {\\n                        implFn = implementation[attrs.originalName];\\n                    }\\n                    if (implFn !== undefined) {\\n                        impl = implFn.bind(implementation);\\n                    }\\n                    else {\\n                        impl = getDefaultHandler(methodType, name);\\n                    }\\n                    const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\\n                    if (success === false) {\\n                        throw new Error(`Method handler for ${attrs.path} already provided.`);\\n                    }\\n                });\\n            }\\n            removeService(service) {\\n                if (service === null || typeof service !== 'object') {\\n                    throw new Error('removeService() requires object as argument');\\n                }\\n                const serviceKeys = Object.keys(service);\\n                serviceKeys.forEach(name =\u003e {\\n                    const attrs = service[name];\\n                    this.unregister(attrs.path);\\n                });\\n            }\\n            bind(port, creds) {\\n                throw new Error('Not implemented. Use bindAsync() instead');\\n            }\\n            /**\\n             * This API is experimental, so API stability is not guaranteed across minor versions.\\n             * @param boundAddress\\n             * @returns\\n             */\\n            experimentalRegisterListenerToChannelz(boundAddress) {\\n                return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), () =\u003e {\\n                    return {\\n                        localAddress: boundAddress,\\n                        remoteAddress: null,\\n                        security: null,\\n                        remoteName: null,\\n                        streamsStarted: 0,\\n                        streamsSucceeded: 0,\\n                        streamsFailed: 0,\\n                        messagesSent: 0,\\n                        messagesReceived: 0,\\n                        keepAlivesSent: 0,\\n                        lastLocalStreamCreatedTimestamp: null,\\n                        lastRemoteStreamCreatedTimestamp: null,\\n                        lastMessageSentTimestamp: null,\\n                        lastMessageReceivedTimestamp: null,\\n                        localFlowControlWindow: null,\\n                        remoteFlowControlWindow: null,\\n                    };\\n                }, this.channelzEnabled);\\n            }\\n            experimentalUnregisterListenerFromChannelz(channelzRef) {\\n                (0, channelz_1.unregisterChannelzRef)(channelzRef);\\n            }\\n            createHttp2Server(credentials) {\\n                let http2Server;\\n                if (credentials._isSecure()) {\\n                    const constructorOptions = credentials._getConstructorOptions();\\n                    const contextOptions = credentials._getSecureContextOptions();\\n                    const secureServerOptions = Object.assign(Object.assign(Object.assign(Object.assign({}, this.commonServerOptions), constructorOptions), contextOptions), { enableTrace: this.options['grpc-node.tls_enable_trace'] === 1 });\\n                    let areCredentialsValid = contextOptions !== null;\\n                    this.trace('Initial credentials valid: ' + areCredentialsValid);\\n                    http2Server = http2.createSecureServer(secureServerOptions);\\n                    http2Server.prependListener('connection', (socket) =\u003e {\\n                        if (!areCredentialsValid) {\\n                            this.trace('Dropped connection from ' + JSON.stringify(socket.address()) + ' due to unloaded credentials');\\n                            socket.destroy();\\n                        }\\n                    });\\n                    http2Server.on('secureConnection', (socket) =\u003e {\\n                        /* These errors need to be handled by the user of Http2SecureServer,\\n                         * according to https://github.com/nodejs/node/issues/35824 */\\n                        socket.on('error', (e) =\u003e {\\n                            this.trace('An incoming TLS connection closed with error: ' + e.message);\\n                        });\\n                    });\\n                    const credsWatcher = options =\u003e {\\n                        if (options) {\\n                            const secureServer = http2Server;\\n                            try {\\n                                secureServer.setSecureContext(options);\\n                            }\\n                            catch (e) {\\n                                logging.log(constants_1.LogVerbosity.ERROR, 'Failed to set secure context with error ' + e.message);\\n                                options = null;\\n                            }\\n                        }\\n                        areCredentialsValid = options !== null;\\n                        this.trace('Post-update credentials valid: ' + areCredentialsValid);\\n                    };\\n                    credentials._addWatcher(credsWatcher);\\n                    http2Server.on('close', () =\u003e {\\n                        credentials._removeWatcher(credsWatcher);\\n                    });\\n                }\\n                else {\\n                    http2Server = http2.createServer(this.commonServerOptions);\\n                }\\n                http2Server.setTimeout(0, noop);\\n                this._setupHandlers(http2Server, credentials._getInterceptors());\\n                return http2Server;\\n            }\\n            bindOneAddress(address, boundPortObject) {\\n                this.trace('Attempting to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address));\\n                const http2Server = this.createHttp2Server(boundPortObject.credentials);\\n                return new Promise((resolve, reject) =\u003e {\\n                    const onError = (err) =\u003e {\\n                        this.trace('Failed to bind ' +\\n                            (0, subchannel_address_1.subchannelAddressToString)(address) +\\n                            ' with error ' +\\n                            err.message);\\n                        resolve({\\n                            port: 'port' in address ? address.port : 1,\\n                            error: err.message,\\n                        });\\n                    };\\n                    http2Server.once('error', onError);\\n                    http2Server.listen(address, () =\u003e {\\n                        const boundAddress = http2Server.address();\\n                        let boundSubchannelAddress;\\n                        if (typeof boundAddress === 'string') {\\n                            boundSubchannelAddress = {\\n                                path: boundAddress,\\n                            };\\n                        }\\n                        else {\\n                            boundSubchannelAddress = {\\n                                host: boundAddress.address,\\n                                port: boundAddress.port,\\n                            };\\n                        }\\n                        const channelzRef = this.experimentalRegisterListenerToChannelz(boundSubchannelAddress);\\n                        this.listenerChildrenTracker.refChild(channelzRef);\\n                        this.http2Servers.set(http2Server, {\\n                            channelzRef: channelzRef,\\n                            sessions: new Set(),\\n                            ownsChannelzRef: true\\n                        });\\n                        boundPortObject.listeningServers.add(http2Server);\\n                        this.trace('Successfully bound ' +\\n                            (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\\n                        resolve({\\n                            port: 'port' in boundSubchannelAddress ? boundSubchannelAddress.port : 1,\\n                        });\\n                        http2Server.removeListener('error', onError);\\n                    });\\n                });\\n            }\\n            async bindManyPorts(addressList, boundPortObject) {\\n                if (addressList.length === 0) {\\n                    return {\\n                        count: 0,\\n                        port: 0,\\n                        errors: [],\\n                    };\\n                }\\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) \u0026\u0026 addressList[0].port === 0) {\\n                    /* If binding to port 0, first try to bind the first address, then bind\\n                     * the rest of the address list to the specific port that it binds. */\\n                    const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);\\n                    if (firstAddressResult.error) {\\n                        /* If the first address fails to bind, try the same operation starting\\n                         * from the second item in the list. */\\n                        const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);\\n                        return Object.assign(Object.assign({}, restAddressResult), { errors: [firstAddressResult.error, ...restAddressResult.errors] });\\n                    }\\n                    else {\\n                        const restAddresses = addressList\\n                            .slice(1)\\n                            .map(address =\u003e (0, subchannel_address_1.isTcpSubchannelAddress)(address)\\n                            ? { host: address.host, port: firstAddressResult.port }\\n                            : address);\\n                        const restAddressResult = await Promise.all(restAddresses.map(address =\u003e this.bindOneAddress(address, boundPortObject)));\\n                        const allResults = [firstAddressResult, ...restAddressResult];\\n                        return {\\n                            count: allResults.filter(result =\u003e result.error === undefined).length,\\n                            port: firstAddressResult.port,\\n                            errors: allResults\\n                                .filter(result =\u003e result.error)\\n                                .map(result =\u003e result.error),\\n                        };\\n                    }\\n                }\\n                else {\\n                    const allResults = await Promise.all(addressList.map(address =\u003e this.bindOneAddress(address, boundPortObject)));\\n                    return {\\n                        count: allResults.filter(result =\u003e result.error === undefined).length,\\n                        port: allResults[0].port,\\n                        errors: allResults\\n                            .filter(result =\u003e result.error)\\n                            .map(result =\u003e result.error),\\n                    };\\n                }\\n            }\\n            async bindAddressList(addressList, boundPortObject) {\\n                const bindResult = await this.bindManyPorts(addressList, boundPortObject);\\n                if (bindResult.count \u003e 0) {\\n                    if (bindResult.count \u003c addressList.length) {\\n                        logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\\n                    }\\n                    return bindResult.port;\\n                }\\n                else {\\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\\n                    throw new Error(`${errorString} errors: [${bindResult.errors.join(',')}]`);\\n                }\\n            }\\n            resolvePort(port) {\\n                return new Promise((resolve, reject) =\u003e {\\n                    const resolverListener = {\\n                        onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError) =\u003e {\\n                            // We only want one resolution result. Discard all future results\\n                            resolverListener.onSuccessfulResolution = () =\u003e { };\\n                            const addressList = [].concat(...endpointList.map(endpoint =\u003e endpoint.addresses));\\n                            if (addressList.length === 0) {\\n                                reject(new Error(`No addresses resolved for port ${port}`));\\n                                return;\\n                            }\\n                            resolve(addressList);\\n                        },\\n                        onError: error =\u003e {\\n                            reject(new Error(error.details));\\n                        },\\n                    };\\n                    const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);\\n                    resolver.updateResolution();\\n                });\\n            }\\n            async bindPort(port, boundPortObject) {\\n                const addressList = await this.resolvePort(port);\\n                if (boundPortObject.cancelled) {\\n                    this.completeUnbind(boundPortObject);\\n                    throw new Error('bindAsync operation cancelled by unbind call');\\n                }\\n                const portNumber = await this.bindAddressList(addressList, boundPortObject);\\n                if (boundPortObject.cancelled) {\\n                    this.completeUnbind(boundPortObject);\\n                    throw new Error('bindAsync operation cancelled by unbind call');\\n                }\\n                return portNumber;\\n            }\\n            normalizePort(port) {\\n                const initialPortUri = (0, uri_parser_1.parseUri)(port);\\n                if (initialPortUri === null) {\\n                    throw new Error(`Could not parse port \\\"${port}\\\"`);\\n                }\\n                const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);\\n                if (portUri === null) {\\n                    throw new Error(`Could not get a default scheme for port \\\"${port}\\\"`);\\n                }\\n                return portUri;\\n            }\\n            bindAsync(port, creds, callback) {\\n                if (this.shutdown) {\\n                    throw new Error('bindAsync called after shutdown');\\n                }\\n                if (typeof port !== 'string') {\\n                    throw new TypeError('port must be a string');\\n                }\\n                if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\\n                    throw new TypeError('creds must be a ServerCredentials object');\\n                }\\n                if (typeof callback !== 'function') {\\n                    throw new TypeError('callback must be a function');\\n                }\\n                this.trace('bindAsync port=' + port);\\n                const portUri = this.normalizePort(port);\\n                const deferredCallback = (error, port) =\u003e {\\n                    process.nextTick(() =\u003e callback(error, port));\\n                };\\n                /* First, if this port is already bound or that bind operation is in\\n                 * progress, use that result. */\\n                let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\\n                if (boundPortObject) {\\n                    if (!creds._equals(boundPortObject.credentials)) {\\n                        deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);\\n                        return;\\n                    }\\n                    /* If that operation has previously been cancelled by an unbind call,\\n                     * uncancel it. */\\n                    boundPortObject.cancelled = false;\\n                    if (boundPortObject.completionPromise) {\\n                        boundPortObject.completionPromise.then(portNum =\u003e callback(null, portNum), error =\u003e callback(error, 0));\\n                    }\\n                    else {\\n                        deferredCallback(null, boundPortObject.portNumber);\\n                    }\\n                    return;\\n                }\\n                boundPortObject = {\\n                    mapKey: (0, uri_parser_1.uriToString)(portUri),\\n                    originalUri: portUri,\\n                    completionPromise: null,\\n                    cancelled: false,\\n                    portNumber: 0,\\n                    credentials: creds,\\n                    listeningServers: new Set(),\\n                };\\n                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\\n                const completionPromise = this.bindPort(portUri, boundPortObject);\\n                boundPortObject.completionPromise = completionPromise;\\n                /* If the port number is 0, defer populating the map entry until after the\\n                 * bind operation completes and we have a specific port number. Otherwise,\\n                 * populate it immediately. */\\n                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\\n                    completionPromise.then(portNum =\u003e {\\n                        const finalUri = {\\n                            scheme: portUri.scheme,\\n                            authority: portUri.authority,\\n                            path: (0, uri_parser_1.combineHostPort)({ host: splitPort.host, port: portNum }),\\n                        };\\n                        boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);\\n                        boundPortObject.completionPromise = null;\\n                        boundPortObject.portNumber = portNum;\\n                        this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\\n                        callback(null, portNum);\\n                    }, error =\u003e {\\n                        callback(error, 0);\\n                    });\\n                }\\n                else {\\n                    this.boundPorts.set(boundPortObject.mapKey, boundPortObject);\\n                    completionPromise.then(portNum =\u003e {\\n                        boundPortObject.completionPromise = null;\\n                        boundPortObject.portNumber = portNum;\\n                        callback(null, portNum);\\n                    }, error =\u003e {\\n                        callback(error, 0);\\n                    });\\n                }\\n            }\\n            registerInjectorToChannelz() {\\n                return (0, channelz_1.registerChannelzSocket)('injector', () =\u003e {\\n                    return {\\n                        localAddress: null,\\n                        remoteAddress: null,\\n                        security: null,\\n                        remoteName: null,\\n                        streamsStarted: 0,\\n                        streamsSucceeded: 0,\\n                        streamsFailed: 0,\\n                        messagesSent: 0,\\n                        messagesReceived: 0,\\n                        keepAlivesSent: 0,\\n                        lastLocalStreamCreatedTimestamp: null,\\n                        lastRemoteStreamCreatedTimestamp: null,\\n                        lastMessageSentTimestamp: null,\\n                        lastMessageReceivedTimestamp: null,\\n                        localFlowControlWindow: null,\\n                        remoteFlowControlWindow: null,\\n                    };\\n                }, this.channelzEnabled);\\n            }\\n            /**\\n             * This API is experimental, so API stability is not guaranteed across minor versions.\\n             * @param credentials\\n             * @param channelzRef\\n             * @returns\\n             */\\n            experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, ownsChannelzRef = false) {\\n                if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {\\n                    throw new TypeError('creds must be a ServerCredentials object');\\n                }\\n                if (this.channelzEnabled) {\\n                    this.listenerChildrenTracker.refChild(channelzRef);\\n                }\\n                const server = this.createHttp2Server(credentials);\\n                const sessionsSet = new Set();\\n                this.http2Servers.set(server, {\\n                    channelzRef: channelzRef,\\n                    sessions: sessionsSet,\\n                    ownsChannelzRef\\n                });\\n                return {\\n                    injectConnection: (connection) =\u003e {\\n                        server.emit('connection', connection);\\n                    },\\n                    drain: (graceTimeMs) =\u003e {\\n                        var _b, _c;\\n                        for (const session of sessionsSet) {\\n                            this.closeSession(session);\\n                        }\\n                        (_c = (_b = setTimeout(() =\u003e {\\n                            for (const session of sessionsSet) {\\n                                session.destroy(http2.constants.NGHTTP2_CANCEL);\\n                            }\\n                        }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\\n                    },\\n                    destroy: () =\u003e {\\n                        this.closeServer(server);\\n                        for (const session of sessionsSet) {\\n                            this.closeSession(session);\\n                        }\\n                    }\\n                };\\n            }\\n            createConnectionInjector(credentials) {\\n                if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {\\n                    throw new TypeError('creds must be a ServerCredentials object');\\n                }\\n                const channelzRef = this.registerInjectorToChannelz();\\n                return this.experimentalCreateConnectionInjectorWithChannelzRef(credentials, channelzRef, true);\\n            }\\n            closeServer(server, callback) {\\n                this.trace('Closing server with address ' + JSON.stringify(server.address()));\\n                const serverInfo = this.http2Servers.get(server);\\n                server.close(() =\u003e {\\n                    if (serverInfo \u0026\u0026 serverInfo.ownsChannelzRef) {\\n                        this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);\\n                        (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);\\n                    }\\n                    this.http2Servers.delete(server);\\n                    callback === null || callback === void 0 ? void 0 : callback();\\n                });\\n            }\\n            closeSession(session, callback) {\\n                var _b;\\n                this.trace('Closing session initiated by ' + ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));\\n                const sessionInfo = this.sessions.get(session);\\n                const closeCallback = () =\u003e {\\n                    if (sessionInfo) {\\n                        this.sessionChildrenTracker.unrefChild(sessionInfo.ref);\\n                        (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);\\n                    }\\n                    callback === null || callback === void 0 ? void 0 : callback();\\n                };\\n                if (session.closed) {\\n                    queueMicrotask(closeCallback);\\n                }\\n                else {\\n                    session.close(closeCallback);\\n                }\\n            }\\n            completeUnbind(boundPortObject) {\\n                for (const server of boundPortObject.listeningServers) {\\n                    const serverInfo = this.http2Servers.get(server);\\n                    this.closeServer(server, () =\u003e {\\n                        boundPortObject.listeningServers.delete(server);\\n                    });\\n                    if (serverInfo) {\\n                        for (const session of serverInfo.sessions) {\\n                            this.closeSession(session);\\n                        }\\n                    }\\n                }\\n                this.boundPorts.delete(boundPortObject.mapKey);\\n            }\\n            /**\\n             * Unbind a previously bound port, or cancel an in-progress bindAsync\\n             * operation. If port 0 was bound, only the actual bound port can be\\n             * unbound. For example, if bindAsync was called with \\\"localhost:0\\\" and the\\n             * bound port result was 54321, it can be unbound as \\\"localhost:54321\\\".\\n             * @param port\\n             */\\n            unbind(port) {\\n                this.trace('unbind port=' + port);\\n                const portUri = this.normalizePort(port);\\n                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\\n                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\\n                    throw new Error('Cannot unbind port 0');\\n                }\\n                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\\n                if (boundPortObject) {\\n                    this.trace('unbinding ' +\\n                        boundPortObject.mapKey +\\n                        ' originally bound as ' +\\n                        (0, uri_parser_1.uriToString)(boundPortObject.originalUri));\\n                    /* If the bind operation is pending, the cancelled flag will trigger\\n                     * the unbind operation later. */\\n                    if (boundPortObject.completionPromise) {\\n                        boundPortObject.cancelled = true;\\n                    }\\n                    else {\\n                        this.completeUnbind(boundPortObject);\\n                    }\\n                }\\n            }\\n            /**\\n             * Gracefully close all connections associated with a previously bound port.\\n             * After the grace time, forcefully close all remaining open connections.\\n             *\\n             * If port 0 was bound, only the actual bound port can be\\n             * drained. For example, if bindAsync was called with \\\"localhost:0\\\" and the\\n             * bound port result was 54321, it can be drained as \\\"localhost:54321\\\".\\n             * @param port\\n             * @param graceTimeMs\\n             * @returns\\n             */\\n            drain(port, graceTimeMs) {\\n                var _b, _c;\\n                this.trace('drain port=' + port + ' graceTimeMs=' + graceTimeMs);\\n                const portUri = this.normalizePort(port);\\n                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);\\n                if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {\\n                    throw new Error('Cannot drain port 0');\\n                }\\n                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));\\n                if (!boundPortObject) {\\n                    return;\\n                }\\n                const allSessions = new Set();\\n                for (const http2Server of boundPortObject.listeningServers) {\\n                    const serverEntry = this.http2Servers.get(http2Server);\\n                    if (serverEntry) {\\n                        for (const session of serverEntry.sessions) {\\n                            allSessions.add(session);\\n                            this.closeSession(session, () =\u003e {\\n                                allSessions.delete(session);\\n                            });\\n                        }\\n                    }\\n                }\\n                /* After the grace time ends, send another goaway to all remaining sessions\\n                 * with the CANCEL code. */\\n                (_c = (_b = setTimeout(() =\u003e {\\n                    for (const session of allSessions) {\\n                        session.destroy(http2.constants.NGHTTP2_CANCEL);\\n                    }\\n                }, graceTimeMs)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\\n            }\\n            forceShutdown() {\\n                for (const boundPortObject of this.boundPorts.values()) {\\n                    boundPortObject.cancelled = true;\\n                }\\n                this.boundPorts.clear();\\n                // Close the server if it is still running.\\n                for (const server of this.http2Servers.keys()) {\\n                    this.closeServer(server);\\n                }\\n                // Always destroy any available sessions. It's possible that one or more\\n                // tryShutdown() calls are in progress. Don't wait on them to finish.\\n                this.sessions.forEach((channelzInfo, session) =\u003e {\\n                    this.closeSession(session);\\n                    // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\\n                    // recognize destroy(code) as a valid signature.\\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n                    session.destroy(http2.constants.NGHTTP2_CANCEL);\\n                });\\n                this.sessions.clear();\\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\\n                this.shutdown = true;\\n            }\\n            register(name, handler, serialize, deserialize, type) {\\n                if (this.handlers.has(name)) {\\n                    return false;\\n                }\\n                this.handlers.set(name, {\\n                    func: handler,\\n                    serialize,\\n                    deserialize,\\n                    type,\\n                    path: name,\\n                });\\n                return true;\\n            }\\n            unregister(name) {\\n                return this.handlers.delete(name);\\n            }\\n            /**\\n             * @deprecated No longer needed as of version 1.10.x\\n             */\\n            start() {\\n                if (this.http2Servers.size === 0 ||\\n                    [...this.http2Servers.keys()].every(server =\u003e !server.listening)) {\\n                    throw new Error('server must be bound in order to start');\\n                }\\n                if (this.started === true) {\\n                    throw new Error('server is already started');\\n                }\\n                this.started = true;\\n            }\\n            tryShutdown(callback) {\\n                var _b;\\n                const wrappedCallback = (error) =\u003e {\\n                    (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\\n                    callback(error);\\n                };\\n                let pendingChecks = 0;\\n                function maybeCallback() {\\n                    pendingChecks--;\\n                    if (pendingChecks === 0) {\\n                        wrappedCallback();\\n                    }\\n                }\\n                this.shutdown = true;\\n                for (const [serverKey, server] of this.http2Servers.entries()) {\\n                    pendingChecks++;\\n                    const serverString = server.channelzRef.name;\\n                    this.trace('Waiting for server ' + serverString + ' to close');\\n                    this.closeServer(serverKey, () =\u003e {\\n                        this.trace('Server ' + serverString + ' finished closing');\\n                        maybeCallback();\\n                    });\\n                    for (const session of server.sessions.keys()) {\\n                        pendingChecks++;\\n                        const sessionString = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress;\\n                        this.trace('Waiting for session ' + sessionString + ' to close');\\n                        this.closeSession(session, () =\u003e {\\n                            this.trace('Session ' + sessionString + ' finished closing');\\n                            maybeCallback();\\n                        });\\n                    }\\n                }\\n                if (pendingChecks === 0) {\\n                    wrappedCallback();\\n                }\\n            }\\n            addHttp2Port() {\\n                throw new Error('Not yet implemented');\\n            }\\n            /**\\n             * Get the channelz reference object for this server. The returned value is\\n             * garbage if channelz is disabled for this server.\\n             * @returns\\n             */\\n            getChannelzRef() {\\n                return this.channelzRef;\\n            }\\n            _verifyContentType(stream, headers) {\\n                const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\\n                if (typeof contentType !== 'string' ||\\n                    !contentType.startsWith('application/grpc')) {\\n                    stream.respond({\\n                        [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\\n                    }, { endStream: true });\\n                    return false;\\n                }\\n                return true;\\n            }\\n            _retrieveHandler(path) {\\n                serverCallTrace('Received call to method ' +\\n                    path +\\n                    ' at address ' +\\n                    this.serverAddressString);\\n                const handler = this.handlers.get(path);\\n                if (handler === undefined) {\\n                    serverCallTrace('No handler registered for method ' +\\n                        path +\\n                        '. Sending UNIMPLEMENTED status.');\\n                    return null;\\n                }\\n                return handler;\\n            }\\n            _respondWithError(err, stream, channelzSessionInfo = null) {\\n                var _b, _c;\\n                const trailersToSend = Object.assign({ 'grpc-status': (_b = err.code) !== null \u0026\u0026 _b !== void 0 ? _b : constants_1.Status.INTERNAL, 'grpc-message': err.details, [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK, [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto' }, (_c = err.metadata) === null || _c === void 0 ? void 0 : _c.toHttp2Headers());\\n                stream.respond(trailersToSend, { endStream: true });\\n                this.callTracker.addCallFailed();\\n                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\\n            }\\n            _channelzHandler(extraInterceptors, stream, headers) {\\n                // for handling idle timeout\\n                this.onStreamOpened(stream);\\n                const channelzSessionInfo = this.sessions.get(stream.session);\\n                this.callTracker.addCallStarted();\\n                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\\n                if (!this._verifyContentType(stream, headers)) {\\n                    this.callTracker.addCallFailed();\\n                    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\\n                    return;\\n                }\\n                const path = headers[HTTP2_HEADER_PATH];\\n                const handler = this._retrieveHandler(path);\\n                if (!handler) {\\n                    this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);\\n                    return;\\n                }\\n                const callEventTracker = {\\n                    addMessageSent: () =\u003e {\\n                        if (channelzSessionInfo) {\\n                            channelzSessionInfo.messagesSent += 1;\\n                            channelzSessionInfo.lastMessageSentTimestamp = new Date();\\n                        }\\n                    },\\n                    addMessageReceived: () =\u003e {\\n                        if (channelzSessionInfo) {\\n                            channelzSessionInfo.messagesReceived += 1;\\n                            channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\\n                        }\\n                    },\\n                    onCallEnd: status =\u003e {\\n                        if (status.code === constants_1.Status.OK) {\\n                            this.callTracker.addCallSucceeded();\\n                        }\\n                        else {\\n                            this.callTracker.addCallFailed();\\n                        }\\n                    },\\n                    onStreamEnd: success =\u003e {\\n                        if (channelzSessionInfo) {\\n                            if (success) {\\n                                channelzSessionInfo.streamTracker.addCallSucceeded();\\n                            }\\n                            else {\\n                                channelzSessionInfo.streamTracker.addCallFailed();\\n                            }\\n                        }\\n                    },\\n                };\\n                const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, callEventTracker, handler, this.options);\\n                if (!this._runHandlerForCall(call, handler)) {\\n                    this.callTracker.addCallFailed();\\n                    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\\n                    call.sendStatus({\\n                        code: constants_1.Status.INTERNAL,\\n                        details: `Unknown handler type: ${handler.type}`,\\n                    });\\n                }\\n            }\\n            _streamHandler(extraInterceptors, stream, headers) {\\n                // for handling idle timeout\\n                this.onStreamOpened(stream);\\n                if (this._verifyContentType(stream, headers) !== true) {\\n                    return;\\n                }\\n                const path = headers[HTTP2_HEADER_PATH];\\n                const handler = this._retrieveHandler(path);\\n                if (!handler) {\\n                    this._respondWithError(getUnimplementedStatusResponse(path), stream, null);\\n                    return;\\n                }\\n                const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, null, handler, this.options);\\n                if (!this._runHandlerForCall(call, handler)) {\\n                    call.sendStatus({\\n                        code: constants_1.Status.INTERNAL,\\n                        details: `Unknown handler type: ${handler.type}`,\\n                    });\\n                }\\n            }\\n            _runHandlerForCall(call, handler) {\\n                const { type } = handler;\\n                if (type === 'unary') {\\n                    handleUnary(call, handler);\\n                }\\n                else if (type === 'clientStream') {\\n                    handleClientStreaming(call, handler);\\n                }\\n                else if (type === 'serverStream') {\\n                    handleServerStreaming(call, handler);\\n                }\\n                else if (type === 'bidi') {\\n                    handleBidiStreaming(call, handler);\\n                }\\n                else {\\n                    return false;\\n                }\\n                return true;\\n            }\\n            _setupHandlers(http2Server, extraInterceptors) {\\n                if (http2Server === null) {\\n                    return;\\n                }\\n                const serverAddress = http2Server.address();\\n                let serverAddressString = 'null';\\n                if (serverAddress) {\\n                    if (typeof serverAddress === 'string') {\\n                        serverAddressString = serverAddress;\\n                    }\\n                    else {\\n                        serverAddressString = serverAddress.address + ':' + serverAddress.port;\\n                    }\\n                }\\n                this.serverAddressString = serverAddressString;\\n                const handler = this.channelzEnabled\\n                    ? this._channelzHandler\\n                    : this._streamHandler;\\n                const sessionHandler = this.channelzEnabled\\n                    ? this._channelzSessionHandler(http2Server)\\n                    : this._sessionHandler(http2Server);\\n                http2Server.on('stream', handler.bind(this, extraInterceptors));\\n                http2Server.on('session', sessionHandler);\\n            }\\n            _sessionHandler(http2Server) {\\n                return (session) =\u003e {\\n                    var _b, _c;\\n                    (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.add(session);\\n                    let connectionAgeTimer = null;\\n                    let connectionAgeGraceTimer = null;\\n                    let keepaliveTimer = null;\\n                    let sessionClosedByServer = false;\\n                    const idleTimeoutObj = this.enableIdleTimeout(session);\\n                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\\n                        // Apply a random jitter within a +/-10% range\\n                        const jitterMagnitude = this.maxConnectionAgeMs / 10;\\n                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\\n                        connectionAgeTimer = setTimeout(() =\u003e {\\n                            var _b, _c;\\n                            sessionClosedByServer = true;\\n                            this.trace('Connection dropped by max connection age: ' +\\n                                ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress));\\n                            try {\\n                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 \u003c\u003c 31), kMaxAge);\\n                            }\\n                            catch (e) {\\n                                // The goaway can't be sent because the session is already closed\\n                                session.destroy();\\n                                return;\\n                            }\\n                            session.close();\\n                            /* Allow a grace period after sending the GOAWAY before forcibly\\n                             * closing the connection. */\\n                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\\n                                connectionAgeGraceTimer = setTimeout(() =\u003e {\\n                                    session.destroy();\\n                                }, this.maxConnectionAgeGraceMs);\\n                                (_c = connectionAgeGraceTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeGraceTimer);\\n                            }\\n                        }, this.maxConnectionAgeMs + jitter);\\n                        (_c = connectionAgeTimer.unref) === null || _c === void 0 ? void 0 : _c.call(connectionAgeTimer);\\n                    }\\n                    const clearKeepaliveTimeout = () =\u003e {\\n                        if (keepaliveTimer) {\\n                            clearTimeout(keepaliveTimer);\\n                            keepaliveTimer = null;\\n                        }\\n                    };\\n                    const canSendPing = () =\u003e {\\n                        return (!session.destroyed \u0026\u0026\\n                            this.keepaliveTimeMs \u003c KEEPALIVE_MAX_TIME_MS \u0026\u0026\\n                            this.keepaliveTimeMs \u003e 0);\\n                    };\\n                    /* eslint-disable-next-line prefer-const */\\n                    let sendPing; // hoisted for use in maybeStartKeepalivePingTimer\\n                    const maybeStartKeepalivePingTimer = () =\u003e {\\n                        var _b;\\n                        if (!canSendPing()) {\\n                            return;\\n                        }\\n                        this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\\n                        keepaliveTimer = setTimeout(() =\u003e {\\n                            clearKeepaliveTimeout();\\n                            sendPing();\\n                        }, this.keepaliveTimeMs);\\n                        (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);\\n                    };\\n                    sendPing = () =\u003e {\\n                        var _b;\\n                        if (!canSendPing()) {\\n                            return;\\n                        }\\n                        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\\n                        let pingSendError = '';\\n                        try {\\n                            const pingSentSuccessfully = session.ping((err, duration, payload) =\u003e {\\n                                clearKeepaliveTimeout();\\n                                if (err) {\\n                                    this.keepaliveTrace('Ping failed with error: ' + err.message);\\n                                    sessionClosedByServer = true;\\n                                    session.close();\\n                                }\\n                                else {\\n                                    this.keepaliveTrace('Received ping response');\\n                                    maybeStartKeepalivePingTimer();\\n                                }\\n                            });\\n                            if (!pingSentSuccessfully) {\\n                                pingSendError = 'Ping returned false';\\n                            }\\n                        }\\n                        catch (e) {\\n                            // grpc/grpc-node#2139\\n                            pingSendError =\\n                                (e instanceof Error ? e.message : '') || 'Unknown error';\\n                        }\\n                        if (pingSendError) {\\n                            this.keepaliveTrace('Ping send failed: ' + pingSendError);\\n                            this.trace('Connection dropped due to ping send error: ' + pingSendError);\\n                            sessionClosedByServer = true;\\n                            session.close();\\n                            return;\\n                        }\\n                        keepaliveTimer = setTimeout(() =\u003e {\\n                            clearKeepaliveTimeout();\\n                            this.keepaliveTrace('Ping timeout passed without response');\\n                            this.trace('Connection dropped by keepalive timeout');\\n                            sessionClosedByServer = true;\\n                            session.close();\\n                        }, this.keepaliveTimeoutMs);\\n                        (_b = keepaliveTimer.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimer);\\n                    };\\n                    maybeStartKeepalivePingTimer();\\n                    session.on('close', () =\u003e {\\n                        var _b, _c;\\n                        if (!sessionClosedByServer) {\\n                            this.trace(`Connection dropped by client ${(_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress}`);\\n                        }\\n                        if (connectionAgeTimer) {\\n                            clearTimeout(connectionAgeTimer);\\n                        }\\n                        if (connectionAgeGraceTimer) {\\n                            clearTimeout(connectionAgeGraceTimer);\\n                        }\\n                        clearKeepaliveTimeout();\\n                        if (idleTimeoutObj !== null) {\\n                            clearTimeout(idleTimeoutObj.timeout);\\n                            this.sessionIdleTimeouts.delete(session);\\n                        }\\n                        (_c = this.http2Servers.get(http2Server)) === null || _c === void 0 ? void 0 : _c.sessions.delete(session);\\n                    });\\n                };\\n            }\\n            _channelzSessionHandler(http2Server) {\\n                return (session) =\u003e {\\n                    var _b, _c, _d, _e;\\n                    const channelzRef = (0, channelz_1.registerChannelzSocket)((_c = (_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) !== null \u0026\u0026 _c !== void 0 ? _c : 'unknown', this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);\\n                    const channelzSessionInfo = {\\n                        ref: channelzRef,\\n                        streamTracker: new channelz_1.ChannelzCallTracker(),\\n                        messagesSent: 0,\\n                        messagesReceived: 0,\\n                        keepAlivesSent: 0,\\n                        lastMessageSentTimestamp: null,\\n                        lastMessageReceivedTimestamp: null,\\n                    };\\n                    (_d = this.http2Servers.get(http2Server)) === null || _d === void 0 ? void 0 : _d.sessions.add(session);\\n                    this.sessions.set(session, channelzSessionInfo);\\n                    const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;\\n                    this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\\n                    this.trace('Connection established by client ' + clientAddress);\\n                    this.sessionChildrenTracker.refChild(channelzRef);\\n                    let connectionAgeTimer = null;\\n                    let connectionAgeGraceTimer = null;\\n                    let keepaliveTimeout = null;\\n                    let sessionClosedByServer = false;\\n                    const idleTimeoutObj = this.enableIdleTimeout(session);\\n                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\\n                        // Apply a random jitter within a +/-10% range\\n                        const jitterMagnitude = this.maxConnectionAgeMs / 10;\\n                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\\n                        connectionAgeTimer = setTimeout(() =\u003e {\\n                            var _b;\\n                            sessionClosedByServer = true;\\n                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);\\n                            try {\\n                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 \u003c\u003c 31), kMaxAge);\\n                            }\\n                            catch (e) {\\n                                // The goaway can't be sent because the session is already closed\\n                                session.destroy();\\n                                return;\\n                            }\\n                            session.close();\\n                            /* Allow a grace period after sending the GOAWAY before forcibly\\n                             * closing the connection. */\\n                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\\n                                connectionAgeGraceTimer = setTimeout(() =\u003e {\\n                                    session.destroy();\\n                                }, this.maxConnectionAgeGraceMs);\\n                                (_b = connectionAgeGraceTimer.unref) === null || _b === void 0 ? void 0 : _b.call(connectionAgeGraceTimer);\\n                            }\\n                        }, this.maxConnectionAgeMs + jitter);\\n                        (_e = connectionAgeTimer.unref) === null || _e === void 0 ? void 0 : _e.call(connectionAgeTimer);\\n                    }\\n                    const clearKeepaliveTimeout = () =\u003e {\\n                        if (keepaliveTimeout) {\\n                            clearTimeout(keepaliveTimeout);\\n                            keepaliveTimeout = null;\\n                        }\\n                    };\\n                    const canSendPing = () =\u003e {\\n                        return (!session.destroyed \u0026\u0026\\n                            this.keepaliveTimeMs \u003c KEEPALIVE_MAX_TIME_MS \u0026\u0026\\n                            this.keepaliveTimeMs \u003e 0);\\n                    };\\n                    /* eslint-disable-next-line prefer-const */\\n                    let sendPing; // hoisted for use in maybeStartKeepalivePingTimer\\n                    const maybeStartKeepalivePingTimer = () =\u003e {\\n                        var _b;\\n                        if (!canSendPing()) {\\n                            return;\\n                        }\\n                        this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\\n                        keepaliveTimeout = setTimeout(() =\u003e {\\n                            clearKeepaliveTimeout();\\n                            sendPing();\\n                        }, this.keepaliveTimeMs);\\n                        (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);\\n                    };\\n                    sendPing = () =\u003e {\\n                        var _b;\\n                        if (!canSendPing()) {\\n                            return;\\n                        }\\n                        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\\n                        let pingSendError = '';\\n                        try {\\n                            const pingSentSuccessfully = session.ping((err, duration, payload) =\u003e {\\n                                clearKeepaliveTimeout();\\n                                if (err) {\\n                                    this.keepaliveTrace('Ping failed with error: ' + err.message);\\n                                    this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to error of a ping frame ' +\\n                                        err.message +\\n                                        ' return in ' +\\n                                        duration);\\n                                    sessionClosedByServer = true;\\n                                    session.close();\\n                                }\\n                                else {\\n                                    this.keepaliveTrace('Received ping response');\\n                                    maybeStartKeepalivePingTimer();\\n                                }\\n                            });\\n                            if (!pingSentSuccessfully) {\\n                                pingSendError = 'Ping returned false';\\n                            }\\n                        }\\n                        catch (e) {\\n                            // grpc/grpc-node#2139\\n                            pingSendError =\\n                                (e instanceof Error ? e.message : '') || 'Unknown error';\\n                        }\\n                        if (pingSendError) {\\n                            this.keepaliveTrace('Ping send failed: ' + pingSendError);\\n                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to ping send error: ' + pingSendError);\\n                            sessionClosedByServer = true;\\n                            session.close();\\n                            return;\\n                        }\\n                        channelzSessionInfo.keepAlivesSent += 1;\\n                        keepaliveTimeout = setTimeout(() =\u003e {\\n                            clearKeepaliveTimeout();\\n                            this.keepaliveTrace('Ping timeout passed without response');\\n                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);\\n                            sessionClosedByServer = true;\\n                            session.close();\\n                        }, this.keepaliveTimeoutMs);\\n                        (_b = keepaliveTimeout.unref) === null || _b === void 0 ? void 0 : _b.call(keepaliveTimeout);\\n                    };\\n                    maybeStartKeepalivePingTimer();\\n                    session.on('close', () =\u003e {\\n                        var _b;\\n                        if (!sessionClosedByServer) {\\n                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\\n                        }\\n                        this.sessionChildrenTracker.unrefChild(channelzRef);\\n                        (0, channelz_1.unregisterChannelzRef)(channelzRef);\\n                        if (connectionAgeTimer) {\\n                            clearTimeout(connectionAgeTimer);\\n                        }\\n                        if (connectionAgeGraceTimer) {\\n                            clearTimeout(connectionAgeGraceTimer);\\n                        }\\n                        clearKeepaliveTimeout();\\n                        if (idleTimeoutObj !== null) {\\n                            clearTimeout(idleTimeoutObj.timeout);\\n                            this.sessionIdleTimeouts.delete(session);\\n                        }\\n                        (_b = this.http2Servers.get(http2Server)) === null || _b === void 0 ? void 0 : _b.sessions.delete(session);\\n                        this.sessions.delete(session);\\n                    });\\n                };\\n            }\\n            enableIdleTimeout(session) {\\n                var _b, _c;\\n                if (this.sessionIdleTimeout \u003e= MAX_CONNECTION_IDLE_MS) {\\n                    return null;\\n                }\\n                const idleTimeoutObj = {\\n                    activeStreams: 0,\\n                    lastIdle: Date.now(),\\n                    onClose: this.onStreamClose.bind(this, session),\\n                    timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session),\\n                };\\n                (_c = (_b = idleTimeoutObj.timeout).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\\n                this.sessionIdleTimeouts.set(session, idleTimeoutObj);\\n                const { socket } = session;\\n                this.trace('Enable idle timeout for ' +\\n                    socket.remoteAddress +\\n                    ':' +\\n                    socket.remotePort);\\n                return idleTimeoutObj;\\n            }\\n            onIdleTimeout(ctx, session) {\\n                const { socket } = session;\\n                const sessionInfo = ctx.sessionIdleTimeouts.get(session);\\n                // if it is called while we have activeStreams - timer will not be rescheduled\\n                // until last active stream is closed, then it will call .refresh() on the timer\\n                // important part is to not clearTimeout(timer) or it becomes unusable\\n                // for future refreshes\\n                if (sessionInfo !== undefined \u0026\u0026\\n                    sessionInfo.activeStreams === 0) {\\n                    if (Date.now() - sessionInfo.lastIdle \u003e= ctx.sessionIdleTimeout) {\\n                        ctx.trace('Session idle timeout triggered for ' +\\n                            (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) +\\n                            ':' +\\n                            (socket === null || socket === void 0 ? void 0 : socket.remotePort) +\\n                            ' last idle at ' +\\n                            sessionInfo.lastIdle);\\n                        ctx.closeSession(session);\\n                    }\\n                    else {\\n                        sessionInfo.timeout.refresh();\\n                    }\\n                }\\n            }\\n            onStreamOpened(stream) {\\n                const session = stream.session;\\n                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\\n                if (idleTimeoutObj) {\\n                    idleTimeoutObj.activeStreams += 1;\\n                    stream.once('close', idleTimeoutObj.onClose);\\n                }\\n            }\\n            onStreamClose(session) {\\n                var _b, _c;\\n                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);\\n                if (idleTimeoutObj) {\\n                    idleTimeoutObj.activeStreams -= 1;\\n                    if (idleTimeoutObj.activeStreams === 0) {\\n                        idleTimeoutObj.lastIdle = Date.now();\\n                        idleTimeoutObj.timeout.refresh();\\n                        this.trace('Session onStreamClose' +\\n                            ((_b = session.socket) === null || _b === void 0 ? void 0 : _b.remoteAddress) +\\n                            ':' +\\n                            ((_c = session.socket) === null || _c === void 0 ? void 0 : _c.remotePort) +\\n                            ' at ' +\\n                            idleTimeoutObj.lastIdle);\\n                    }\\n                }\\n            }\\n        },\\\"name\\\",{value:\\\"Server\\\"})\"\n"])</script><script>self.__next_f.push([1,"b3:\"$EObject.defineProperty(class ServerCredentials {\\n    constructor(serverConstructorOptions, contextOptions) {\\n        this.serverConstructorOptions = serverConstructorOptions;\\n        this.watchers = new Set();\\n        this.latestContextOptions = null;\\n        this.latestContextOptions = contextOptions !== null \u0026\u0026 contextOptions !== void 0 ? contextOptions : null;\\n    }\\n    _addWatcher(watcher) {\\n        this.watchers.add(watcher);\\n    }\\n    _removeWatcher(watcher) {\\n        this.watchers.delete(watcher);\\n    }\\n    getWatcherCount() {\\n        return this.watchers.size;\\n    }\\n    updateSecureContextOptions(options) {\\n        this.latestContextOptions = options;\\n        for (const watcher of this.watchers) {\\n            watcher(this.latestContextOptions);\\n        }\\n    }\\n    _isSecure() {\\n        return this.serverConstructorOptions !== null;\\n    }\\n    _getSecureContextOptions() {\\n        return this.latestContextOptions;\\n    }\\n    _getConstructorOptions() {\\n        return this.serverConstructorOptions;\\n    }\\n    _getInterceptors() {\\n        return [];\\n    }\\n    static createInsecure() {\\n        return new InsecureServerCredentials();\\n    }\\n    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {\\n        var _a;\\n        if (rootCerts !== null \u0026\u0026 !Buffer.isBuffer(rootCerts)) {\\n            throw new TypeError('rootCerts must be null or a Buffer');\\n        }\\n        if (!Array.isArray(keyCertPairs)) {\\n            throw new TypeError('keyCertPairs must be an array');\\n        }\\n        if (typeof checkClientCertificate !== 'boolean') {\\n            throw new TypeError('checkClientCertificate must be a boolean');\\n        }\\n        const cert = [];\\n        const key = [];\\n        for (let i = 0; i \u003c keyCertPairs.length; i++) {\\n            const pair = keyCertPairs[i];\\n            if (pair === null || typeof pair !== 'object') {\\n                throw new TypeError(`keyCertPair[${i}] must be an object`);\\n            }\\n            if (!Buffer.isBuffer(pair.private_key)) {\\n                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\\n            }\\n            if (!Buffer.isBuffer(pair.cert_chain)) {\\n                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\\n            }\\n            cert.push(pair.cert_chain);\\n            key.push(pair.private_key);\\n        }\\n        return new SecureServerCredentials({\\n            requestCert: checkClientCertificate,\\n            ciphers: tls_helpers_1.CIPHER_SUITES,\\n        }, {\\n            ca: (_a = rootCerts !== null \u0026\u0026 rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null \u0026\u0026 _a !== void 0 ? _a : undefined,\\n            cert,\\n            key,\\n        });\\n    }\\n},\\\"name\\\",{value:\\\"ServerCredentials\\\"})\"\n"])</script><script>self.__next_f.push([1,"b4:\"$EObject.defineProperty((client) =\u003e {\\n    return client_1.Client.prototype.getChannel.call(client);\\n},\\\"name\\\",{value:\\\"getClientChannel\\\"})\"\nb5:\"$EObject.defineProperty(class StatusBuilder {\\n    constructor() {\\n        this.code = null;\\n        this.details = null;\\n        this.metadata = null;\\n    }\\n    /**\\n     * Adds a status code to the builder.\\n     */\\n    withCode(code) {\\n        this.code = code;\\n        return this;\\n    }\\n    /**\\n     * Adds details to the builder.\\n     */\\n    withDetails(details) {\\n        this.details = details;\\n        return this;\\n    }\\n    /**\\n     * Adds metadata to the builder.\\n     */\\n    withMetadata(metadata) {\\n        this.metadata = metadata;\\n        return this;\\n    }\\n    /**\\n     * Builds the status object.\\n     */\\n    build() {\\n        const status = {};\\n        if (this.code !== null) {\\n            status.code = this.code;\\n        }\\n        if (this.details !== null) {\\n            status.details = this.details;\\n        }\\n        if (this.metadata !== null) {\\n            status.metadata = this.metadata;\\n        }\\n        return status;\\n    }\\n},\\\"name\\\",{value:\\\"StatusBuilder\\\"})\"\nb6:\"$EObject.defineProperty(class ListenerBuilder {\\n    constructor() {\\n        this.metadata = undefined;\\n        this.message = undefined;\\n        this.status = undefined;\\n    }\\n    withOnReceiveMetadata(onReceiveMetadata) {\\n        this.metadata = onReceiveMetadata;\\n        return this;\\n    }\\n    withOnReceiveMessage(onReceiveMessage) {\\n        this.message = onReceiveMessage;\\n        return this;\\n    }\\n    withOnReceiveStatus(onReceiveStatus) {\\n        this.status = onReceiveStatus;\\n        return this;\\n    }\\n    build() {\\n        return {\\n            onReceiveMetadata: this.metadata,\\n            onReceiveMessage: this.message,\\n            onReceiveStatus: this.status,\\n        };\\n    }\\n},\\\"name\\\",{value:\\\"ListenerBuilder\\\"})\"\nb7:\"$EObject.defineProperty(class RequesterBuilder {\\n    constructor() {\\n        this.start = undefined;\\n        this.message = undefined;\\n        this.halfClose = undefined;\\n        this.cancel = undefined;\\n    }\\n    withStart(start) {\\n        this.start = start;\\n        return this;\\n    }\\n    withSendMessage(sendMessage) {\\n        this.message = sendMessage;\\n        return this;\\n    }\\n    withHalfClose(halfClose) {\\n        this.halfClose = halfClose;\\n        return this;\\n    }\\n    withCancel(cancel) {\\n        this.cancel = cancel;\\n        return this;\\n    }\\n    build() {\\n        return {\\n            start: this.start,\\n            sendMessage: this.message,\\n            halfClose: this.halfClose,\\n            cancel: this.cancel,\\n        };\\n    }\\n},\\\"name\\\",{value:\\\"RequesterBuilder\\\"})\"\n"])</script><script>self.__next_f.push([1,"b8:\"$EObject.defineProperty(class InterceptingCall {\\n    constructor(nextCall, requester) {\\n        var _a, _b, _c, _d;\\n        this.nextCall = nextCall;\\n        /**\\n         * Indicates that metadata has been passed to the requester's start\\n         * method but it has not been passed to the corresponding next callback\\n         */\\n        this.processingMetadata = false;\\n        /**\\n         * Message context for a pending message that is waiting for\\n         */\\n        this.pendingMessageContext = null;\\n        /**\\n         * Indicates that a message has been passed to the requester's sendMessage\\n         * method but it has not been passed to the corresponding next callback\\n         */\\n        this.processingMessage = false;\\n        /**\\n         * Indicates that a status was received but could not be propagated because\\n         * a message was still being processed.\\n         */\\n        this.pendingHalfClose = false;\\n        if (requester) {\\n            this.requester = {\\n                start: (_a = requester.start) !== null \u0026\u0026 _a !== void 0 ? _a : defaultRequester.start,\\n                sendMessage: (_b = requester.sendMessage) !== null \u0026\u0026 _b !== void 0 ? _b : defaultRequester.sendMessage,\\n                halfClose: (_c = requester.halfClose) !== null \u0026\u0026 _c !== void 0 ? _c : defaultRequester.halfClose,\\n                cancel: (_d = requester.cancel) !== null \u0026\u0026 _d !== void 0 ? _d : defaultRequester.cancel,\\n            };\\n        }\\n        else {\\n            this.requester = defaultRequester;\\n        }\\n    }\\n    cancelWithStatus(status, details) {\\n        this.requester.cancel(() =\u003e {\\n            this.nextCall.cancelWithStatus(status, details);\\n        });\\n    }\\n    getPeer() {\\n        return this.nextCall.getPeer();\\n    }\\n    processPendingMessage() {\\n        if (this.pendingMessageContext) {\\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\\n            this.pendingMessageContext = null;\\n            this.pendingMessage = null;\\n        }\\n    }\\n    processPendingHalfClose() {\\n        if (this.pendingHalfClose) {\\n            this.nextCall.halfClose();\\n        }\\n    }\\n    start(metadata, interceptingListener) {\\n        var _a, _b, _c, _d, _e, _f;\\n        const fullInterceptingListener = {\\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null \u0026\u0026 _b !== void 0 ? _b : (metadata =\u003e { }),\\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null \u0026\u0026 _d !== void 0 ? _d : (message =\u003e { }),\\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null \u0026\u0026 _f !== void 0 ? _f : (status =\u003e { }),\\n        };\\n        this.processingMetadata = true;\\n        this.requester.start(metadata, fullInterceptingListener, (md, listener) =\u003e {\\n            var _a, _b, _c;\\n            this.processingMetadata = false;\\n            let finalInterceptingListener;\\n            if ((0, call_interface_1.isInterceptingListener)(listener)) {\\n                finalInterceptingListener = listener;\\n            }\\n            else {\\n                const fullListener = {\\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null \u0026\u0026 _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null \u0026\u0026 _b !== void 0 ? _b : defaultListener.onReceiveMessage,\\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null \u0026\u0026 _c !== void 0 ? _c : defaultListener.onReceiveStatus,\\n                };\\n                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\\n            }\\n            this.nextCall.start(md, finalInterceptingListener);\\n            this.processPendingMessage();\\n            this.processPendingHalfClose();\\n        });\\n    }\\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    sendMessageWithContext(context, message) {\\n        this.processingMessage = true;\\n        this.requester.sendMessage(message, finalMessage =\u003e {\\n            this.processingMessage = false;\\n            if (this.processingMetadata) {\\n                this.pendingMessageContext = context;\\n                this.pendingMessage = message;\\n            }\\n            else {\\n                this.nextCall.sendMessageWithContext(context, finalMessage);\\n                this.processPendingHalfClose();\\n            }\\n        });\\n    }\\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    sendMessage(message) {\\n        this.sendMessageWithContext({}, message);\\n    }\\n    startRead() {\\n        this.nextCall.startRead();\\n    }\\n    halfClose() {\\n        this.requester.halfClose(() =\u003e {\\n            if (this.processingMetadata || this.processingMessage) {\\n                this.pendingHalfClose = true;\\n            }\\n            else {\\n                this.nextCall.halfClose();\\n            }\\n        });\\n    }\\n},\\\"name\\\",{value:\\\"InterceptingCall\\\"})\"\n"])</script><script>self.__next_f.push([1,"b9:\"$EObject.defineProperty(class InterceptorConfigurationError extends Error {\\n    constructor(message) {\\n        super(message);\\n        this.name = 'InterceptorConfigurationError';\\n        Error.captureStackTrace(this, InterceptorConfigurationError);\\n    }\\n},\\\"name\\\",{value:\\\"InterceptorConfigurationError\\\"})\"\nba:\"$EObject.defineProperty(function getChannelzServiceDefinition() {\\n    if (loadedChannelzDefinition) {\\n        return loadedChannelzDefinition;\\n    }\\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\\n     * runtime for users who will not use/enable channelz. */\\n    const loaderLoadSync = require('@grpc/proto-loader')\\n        .loadSync;\\n    const loadedProto = loaderLoadSync('channelz.proto', {\\n        keepCase: true,\\n        longs: String,\\n        enums: String,\\n        defaults: true,\\n        oneofs: true,\\n        includeDirs: [`${__dirname}/../../proto`],\\n    });\\n    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);\\n    loadedChannelzDefinition =\\n        channelzGrpcObject.grpc.channelz.v1.Channelz.service;\\n    return loadedChannelzDefinition;\\n},\\\"name\\\",{value:\\\"getChannelzServiceDefinition\\\"})\"\nbb:\"$EObject.defineProperty(function getChannelzHandlers() {\\n    return {\\n        GetChannel,\\n        GetTopChannels,\\n        GetServer,\\n        GetServers,\\n        GetSubchannel,\\n        GetSocket,\\n        GetServerSockets,\\n    };\\n},\\\"name\\\",{value:\\\"getChannelzHandlers\\\"})\"\nbc:\"$EObject.defineProperty(function addAdminServicesToServer(server) {\\n    for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {\\n        server.addService(getServiceDefinition(), getHandlers());\\n    }\\n},\\\"name\\\",{value:\\\"addAdminServicesToServer\\\"})\"\nbd:\"$EObject.defineProperty(class ServerListenerBuilder {\\n    constructor() {\\n        this.metadata = undefined;\\n        this.message = undefined;\\n        this.halfClose = undefined;\\n        this.cancel = undefined;\\n    }\\n    withOnReceiveMetadata(onReceiveMetadata) {\\n        this.metadata = onReceiveMetadata;\\n        return this;\\n    }\\n    withOnReceiveMessage(onReceiveMessage) {\\n        this.message = onReceiveMessage;\\n        return this;\\n    }\\n    withOnReceiveHalfClose(onReceiveHalfClose) {\\n        this.halfClose = onReceiveHalfClose;\\n        return this;\\n    }\\n    withOnCancel(onCancel) {\\n        this.cancel = onCancel;\\n        return this;\\n    }\\n    build() {\\n        return {\\n            onReceiveMetadata: this.metadata,\\n            onReceiveMessage: this.message,\\n            onReceiveHalfClose: this.halfClose,\\n            onCancel: this.cancel,\\n        };\\n    }\\n},\\\"name\\\",{value:\\\"ServerListenerBuilder\\\"})\"\nbe:\"$EObject.defineProperty(class ResponderBuilder {\\n    constructor() {\\n        this.start = undefined;\\n        this.metadata = undefined;\\n        this.message = undefined;\\n        this.status = undefined;\\n    }\\n    withStart(start) {\\n        this.start = start;\\n        return this;\\n    }\\n    withSendMetadata(sendMetadata) {\\n        this.metadata = sendMetadata;\\n        return this;\\n    }\\n    withSendMessage(sendMessage) {\\n        this.message = sendMessage;\\n        return this;\\n    }\\n    withSendStatus(sendStatus) {\\n        this.status = sendStatus;\\n        return this;\\n    }\\n    build() {\\n        return {\\n            start: this.start,\\n            sendMetadata: this.metadata,\\n            sendMessage: this.message,\\n            sendStatus: this.status,\\n        };\\n    }\\n},\\\"name\\\",{value:\\\"ResponderBuilder\\\"})\"\n"])</script><script>self.__next_f.push([1,"bf:\"$EObject.defineProperty(class ServerInterceptingCall {\\n    constructor(nextCall, responder) {\\n        var _a, _b, _c, _d;\\n        this.nextCall = nextCall;\\n        this.processingMetadata = false;\\n        this.sentMetadata = false;\\n        this.processingMessage = false;\\n        this.pendingMessage = null;\\n        this.pendingMessageCallback = null;\\n        this.pendingStatus = null;\\n        this.responder = {\\n            start: (_a = responder === null || responder === void 0 ? void 0 : responder.start) !== null \u0026\u0026 _a !== void 0 ? _a : defaultResponder.start,\\n            sendMetadata: (_b = responder === null || responder === void 0 ? void 0 : responder.sendMetadata) !== null \u0026\u0026 _b !== void 0 ? _b : defaultResponder.sendMetadata,\\n            sendMessage: (_c = responder === null || responder === void 0 ? void 0 : responder.sendMessage) !== null \u0026\u0026 _c !== void 0 ? _c : defaultResponder.sendMessage,\\n            sendStatus: (_d = responder === null || responder === void 0 ? void 0 : responder.sendStatus) !== null \u0026\u0026 _d !== void 0 ? _d : defaultResponder.sendStatus,\\n        };\\n    }\\n    processPendingMessage() {\\n        if (this.pendingMessageCallback) {\\n            this.nextCall.sendMessage(this.pendingMessage, this.pendingMessageCallback);\\n            this.pendingMessage = null;\\n            this.pendingMessageCallback = null;\\n        }\\n    }\\n    processPendingStatus() {\\n        if (this.pendingStatus) {\\n            this.nextCall.sendStatus(this.pendingStatus);\\n            this.pendingStatus = null;\\n        }\\n    }\\n    start(listener) {\\n        this.responder.start(interceptedListener =\u003e {\\n            var _a, _b, _c, _d;\\n            const fullInterceptedListener = {\\n                onReceiveMetadata: (_a = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMetadata) !== null \u0026\u0026 _a !== void 0 ? _a : defaultServerListener.onReceiveMetadata,\\n                onReceiveMessage: (_b = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMessage) !== null \u0026\u0026 _b !== void 0 ? _b : defaultServerListener.onReceiveMessage,\\n                onReceiveHalfClose: (_c = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveHalfClose) !== null \u0026\u0026 _c !== void 0 ? _c : defaultServerListener.onReceiveHalfClose,\\n                onCancel: (_d = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onCancel) !== null \u0026\u0026 _d !== void 0 ? _d : defaultServerListener.onCancel,\\n            };\\n            const finalInterceptingListener = new InterceptingServerListenerImpl(fullInterceptedListener, listener);\\n            this.nextCall.start(finalInterceptingListener);\\n        });\\n    }\\n    sendMetadata(metadata) {\\n        this.processingMetadata = true;\\n        this.sentMetadata = true;\\n        this.responder.sendMetadata(metadata, interceptedMetadata =\u003e {\\n            this.processingMetadata = false;\\n            this.nextCall.sendMetadata(interceptedMetadata);\\n            this.processPendingMessage();\\n            this.processPendingStatus();\\n        });\\n    }\\n    sendMessage(message, callback) {\\n        this.processingMessage = true;\\n        if (!this.sentMetadata) {\\n            this.sendMetadata(new metadata_1.Metadata());\\n        }\\n        this.responder.sendMessage(message, interceptedMessage =\u003e {\\n            this.processingMessage = false;\\n            if (this.processingMetadata) {\\n                this.pendingMessage = interceptedMessage;\\n                this.pendingMessageCallback = callback;\\n            }\\n            else {\\n                this.nextCall.sendMessage(interceptedMessage, callback);\\n            }\\n        });\\n    }\\n    sendStatus(status) {\\n        this.responder.sendStatus(status, interceptedStatus =\u003e {\\n            if (this.processingMetadata || this.processingMessage) {\\n                this.pendingStatus = interceptedStatus;\\n            }\\n            else {\\n                this.nextCall.sendStatus(interceptedStatus);\\n            }\\n        });\\n    }\\n    startRead() {\\n        this.nextCall.startRead();\\n    }\\n    getPeer() {\\n        return this.nextCall.getPeer();\\n    }\\n    getDeadline() {\\n        return this.nextCall.getDeadline();\\n    }\\n    getHost() {\\n        return this.nextCall.getHost();\\n    }\\n},\\\"name\\\",{value:\\\"ServerInterceptingCall\\\"})\"\n"])</script><script>self.__next_f.push([1,"c0:\"$EObject.defineProperty(class OngoingCall {\\n    /**\\n     * OngoingCall manages callback, API calls, and cancellation\\n     * of the API calls.\\n     * @param {APICallback=} callback\\n     *   The callback to be called asynchronously when the API call\\n     *   finishes.\\n     * @constructor\\n     * @property {APICallback} callback\\n     *   The callback function to be called.\\n     * @private\\n     */\\n    constructor(callback) {\\n        this.callback = callback;\\n        this.completed = false;\\n    }\\n    /**\\n     * Cancels the ongoing promise.\\n     */\\n    cancel() {\\n        if (this.completed) {\\n            return;\\n        }\\n        this.completed = true;\\n        if (this.cancelFunc) {\\n            this.cancelFunc();\\n        }\\n        else {\\n            const error = new googleError_1.GoogleError('cancelled');\\n            error.code = status_1.Status.CANCELLED;\\n            this.callback(error);\\n        }\\n    }\\n    /**\\n     * Call calls the specified function. Result will be used to fulfill\\n     * the promise.\\n     *\\n     * @param {SimpleCallbackFunction} func\\n     *   A function for an API call.\\n     * @param {Object} argument\\n     *   A request object.\\n     */\\n    call(func, argument) {\\n        if (this.completed) {\\n            return;\\n        }\\n        const canceller = func(argument, (err, response, next, rawResponse) =\u003e {\\n            this.completed = true;\\n            setImmediate(this.callback, err, response, next, rawResponse);\\n        });\\n        if (canceller instanceof Promise) {\\n            canceller.catch(err =\u003e {\\n                setImmediate(this.callback, new googleError_1.GoogleError(err), null, null, null);\\n            });\\n        }\\n        this.cancelFunc = () =\u003e canceller.cancel();\\n    }\\n},\\\"name\\\",{value:\\\"OngoingCall\\\"})\"\n"])</script><script>self.__next_f.push([1,"c1:\"$EObject.defineProperty(function createApiCall(func, settings, descriptor, \\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\\n_fallback // unused here, used in fallback.ts implementation\\n) {\\n    // we want to be able to accept both promise resolving to a function and a\\n    // function. Currently client librares are only calling this method with a\\n    // promise, but it will change.\\n    const funcPromise = typeof func === 'function' ? Promise.resolve(func) : func;\\n    // the following apiCaller will be used for all calls of this function...\\n    const apiCaller = (0, apiCaller_1.createAPICaller)(settings, descriptor);\\n    return (request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    };\\n},\\\"name\\\",{value:\\\"createApiCall\\\"})\"\n"])</script><script>self.__next_f.push([1,"c2:\"$EObject.defineProperty(class BundleDescriptor {\\n    /**\\n     * Describes the structure of bundled call.\\n     *\\n     * requestDiscriminatorFields may include '.' as a separator, which is used to\\n     * indicate object traversal. This allows fields in nested objects to be used\\n     * to determine what request to bundle.\\n     *\\n     * @property {String} bundledField\\n     * @property {String} requestDiscriminatorFields\\n     * @property {String} subresponseField\\n     * @property {Function} byteLengthFunction\\n     *\\n     * @param {String} bundledField - the repeated field in the request message\\n     *   that will have its elements aggregated by bundling.\\n     * @param {String} requestDiscriminatorFields - a list of fields in the\\n     *   target request message class that are used to detemrine which request\\n     *   messages should be bundled together.\\n     * @param {String} subresponseField - an optional field, when present it\\n     *   indicates the field in the response message that should be used to\\n     *   demultiplex the response into multiple response messages.\\n     * @param {Function} byteLengthFunction - a function to obtain the byte\\n     *   length to be consumed for the bundled field messages. Because Node.JS\\n     *   protobuf.js/gRPC uses builtin Objects for the user-visible data and\\n     *   internally they are encoded/decoded in protobuf manner, this function\\n     *   is actually necessary to calculate the byte length.\\n     * @constructor\\n     */\\n    constructor(bundledField, requestDiscriminatorFields, subresponseField, byteLengthFunction) {\\n        if (!byteLengthFunction \u0026\u0026 typeof subresponseField === 'function') {\\n            byteLengthFunction = subresponseField;\\n            subresponseField = null;\\n        }\\n        this.bundledField = bundledField;\\n        this.requestDiscriminatorFields =\\n            requestDiscriminatorFields.map(util_1.toCamelCase);\\n        this.subresponseField = subresponseField;\\n        this.byteLengthFunction = byteLengthFunction;\\n    }\\n    getApiCaller(settings) {\\n        if (settings.isBundling === false) {\\n            return new normalApiCaller_1.NormalApiCaller();\\n        }\\n        return new bundleApiCaller_1.BundleApiCaller(new bundleExecutor_1.BundleExecutor(settings.bundleOptions, this));\\n    }\\n},\\\"name\\\",{value:\\\"BundleDescriptor\\\"})\"\n"])</script><script>self.__next_f.push([1,"c3:\"$EObject.defineProperty(class LongRunningDescriptor {\\n    constructor(operationsClient, responseDecoder, metadataDecoder) {\\n        this.operationsClient = operationsClient;\\n        this.responseDecoder = responseDecoder;\\n        this.metadataDecoder = metadataDecoder;\\n    }\\n    getApiCaller() {\\n        return new longRunningApiCaller_1.LongrunningApiCaller(this);\\n    }\\n},\\\"name\\\",{value:\\\"LongRunningDescriptor\\\"})\"\n"])</script><script>self.__next_f.push([1,"c4:\"$EObject.defineProperty(class PageDescriptor {\\n    constructor(requestPageTokenField, responsePageTokenField, resourceField) {\\n        this.requestPageTokenField = requestPageTokenField;\\n        this.responsePageTokenField = responsePageTokenField;\\n        this.resourceField = resourceField;\\n    }\\n    /**\\n     * Creates a new object Stream which emits the resource on 'data' event.\\n     */\\n    createStream(apiCall, request, options) {\\n        const stream = new stream_1.PassThrough({ objectMode: true });\\n        options = Object.assign({}, options, { autoPaginate: false });\\n        const maxResults = 'maxResults' in options ? options.maxResults : -1;\\n        let pushCount = 0;\\n        let started = false;\\n        function callback(err, resources, next, apiResp) {\\n            if (err) {\\n                stream.emit('error', err);\\n                return;\\n            }\\n            // emit full api response with every page.\\n            stream.emit('response', apiResp);\\n            for (let i = 0; i \u003c resources.length; ++i) {\\n                // TODO: rewrite without accessing stream internals\\n                if (stream\\n                    ._readableState.ended) {\\n                    return;\\n                }\\n                if (resources[i] === null) {\\n                    continue;\\n                }\\n                stream.push(resources[i]);\\n                pushCount++;\\n                if (pushCount === maxResults) {\\n                    stream.end();\\n                }\\n            }\\n            // TODO: rewrite without accessing stream internals\\n            if (stream._readableState\\n                .ended) {\\n                return;\\n            }\\n            if (!next) {\\n                stream.end();\\n                return;\\n            }\\n            // When pageToken is specified in the original options, it will overwrite\\n            // the page token field in the next request. Therefore it must be cleared.\\n            if ('pageToken' in options) {\\n                delete options.pageToken;\\n            }\\n            if (stream.isPaused()) {\\n                request = next;\\n                started = false;\\n            }\\n            else {\\n                setImmediate(apiCall, next, options, callback);\\n            }\\n        }\\n        stream.on('resume', () =\u003e {\\n            if (!started) {\\n                started = true;\\n                apiCall(request, options, callback);\\n            }\\n        });\\n        return stream;\\n    }\\n    /**\\n     * Create an async iterable which can be recursively called for data on-demand.\\n     */\\n    asyncIterate(apiCall, request, options) {\\n        options = Object.assign({}, options, { autoPaginate: false });\\n        const iterable = this.createIterator(apiCall, request, options);\\n        return iterable;\\n    }\\n    createIterator(apiCall, request, options) {\\n        const asyncIterable = {\\n            [Symbol.asyncIterator]() {\\n                let nextPageRequest = request;\\n                const cache = [];\\n                return {\\n                    async next() {\\n                        if (cache.length \u003e 0) {\\n                            return Promise.resolve({\\n                                done: false,\\n                                value: cache.shift(),\\n                            });\\n                        }\\n                        let attempts = 0;\\n                        while (cache.length === 0 \u0026\u0026 nextPageRequest) {\\n                            let result;\\n                            [result, nextPageRequest] = (await apiCall(nextPageRequest, options));\\n                            // For pagination response with protobuf map type, use tuple as representation.\\n                            if (result \u0026\u0026 !Array.isArray(result)) {\\n                                for (const [key, value] of Object.entries(result)) {\\n                                    cache.push([key, value]);\\n                                }\\n                            }\\n                            else {\\n                                cache.push(...result);\\n                            }\\n                            if (cache.length === 0) {\\n                                ++attempts;\\n                                if (attempts \u003e maxAttemptsEmptyResponse) {\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        if (cache.length === 0) {\\n                            return Promise.resolve({ done: true, value: undefined });\\n                        }\\n                        return Promise.resolve({ done: false, value: cache.shift() });\\n                    },\\n                };\\n            },\\n        };\\n        return asyncIterable;\\n    }\\n    getApiCaller(settings) {\\n        if (!settings.autoPaginate) {\\n            return new normalApiCaller_1.NormalApiCaller();\\n        }\\n        return new pagedApiCaller_1.PagedApiCaller(this);\\n    }\\n},\\\"name\\\",{value:\\\"PageDescriptor\\\"})\"\n"])</script><script>self.__next_f.push([1,"c5:\"$EObject.defineProperty(class StreamDescriptor {\\n    constructor(streamType, rest, gaxStreamingRetries) {\\n        this.type = streamType;\\n        this.streaming = true;\\n        this.rest = rest;\\n        this.gaxStreamingRetries = gaxStreamingRetries;\\n    }\\n    getApiCaller() {\\n        // Right now retrying does not work with gRPC-streaming, because retryable\\n        // assumes an API call returns an event emitter while gRPC-streaming methods\\n        // return Stream.\\n        return new streamingApiCaller_1.StreamingApiCaller(this);\\n    }\\n},\\\"name\\\",{value:\\\"StreamDescriptor\\\"})\"\n"])</script><script>self.__next_f.push([1,"c6:\"$EObject.defineProperty(class CallSettings {\\n    /**\\n     * @param {Object} settings - An object containing parameters of this settings.\\n     * @param {number} settings.timeout - The client-side timeout for API calls.\\n     *   This parameter is ignored for retrying calls.\\n     * @param {RetryOptions} settings.retry - The configuration for retrying upon\\n     *   transient error. If set to null, this call will not retry.\\n     * @param {boolean} settings.autoPaginate - If there is no `pageDescriptor`,\\n     *   this attrbute has no meaning. Otherwise, determines whether a page\\n     * streamed response should make the page structure transparent to the user by\\n     *   flattening the repeated field in the returned generator.\\n     * @param {number} settings.pageToken - If there is no `pageDescriptor`,\\n     *   this attribute has no meaning. Otherwise, determines the page token used\\n     * in the page streaming request.\\n     * @param {Object} settings.otherArgs - Additional arguments to be passed to\\n     *   the API calls.\\n     *\\n     * @constructor\\n     */\\n    constructor(settings) {\\n        var _a;\\n        settings = settings || {};\\n        this.timeout = settings.timeout || 30 * 1000;\\n        this.retry = settings.retry;\\n        this.autoPaginate =\\n            'autoPaginate' in settings ? settings.autoPaginate : true;\\n        this.maxResults = settings.maxResults;\\n        this.otherArgs = settings.otherArgs || {};\\n        this.bundleOptions = settings.bundleOptions;\\n        this.isBundling = 'isBundling' in settings ? settings.isBundling : true;\\n        this.longrunning =\\n            'longrunning' in settings ? settings.longrunning : undefined;\\n        this.apiName = (_a = settings.apiName) !== null \u0026\u0026 _a !== void 0 ? _a : undefined;\\n        this.retryRequestOptions = settings.retryRequestOptions;\\n    }\\n    /**\\n     * Returns a new CallSettings merged from this and a CallOptions object.\\n     *\\n     * @param {CallOptions} options - an instance whose values override\\n     *   those in this object. If null, ``merge`` returns a copy of this\\n     *   object\\n     * @return {CallSettings} The merged CallSettings instance.\\n     */\\n    merge(options) {\\n        if (!options) {\\n            return new CallSettings(this);\\n        }\\n        let timeout = this.timeout;\\n        let retry = this.retry;\\n        let autoPaginate = this.autoPaginate;\\n        let maxResults = this.maxResults;\\n        let otherArgs = this.otherArgs;\\n        let isBundling = this.isBundling;\\n        let longrunning = this.longrunning;\\n        let apiName = this.apiName;\\n        let retryRequestOptions = this.retryRequestOptions;\\n        // If the user provides a timeout to the method, that timeout value will be used\\n        // to override the backoff settings.\\n        if ('timeout' in options) {\\n            timeout = options.timeout;\\n        }\\n        // If a method-specific timeout is set in the service config, and the retry codes for that\\n        // method are non-null, then that timeout value will be used to\\n        // override backoff settings.\\n        if (retry === null || retry === void 0 ? void 0 : retry.retryCodes) {\\n            retry.backoffSettings.initialRpcTimeoutMillis = timeout;\\n            retry.backoffSettings.maxRpcTimeoutMillis = timeout;\\n            retry.backoffSettings.totalTimeoutMillis = timeout;\\n        }\\n        if ('retry' in options) {\\n            retry = mergeRetryOptions(retry || {}, options.retry);\\n        }\\n        if ('autoPaginate' in options \u0026\u0026 !options.autoPaginate) {\\n            autoPaginate = false;\\n        }\\n        if ('maxResults' in options) {\\n            maxResults = options.maxResults;\\n        }\\n        if ('otherArgs' in options) {\\n            otherArgs = {};\\n            for (const key in this.otherArgs) {\\n                otherArgs[key] = this.otherArgs[key];\\n            }\\n            for (const optionsKey in options.otherArgs) {\\n                otherArgs[optionsKey] = options.otherArgs[optionsKey];\\n            }\\n        }\\n        if ('isBundling' in options) {\\n            isBundling = options.isBundling;\\n        }\\n        if ('maxRetries' in options \u0026\u0026 options.maxRetries !== undefined) {\\n            retry.backoffSettings.maxRetries = options.maxRetries;\\n            delete retry.backoffSettings.totalTimeoutMillis;\\n        }\\n        if ('longrunning' in options) {\\n            longrunning = options.longrunning;\\n        }\\n        if ('apiName' in options) {\\n            apiName = options.apiName;\\n        }\\n        if ('retryRequestOptions' in options) {\\n            retryRequestOptions = options.retryRequestOptions;\\n        }\\n        return new CallSettings({\\n            timeout,\\n            retry,\\n            bundleOptions: this.bundleOptions,\\n            longrunning,\\n            autoPaginate,\\n            maxResults,\\n            otherArgs,\\n            isBundling,\\n            apiName,\\n            retryRequestOptions,\\n        });\\n    }\\n},\\\"name\\\",{value:\\\"CallSettings\\\"})\"\n"])</script><script>self.__next_f.push([1,"c7:\"$EObject.defineProperty(function constructSettings(serviceName, clientConfig, configOverrides, retryNames, otherArgs) {\\n    otherArgs = otherArgs || {};\\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    const defaults = {};\\n    const serviceConfig = (clientConfig.interfaces || {})[serviceName];\\n    if (!serviceConfig) {\\n        return null;\\n    }\\n    // users can override the config from client side, like bundling options.\\n    // The detailed structure of the clientConfig can be found here: https://github.com/googleapis/gax-nodejs/blob/main/src/gax.ts#L546\\n    // The way to override bundling options:\\n    //\\n    // const customConfig = {\\\"interfaces\\\": {\\\"service\\\": {\\\"methods\\\": {\\\"methodName\\\": {\\\"bundling\\\": {..}}}}}}\\n    // const client = new Client({ projectId, customConfig });\\n    const overrides = (configOverrides.interfaces || {})[serviceName] || {};\\n    const methods = serviceConfig.methods;\\n    const overridingMethods = overrides.methods || {};\\n    for (const methodName in methods) {\\n        const methodConfig = methods[methodName];\\n        const jsName = (0, util_1.toLowerCamelCase)(methodName);\\n        let retry = constructRetry(methodConfig, serviceConfig.retry_codes, serviceConfig.retry_params, retryNames);\\n        let bundlingConfig = methodConfig.bundling;\\n        let timeout = methodConfig.timeout_millis;\\n        if (methodName in overridingMethods) {\\n            const overridingMethod = overridingMethods[methodName];\\n            if (overridingMethod) {\\n                if ('bundling' in overridingMethod) {\\n                    bundlingConfig = overridingMethod.bundling;\\n                }\\n                if ('timeout_millis' in overridingMethod) {\\n                    timeout = overridingMethod.timeout_millis;\\n                }\\n            }\\n            retry = mergeRetryOptions(retry, constructRetry(overridingMethod, overrides.retry_codes, overrides.retry_params, retryNames));\\n        }\\n        const apiName = serviceName;\\n        defaults[jsName] = new CallSettings({\\n            timeout,\\n            retry,\\n            bundleOptions: bundlingConfig\\n                ? createBundleOptions(bundlingConfig)\\n                : null,\\n            otherArgs,\\n            apiName,\\n        });\\n    }\\n    return defaults;\\n},\\\"name\\\",{value:\\\"constructSettings\\\"})\"\n"])</script><script>self.__next_f.push([1,"c8:\"$EObject.defineProperty(class RetryOptions {\\n    constructor(retryCodes, backoffSettings, shouldRetryFn, getResumptionRequestFn) {\\n        this.retryCodes = retryCodes;\\n        this.backoffSettings = backoffSettings;\\n        this.shouldRetryFn = shouldRetryFn;\\n        this.getResumptionRequestFn = getResumptionRequestFn;\\n    }\\n},\\\"name\\\",{value:\\\"RetryOptions\\\"})\"\nc9:\"$EObject.defineProperty(function createRetryOptions(retryCodes, backoffSettings, shouldRetryFn, getResumptionRequestFn) {\\n    return {\\n        retryCodes,\\n        backoffSettings,\\n        shouldRetryFn,\\n        getResumptionRequestFn,\\n    };\\n},\\\"name\\\",{value:\\\"createRetryOptions\\\"})\"\nca:\"$EObject.defineProperty(function createBundleOptions(options) {\\n    const params = [\\n        'element_count_threshold',\\n        'element_count_limit',\\n        'request_byte_threshold',\\n        'request_byte_limit',\\n        'delay_threshold_millis',\\n    ];\\n    params.forEach(param =\u003e {\\n        if (param in options \u0026\u0026 typeof options[param] !== 'number') {\\n            throw new Error(`${param} should be a number`);\\n        }\\n    });\\n    const elementCountThreshold = options.element_count_threshold || 0;\\n    const elementCountLimit = options.element_count_limit || 0;\\n    const requestByteThreshold = options.request_byte_threshold || 0;\\n    const requestByteLimit = options.request_byte_limit || 0;\\n    const delayThreshold = options.delay_threshold_millis || 0;\\n    if (elementCountThreshold === 0 \u0026\u0026\\n        requestByteThreshold === 0 \u0026\u0026\\n        delayThreshold === 0) {\\n        throw new Error('one threshold should be \u003e 0');\\n    }\\n    return {\\n        elementCountThreshold,\\n        elementCountLimit,\\n        requestByteThreshold,\\n        requestByteLimit,\\n        delayThreshold,\\n    };\\n},\\\"name\\\",{value:\\\"createBundleOptions\\\"})\"\ncb:\"$EObject.defineProperty(function createBackoffSettings(initialRetryDelayMillis, retryDelayMultiplier, maxRetryDelayMillis, initialRpcTimeoutMillis, rpcTimeoutMultiplier, maxRpcTimeoutMillis, totalTimeoutMillis) {\\n    return {\\n        initialRetryDelayMillis,\\n        retryDelayMultiplier,\\n        maxRetryDelayMillis,\\n        initialRpcTimeoutMillis,\\n        rpcTimeoutMultiplier,\\n        maxRpcTimeoutMillis,\\n        totalTimeoutMillis,\\n    };\\n},\\\"name\\\",{value:\\\"createBackoffSettings\\\"})\"\ncc:\"$EObject.defineProperty(function createDefaultBackoffSettings() {\\n    return createBackoffSettings(100, 1.3, 60000, null, null, null, null);\\n},\\\"name\\\",{value:\\\"createDefaultBackoffSettings\\\"})\"\ncd:\"$EObject.defineProperty(function createMaxRetriesBackoffSettings(initialRetryDelayMillis, retryDelayMultiplier, maxRetryDelayMillis, initialRpcTimeoutMillis, rpcTimeoutMultiplier, maxRpcTimeoutMillis, maxRetries) {\\n    return {\\n        initialRetryDelayMillis,\\n        retryDelayMultiplier,\\n        maxRetryDelayMillis,\\n        initialRpcTimeoutMillis,\\n        rpcTimeoutMultiplier,\\n        maxRpcTimeoutMillis,\\n        maxRetries,\\n    };\\n},\\\"name\\\",{value:\\\"createMaxRetriesBackoffSettings\\\"})\"\n"])</script><script>self.__next_f.push([1,"ce:\"$EObject.defineProperty(class GoogleError extends Error {\\n    // Parse details field in google.rpc.status wire over gRPC medatadata.\\n    // Promote google.rpc.ErrorInfo if exist.\\n    static parseGRPCStatusDetails(err) {\\n        const decoder = new GoogleErrorDecoder();\\n        try {\\n            if (err.metadata \u0026\u0026 err.metadata.get('grpc-status-details-bin')) {\\n                const statusDetailsObj = decoder.decodeGRPCStatusDetails(err.metadata.get('grpc-status-details-bin'));\\n                if (statusDetailsObj \u0026\u0026\\n                    statusDetailsObj.details \u0026\u0026\\n                    statusDetailsObj.details.length \u003e 0) {\\n                    err.statusDetails = statusDetailsObj.details;\\n                }\\n                if (statusDetailsObj \u0026\u0026 statusDetailsObj.errorInfo) {\\n                    err.reason = statusDetailsObj.errorInfo.reason;\\n                    err.domain = statusDetailsObj.errorInfo.domain;\\n                    err.errorInfoMetadata = statusDetailsObj.errorInfo.metadata;\\n                }\\n            }\\n        }\\n        catch (decodeErr) {\\n            // ignoring the error\\n        }\\n        return err;\\n    }\\n    // Parse http JSON error and promote google.rpc.ErrorInfo if exist.\\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    static parseHttpError(json) {\\n        if (Array.isArray(json)) {\\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n            json = json.find((obj) =\u003e {\\n                return 'error' in obj;\\n            });\\n        }\\n        // fallback logic.\\n        // related issue: https://github.com/googleapis/gax-nodejs/issues/1303\\n        // google error mapping: https://cloud.google.com/apis/design/errors\\n        // if input json doesn't have 'error' fields, wrap the whole object with 'error' field\\n        if (!json['error']) {\\n            json['error'] = {};\\n            Object.keys(json)\\n                .filter(key =\u003e key !== 'error')\\n                .forEach(key =\u003e {\\n                json['error'][key] = json[key];\\n                delete json[key];\\n            });\\n        }\\n        const decoder = new GoogleErrorDecoder();\\n        const proto3Error = decoder.decodeHTTPError(json['error']);\\n        const error = Object.assign(new GoogleError(json['error']['message']), proto3Error);\\n        // Map Http Status Code to gRPC Status Code\\n        if (json['error']['code']) {\\n            error.code = (0, status_1.rpcCodeFromHttpStatusCode)(json['error']['code']);\\n        }\\n        else {\\n            // If error code is absent, proto3 message default value is 0. We should\\n            // keep error code as undefined.\\n            delete error.code;\\n        }\\n        // Keep consistency with gRPC statusDetails fields. gRPC details has been occupied before.\\n        // Rename \\\"details\\\" to \\\"statusDetails\\\".\\n        if (error.details) {\\n            try {\\n                const statusDetailsObj = decoder.decodeHttpStatusDetails(error.details);\\n                if (statusDetailsObj \u0026\u0026\\n                    statusDetailsObj.details \u0026\u0026\\n                    statusDetailsObj.details.length \u003e 0) {\\n                    error.statusDetails = statusDetailsObj.details;\\n                }\\n                if (statusDetailsObj \u0026\u0026 statusDetailsObj.errorInfo) {\\n                    error.reason = statusDetailsObj.errorInfo.reason;\\n                    error.domain = statusDetailsObj.errorInfo.domain;\\n                    // error.metadata has been occupied for gRPC metadata, so we use\\n                    // errorInfoMetadata to represent ErrorInfo' metadata field. Keep\\n                    // consistency with gRPC ErrorInfo metadata field name.\\n                    error.errorInfoMetadata = statusDetailsObj.errorInfo.metadata;\\n                }\\n            }\\n            catch (decodeErr) {\\n                // ignoring the error\\n            }\\n        }\\n        return error;\\n    }\\n},\\\"name\\\",{value:\\\"GoogleError\\\"})\"\n"])</script><script>self.__next_f.push([1,"cf:\"$EObject.defineProperty(class ClientStub extends grpc.Client {\\n},\\\"name\\\",{value:\\\"ClientStub\\\"})\"\n"])</script><script>self.__next_f.push([1,"d0:\"$EObject.defineProperty(class GoogleProtoFilesRoot extends protobuf.Root {\\n    constructor(...args) {\\n        super(...args);\\n    }\\n    // Causes the loading of an included proto to check if it is a common\\n    // proto. If it is a common proto, use the bundled proto.\\n    resolvePath(originPath, includePath) {\\n        originPath = path.normalize(originPath);\\n        includePath = path.normalize(includePath);\\n        // Fully qualified paths don't need to be resolved.\\n        if (path.isAbsolute(includePath)) {\\n            if (!fs.existsSync(includePath)) {\\n                throw new Error('The include `' + includePath + '` was not found.');\\n            }\\n            return includePath;\\n        }\\n        if (COMMON_PROTO_FILES.indexOf(includePath) \u003e -1) {\\n            return path.join(googleProtoFilesDir, includePath);\\n        }\\n        return GoogleProtoFilesRoot._findIncludePath(originPath, includePath);\\n    }\\n    static _findIncludePath(originPath, includePath) {\\n        originPath = path.normalize(originPath);\\n        includePath = path.normalize(includePath);\\n        let current = originPath;\\n        let found = fs.existsSync(path.join(current, includePath));\\n        while (!found \u0026\u0026 current.length \u003e 0) {\\n            current = current.substring(0, current.lastIndexOf(path.sep));\\n            found = fs.existsSync(path.join(current, includePath));\\n        }\\n        if (!found) {\\n            throw new Error('The include `' + includePath + '` was not found.');\\n        }\\n        return path.join(current, includePath);\\n    }\\n},\\\"name\\\",{value:\\\"GoogleProtoFilesRoot\\\"})\"\n"])</script><script>self.__next_f.push([1,"d1:\"$EObject.defineProperty(class GrpcClient {\\n    /**\\n     * Key for proto cache map. We are doing our best to make sure we respect\\n     * the options, so if the same proto file is loaded with different set of\\n     * options, the cache won't be used.  Since some of the options are\\n     * Functions (e.g. `enums: String` - see below in `loadProto()`),\\n     * they will be omitted from the cache key.  If the cache breaks anything\\n     * for you, use the `ignoreCache` parameter of `loadProto()` to disable it.\\n     */\\n    static protoCacheKey(filename, options) {\\n        if (!filename ||\\n            (Array.isArray(filename) \u0026\u0026 (filename.length === 0 || !filename[0]))) {\\n            return undefined;\\n        }\\n        return JSON.stringify(filename) + ' ' + JSON.stringify(options);\\n    }\\n    /**\\n     * In rare cases users might need to deallocate all memory consumed by loaded protos.\\n     * This method will delete the proto cache content.\\n     */\\n    static clearProtoCache() {\\n        GrpcClient.protoCache.clear();\\n    }\\n    /**\\n     * A class which keeps the context of gRPC and auth for the gRPC.\\n     *\\n     * @param {Object=} options - The optional parameters. It will be directly\\n     *   passed to google-auth-library library, so parameters like keyFile or\\n     *   credentials will be valid.\\n     * @param {Object=} options.auth - An instance of google-auth-library.\\n     *   When specified, this auth instance will be used instead of creating\\n     *   a new one.\\n     * @param {Object=} options.grpc - When specified, this will be used\\n     *   for the 'grpc' module in this context. By default, it will load the grpc\\n     *   module in the standard way.\\n     * @constructor\\n     */\\n    constructor(options = {}) {\\n        var _a;\\n        this.auth = options.auth || new google_auth_library_1.GoogleAuth(options);\\n        this.fallback = false;\\n        const minimumVersion = 10;\\n        const major = Number((_a = process.version.match(/^v(\\\\d+)/)) === null || _a === void 0 ? void 0 : _a[1]);\\n        if (Number.isNaN(major) || major \u003c minimumVersion) {\\n            const errorMessage = `Node.js v${minimumVersion}.0.0 is a minimum requirement. To learn about legacy version support visit: ` +\\n                'https://github.com/googleapis/google-cloud-node#supported-nodejs-versions';\\n            throw new Error(errorMessage);\\n        }\\n        if ('grpc' in options) {\\n            this.grpc = options.grpc;\\n            this.grpcVersion = '';\\n        }\\n        else {\\n            this.grpc = grpc;\\n            this.grpcVersion = require('@grpc/grpc-js/package.json').version;\\n        }\\n    }\\n    /**\\n     * Creates a gRPC credentials. It asks the auth data if necessary.\\n     * @private\\n     * @param {Object} opts - options values for configuring credentials.\\n     * @param {Object=} opts.sslCreds - when specified, this is used instead\\n     *   of default channel credentials.\\n     * @return {Promise} The promise which will be resolved to the gRPC credential.\\n     */\\n    async _getCredentials(opts) {\\n        if (opts.sslCreds) {\\n            return opts.sslCreds;\\n        }\\n        const grpc = this.grpc;\\n        const sslCreds = opts.cert \u0026\u0026 opts.key\\n            ? grpc.credentials.createSsl(null, Buffer.from(opts.key), Buffer.from(opts.cert))\\n            : grpc.credentials.createSsl();\\n        const client = await this.auth.getClient();\\n        const credentials = grpc.credentials.combineChannelCredentials(sslCreds, grpc.credentials.createFromGoogleCredential(client));\\n        return credentials;\\n    }\\n    static defaultOptions() {\\n        // This set of @grpc/proto-loader options\\n        // 'closely approximates the existing behavior of grpc.load'\\n        const includeDirs = INCLUDE_DIRS.slice();\\n        const options = {\\n            keepCase: false,\\n            longs: String,\\n            enums: String,\\n            defaults: true,\\n            oneofs: true,\\n            includeDirs,\\n        };\\n        return options;\\n    }\\n    /**\\n     * Loads the gRPC service from the proto file(s) at the given path and with the\\n     * given options. Caches the loaded protos so the subsequent loads don't do\\n     * any disk reads.\\n     * @param filename The path to the proto file(s).\\n     * @param options Options for loading the proto file.\\n     * @param ignoreCache Defaults to `false`. Set it to `true` if the caching logic\\n     *   incorrectly decides that the options object is the same, or if you want to\\n     *   re-read the protos from disk for any other reason.\\n     */\\n    loadFromProto(filename, options, ignoreCache = false) {\\n        const cacheKey = GrpcClient.protoCacheKey(filename, options);\\n        let grpcPackage = cacheKey\\n            ? GrpcClient.protoCache.get(cacheKey)\\n            : undefined;\\n        if (ignoreCache || !grpcPackage) {\\n            const packageDef = grpcProtoLoader.loadSync(filename, options);\\n            grpcPackage = this.grpc.loadPackageDefinition(packageDef);\\n            if (cacheKey) {\\n                GrpcClient.protoCache.set(cacheKey, grpcPackage);\\n            }\\n        }\\n        return grpcPackage;\\n    }\\n    /**\\n     * Load gRPC proto service from a filename looking in googleapis common protos\\n     * when necessary. Caches the loaded protos so the subsequent loads don't do\\n     * any disk reads.\\n     * @param {String} protoPath - The directory to search for the protofile.\\n     * @param {String|String[]} filename - The filename(s) of the proto(s) to be loaded.\\n     *   If omitted, protoPath will be treated as a file path to load.\\n     * @param ignoreCache Defaults to `false`. Set it to `true` if the caching logic\\n     *   incorrectly decides that the options object is the same, or if you want to\\n     *   re-read the protos from disk for any other reason.\\n     * @return {Object\u003cstring, *\u003e} The gRPC loaded result (the toplevel namespace\\n     *   object).\\n     */\\n    loadProto(protoPath, filename, ignoreCache = false) {\\n        if (!filename) {\\n            filename = path.basename(protoPath);\\n            protoPath = path.dirname(protoPath);\\n        }\\n        if (Array.isArray(filename) \u0026\u0026 filename.length === 0) {\\n            return {};\\n        }\\n        const options = GrpcClient.defaultOptions();\\n        options.includeDirs.unshift(protoPath);\\n        return this.loadFromProto(filename, options, ignoreCache);\\n    }\\n    static _resolveFile(protoPath, filename) {\\n        if (fs.existsSync(path.join(protoPath, filename))) {\\n            return path.join(protoPath, filename);\\n        }\\n        else if (COMMON_PROTO_FILES.indexOf(filename) \u003e -1) {\\n            return path.join(googleProtoFilesDir, filename);\\n        }\\n        throw new Error(filename + ' could not be found in ' + protoPath);\\n    }\\n    loadProtoJSON(json, ignoreCache = false) {\\n        const hash = objectHash(JSON.stringify(json)).toString();\\n        const cached = GrpcClient.protoCache.get(hash);\\n        if (cached \u0026\u0026 !ignoreCache) {\\n            return cached;\\n        }\\n        const options = GrpcClient.defaultOptions();\\n        const packageDefinition = grpcProtoLoader.fromJSON(json, options);\\n        const grpcPackage = this.grpc.loadPackageDefinition(packageDefinition);\\n        GrpcClient.protoCache.set(hash, grpcPackage);\\n        return grpcPackage;\\n    }\\n    metadataBuilder(headers) {\\n        const Metadata = this.grpc.Metadata;\\n        const baseMetadata = new Metadata();\\n        for (const key in headers) {\\n            const value = headers[key];\\n            if (Array.isArray(value)) {\\n                value.forEach(v =\u003e baseMetadata.add(key, v));\\n            }\\n            else {\\n                baseMetadata.set(key, `${value}`);\\n            }\\n        }\\n        return function buildMetadata(abTests, moreHeaders) {\\n            // TODO: bring the A/B testing info into the metadata.\\n            let copied = false;\\n            let metadata = baseMetadata;\\n            if (moreHeaders) {\\n                for (const key in moreHeaders) {\\n                    if (key.toLowerCase() !== 'x-goog-api-client') {\\n                        if (!copied) {\\n                            copied = true;\\n                            metadata = metadata.clone();\\n                        }\\n                        const value = moreHeaders[key];\\n                        if (Array.isArray(value)) {\\n                            value.forEach(v =\u003e metadata.add(key, v));\\n                        }\\n                        else {\\n                            metadata.set(key, `${value}`);\\n                        }\\n                    }\\n                }\\n            }\\n            return metadata;\\n        };\\n    }\\n    /**\\n     * A wrapper of {@link constructSettings} function under the gRPC context.\\n     *\\n     * Most of parameters are common among constructSettings, please take a look.\\n     * @param {string} serviceName - The fullly-qualified name of the service.\\n     * @param {Object} clientConfig - A dictionary of the client config.\\n     * @param {Object} configOverrides - A dictionary of overriding configs.\\n     * @param {Object} headers - A dictionary of additional HTTP header name to\\n     *   its value.\\n     * @return {Object} A mapping of method names to CallSettings.\\n     */\\n    constructSettings(serviceName, clientConfig, configOverrides, headers) {\\n        return gax.constructSettings(serviceName, clientConfig, configOverrides, this.grpc.status, { metadataBuilder: this.metadataBuilder(headers) });\\n    }\\n    /**\\n     * Creates a gRPC stub with current gRPC and auth.\\n     * @param {function} CreateStub - The constructor function of the stub.\\n     * @param {Object} options - The optional arguments to customize\\n     *   gRPC connection. This options will be passed to the constructor of\\n     *   gRPC client too.\\n     * @param {string} options.servicePath - The name of the server of the service.\\n     * @param {number} options.port - The port of the service.\\n     * @param {grpcTypes.ClientCredentials=} options.sslCreds - The credentials to be used\\n     *   to set up gRPC connection.\\n     * @param {string} defaultServicePath - The default service path.\\n     * @return {Promise} A promise which resolves to a gRPC stub instance.\\n     */\\n    async createStub(CreateStub, options, customServicePath) {\\n        // The following options are understood by grpc-gcp and need a special treatment\\n        // (should be passed without a `grpc.` prefix)\\n        const grpcGcpOptions = [\\n            'grpc.callInvocationTransformer',\\n            'grpc.channelFactoryOverride',\\n            'grpc.gcpApiConfig',\\n        ];\\n        const [cert, key] = await this._detectClientCertificate(options, options.universeDomain);\\n        const servicePath = this._mtlsServicePath(options.servicePath, customServicePath, cert \u0026\u0026 key);\\n        const opts = Object.assign({}, options, { cert, key, servicePath });\\n        const serviceAddress = servicePath + ':' + opts.port;\\n        if (!options.universeDomain) {\\n            options.universeDomain = 'googleapis.com';\\n        }\\n        if (options.universeDomain) {\\n            const universeFromAuth = await this.auth.getUniverseDomain();\\n            if (universeFromAuth \u0026\u0026 options.universeDomain !== universeFromAuth) {\\n                throw new Error(`The configured universe domain (${options.universeDomain}) does not match the universe domain found in the credentials (${universeFromAuth}). ` +\\n                    \\\"If you haven't configured the universe domain explicitly, googleapis.com is the default.\\\");\\n            }\\n        }\\n        const creds = await this._getCredentials(opts);\\n        const grpcOptions = {};\\n        // @grpc/grpc-js limits max receive/send message length starting from v0.8.0\\n        // https://github.com/grpc/grpc-node/releases/tag/%40grpc%2Fgrpc-js%400.8.0\\n        // To keep the existing behavior and avoid libraries breakage, we pass -1 there as suggested.\\n        grpcOptions['grpc.max_receive_message_length'] = -1;\\n        grpcOptions['grpc.max_send_message_length'] = -1;\\n        grpcOptions['grpc.initial_reconnect_backoff_ms'] = 1000;\\n        Object.keys(opts).forEach(key =\u003e {\\n            const value = options[key];\\n            // the older versions had a bug which required users to call an option\\n            // grpc.grpc.* to make it actually pass to gRPC as grpc.*, let's handle\\n            // this here until the next major release\\n            if (key.startsWith('grpc.grpc.')) {\\n                key = key.replace(/^grpc\\\\./, '');\\n            }\\n            if (key.startsWith('grpc.')) {\\n                if (grpcGcpOptions.includes(key)) {\\n                    key = key.replace(/^grpc\\\\./, '');\\n                }\\n                grpcOptions[key] = value;\\n            }\\n            if (key.startsWith('grpc-node.')) {\\n                grpcOptions[key] = value;\\n            }\\n        });\\n        const stub = new CreateStub(serviceAddress, creds, grpcOptions);\\n        return stub;\\n    }\\n    /**\\n     * Detect mTLS client certificate based on logic described in\\n     * https://google.aip.dev/auth/4114.\\n     *\\n     * @param {object} [options] - The configuration object.\\n     * @returns {Promise} Resolves array of strings representing cert and key.\\n     */\\n    async _detectClientCertificate(opts, universeDomain) {\\n        var _a;\\n        const certRegex = /(?\u003ccert\u003e-----BEGIN CERTIFICATE-----.*?-----END CERTIFICATE-----)/s;\\n        const keyRegex = /(?\u003ckey\u003e-----BEGIN PRIVATE KEY-----.*?-----END PRIVATE KEY-----)/s;\\n        // If GOOGLE_API_USE_CLIENT_CERTIFICATE is true...:\\n        if (typeof process !== 'undefined' \u0026\u0026\\n            ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.GOOGLE_API_USE_CLIENT_CERTIFICATE) === 'true') {\\n            if (universeDomain \u0026\u0026 universeDomain !== 'googleapis.com') {\\n                throw new Error('mTLS is not supported outside of googleapis.com universe domain.');\\n            }\\n            if ((opts === null || opts === void 0 ? void 0 : opts.cert) \u0026\u0026 (opts === null || opts === void 0 ? void 0 : opts.key)) {\\n                return [opts.cert, opts.key];\\n            }\\n            // If context aware metadata exists, run the cert provider command,\\n            // parse the output to extract cert and key, and use this cert/key.\\n            const metadataPath = (0, path_1.join)(os.homedir(), '.secureConnect', 'context_aware_metadata.json');\\n            const metadata = JSON.parse(await readFileAsync(metadataPath));\\n            if (!metadata.cert_provider_command) {\\n                throw Error('no cert_provider_command found');\\n            }\\n            const stdout = await execFileAsync(metadata.cert_provider_command[0], metadata.cert_provider_command.slice(1));\\n            const matchCert = stdout.toString().match(certRegex);\\n            const matchKey = stdout.toString().match(keyRegex);\\n            if (!((matchCert === null || matchCert === void 0 ? void 0 : matchCert.groups) \u0026\u0026 (matchKey === null || matchKey === void 0 ? void 0 : matchKey.groups))) {\\n                throw Error('unable to parse certificate and key');\\n            }\\n            else {\\n                return [matchCert.groups.cert, matchKey.groups.key];\\n            }\\n        }\\n        // If GOOGLE_API_USE_CLIENT_CERTIFICATE is not set or false,\\n        // use no cert or key:\\n        return [undefined, undefined];\\n    }\\n    /**\\n     * Return service path, taking into account mTLS logic.\\n     * See: https://google.aip.dev/auth/4114\\n     *\\n     * @param {string|undefined} servicePath - The path of the service.\\n     * @param {string|undefined} customServicePath - Did the user provide a custom service URL.\\n     * @param {boolean} hasCertificate - Was a certificate found.\\n     * @returns {string} The DNS address for this service.\\n     */\\n    _mtlsServicePath(servicePath, customServicePath, hasCertificate) {\\n        var _a, _b;\\n        // If user provides a custom service path, return the current service\\n        // path and do not attempt to add mtls subdomain:\\n        if (customServicePath || !servicePath)\\n            return servicePath;\\n        if (typeof process !== 'undefined' \u0026\u0026\\n            ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.GOOGLE_API_USE_MTLS_ENDPOINT) === 'never') {\\n            // It was explicitly asked that mtls endpoint not be used:\\n            return servicePath;\\n        }\\n        else if ((typeof process !== 'undefined' \u0026\u0026\\n            ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.GOOGLE_API_USE_MTLS_ENDPOINT) === 'always') ||\\n            hasCertificate) {\\n            // Either auto-detect or explicit setting of endpoint:\\n            return servicePath.replace('googleapis.com', 'mtls.googleapis.com');\\n        }\\n        return servicePath;\\n    }\\n    /**\\n     * Creates a 'bytelength' function for a given proto message class.\\n     *\\n     * See {@link BundleDescriptor} about the meaning of the return value.\\n     *\\n     * @param {function} message - a constructor function that is generated by\\n     *   protobuf.js. Assumes 'encoder' field in the message.\\n     * @return {function(Object):number} - a function to compute the byte length\\n     *   for an object.\\n     */\\n    static createByteLengthFunction(message) {\\n        return gax.createByteLengthFunction(message);\\n    }\\n},\\\"name\\\",{value:\\\"GrpcClient\\\"})\"\n"])</script><script>self.__next_f.push([1,"d2:\"$EObject.defineProperty(class Operation extends events_1.EventEmitter {\\n    /**\\n     * Wrapper for a google.longrunnung.Operation.\\n     *\\n     * @constructor\\n     *\\n     * @param {google.longrunning.Operation} grpcOp - The operation to be wrapped.\\n     * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\\n     * operations service client and unpacking mechanisms for the operation.\\n     * @param {BackoffSettings} backoffSettings - The backoff settings used in\\n     * in polling the operation.\\n     * @param {CallOptions} callOptions - CallOptions used in making get operation\\n     * requests.\\n     */\\n    constructor(grpcOp, longrunningDescriptor, backoffSettings, callOptions) {\\n        super();\\n        this.completeListeners = 0;\\n        this.hasActiveListeners = false;\\n        this.latestResponse = grpcOp;\\n        this.name = this.latestResponse.name;\\n        this.done = this.latestResponse.done;\\n        this.error = this.latestResponse.error;\\n        this.longrunningDescriptor = longrunningDescriptor;\\n        this.result = null;\\n        this.metadata = null;\\n        this.backoffSettings = backoffSettings;\\n        this._unpackResponse(grpcOp);\\n        this._listenForEvents();\\n        this._callOptions = callOptions;\\n    }\\n    /**\\n     * Begin listening for events on the operation. This method keeps track of how\\n     * many \\\"complete\\\" listeners are registered and removed, making sure polling\\n     * is handled automatically.\\n     *\\n     * As long as there is one active \\\"complete\\\" listener, the connection is open.\\n     * When there are no more listeners, the polling stops.\\n     *\\n     * @private\\n     */\\n    _listenForEvents() {\\n        this.on('newListener', event =\u003e {\\n            if (event === 'complete') {\\n                this.completeListeners++;\\n                if (!this.hasActiveListeners) {\\n                    this.hasActiveListeners = true;\\n                    this.startPolling_();\\n                }\\n            }\\n        });\\n        this.on('removeListener', event =\u003e {\\n            if (event === 'complete' \u0026\u0026 --this.completeListeners === 0) {\\n                this.hasActiveListeners = false;\\n            }\\n        });\\n    }\\n    /**\\n     * Cancels current polling api call and cancels the operation.\\n     *\\n     * @return {Promise} the promise of the OperationsClient#cancelOperation api\\n     * request.\\n     */\\n    cancel() {\\n        if (this.currentCallPromise_) {\\n            this.currentCallPromise_.cancel();\\n        }\\n        const operationsClient = this.longrunningDescriptor.operationsClient;\\n        const cancelRequest = new operationProtos.google.longrunning.CancelOperationRequest();\\n        cancelRequest.name = this.latestResponse.name;\\n        return operationsClient.cancelOperation(cancelRequest);\\n    }\\n    getOperation(callback) {\\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\\n        const self = this;\\n        const operationsClient = this.longrunningDescriptor.operationsClient;\\n        function promisifyResponse() {\\n            if (!callback) {\\n                return new Promise((resolve, reject) =\u003e {\\n                    if (self.latestResponse.error) {\\n                        const error = new googleError_1.GoogleError(self.latestResponse.error.message);\\n                        error.code = self.latestResponse.error.code;\\n                        reject(error);\\n                    }\\n                    else {\\n                        resolve([self.result, self.metadata, self.latestResponse]);\\n                    }\\n                });\\n            }\\n            return;\\n        }\\n        if (this.latestResponse.done) {\\n            this._unpackResponse(this.latestResponse, callback);\\n            return promisifyResponse();\\n        }\\n        const request = new operationProtos.google.longrunning.GetOperationRequest();\\n        request.name = this.latestResponse.name;\\n        this.currentCallPromise_ = operationsClient.getOperationInternal(request, this._callOptions);\\n        const noCallbackPromise = this.currentCallPromise_.then(responses =\u003e {\\n            self.latestResponse = responses[0];\\n            self._unpackResponse(responses[0], callback);\\n            return promisifyResponse();\\n        }, (err) =\u003e {\\n            if (callback) {\\n                callback(err);\\n                return;\\n            }\\n            return Promise.reject(err);\\n        });\\n        if (!callback) {\\n            return noCallbackPromise;\\n        }\\n    }\\n    _unpackResponse(op, callback) {\\n        const responseDecoder = this.longrunningDescriptor.responseDecoder;\\n        const metadataDecoder = this.longrunningDescriptor.metadataDecoder;\\n        let response;\\n        let metadata;\\n        if (op.done) {\\n            if (op.result === 'error') {\\n                const error = new googleError_1.GoogleError(op.error.message);\\n                error.code = op.error.code;\\n                this.error = error;\\n                if (callback) {\\n                    callback(error);\\n                }\\n                return;\\n            }\\n            if (responseDecoder \u0026\u0026 op.response) {\\n                this.response = op.response;\\n                response = responseDecoder(op.response.value);\\n                this.result = response;\\n                this.done = true;\\n            }\\n        }\\n        if (metadataDecoder \u0026\u0026 op.metadata) {\\n            metadata = metadataDecoder(op.metadata.value);\\n            this.metadata = metadata;\\n        }\\n        if (callback) {\\n            callback(null, response, metadata, op);\\n        }\\n    }\\n    /**\\n     * Poll `getOperation` to check the operation's status. This runs a loop to\\n     * ping using the backoff strategy specified at initialization.\\n     *\\n     * Note: This method is automatically called once a \\\"complete\\\" event handler\\n     * is registered on the operation.\\n     *\\n     * @private\\n     */\\n    startPolling_() {\\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\\n        const self = this;\\n        let now = new Date();\\n        const delayMult = this.backoffSettings.retryDelayMultiplier;\\n        const maxDelay = this.backoffSettings.maxRetryDelayMillis;\\n        let delay = this.backoffSettings.initialRetryDelayMillis;\\n        let deadline = Infinity;\\n        if (this.backoffSettings.totalTimeoutMillis) {\\n            deadline = now.getTime() + this.backoffSettings.totalTimeoutMillis;\\n        }\\n        let previousMetadataBytes;\\n        if (this.latestResponse.metadata) {\\n            previousMetadataBytes = this.latestResponse.metadata.value;\\n        }\\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n        function emit(event, ...args) {\\n            self.emit(event, ...args);\\n        }\\n        // Helper function to replace nodejs buffer's equals()\\n        function arrayEquals(a, b) {\\n            if (a.byteLength !== b.byteLength) {\\n                return false;\\n            }\\n            for (let i = 0; i \u003c a.byteLength; ++i) {\\n                if (a[i] !== b[i])\\n                    return false;\\n            }\\n            return true;\\n        }\\n        function retry() {\\n            if (!self.hasActiveListeners) {\\n                return;\\n            }\\n            if (now.getTime() \u003e= deadline) {\\n                const error = new googleError_1.GoogleError('Total timeout exceeded before any response was received');\\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\\n                setImmediate(emit, 'error', error);\\n                return;\\n            }\\n            self.getOperation((err, result, metadata, rawResponse) =\u003e {\\n                if (err) {\\n                    setImmediate(emit, 'error', err);\\n                    return;\\n                }\\n                if (!result) {\\n                    if (rawResponse.metadata \u0026\u0026\\n                        (!previousMetadataBytes ||\\n                            (rawResponse \u0026\u0026\\n                                !arrayEquals(rawResponse.metadata.value, previousMetadataBytes)))) {\\n                        setImmediate(emit, 'progress', metadata, rawResponse);\\n                        previousMetadataBytes = rawResponse.metadata.value;\\n                    }\\n                    // special case: some APIs fail to set either result or error\\n                    // but set done = true (e.g. speech with silent file).\\n                    // Some APIs just use this for the normal completion\\n                    // (e.g. nodejs-contact-center-insights), so let's just return\\n                    // an empty response in this case.\\n                    if (rawResponse.done) {\\n                        setImmediate(emit, 'complete', {}, metadata, rawResponse);\\n                        return;\\n                    }\\n                    setTimeout(() =\u003e {\\n                        now = new Date();\\n                        delay = Math.min(delay * delayMult, maxDelay);\\n                        retry();\\n                    }, delay);\\n                    return;\\n                }\\n                setImmediate(emit, 'complete', result, metadata, rawResponse);\\n            });\\n        }\\n        retry();\\n    }\\n    /**\\n     * Wraps the `complete` and `error` events in a Promise.\\n     *\\n     * @return {promise} - Promise that resolves on operation completion and rejects\\n     * on operation error.\\n     */\\n    promise() {\\n        return new Promise((resolve, reject) =\u003e {\\n            this.on('error', reject).on('complete', (result, metadata, rawResponse) =\u003e {\\n                resolve([result, metadata, rawResponse]);\\n            });\\n        });\\n    }\\n},\\\"name\\\",{value:\\\"Operation\\\"})\"\n"])</script><script>self.__next_f.push([1,"d3:\"$EObject.defineProperty(function operation(op, longrunningDescriptor, backoffSettings, callOptions) {\\n    return new Operation(op, longrunningDescriptor, backoffSettings, callOptions);\\n},\\\"name\\\",{value:\\\"operation\\\"})\"\n"])</script><script>self.__next_f.push([1,"d4:\"$EObject.defineProperty(class PathTemplate {\\n    /**\\n     * @param {String} data the of the template\\n     *\\n     * @constructor\\n     */\\n    constructor(data) {\\n        this.bindings = {};\\n        this.data = data;\\n        this.segments = this.parsePathTemplate(data);\\n        this.size = this.segments.length;\\n    }\\n    /**\\n     * Matches a fully-qualified path template string.\\n     *\\n     * @param {String} path a fully-qualified path template string\\n     * @return {Object} contains const names matched to binding values\\n     * @throws {TypeError} if path can't be matched to this template\\n     */\\n    match(path) {\\n        let pathSegments = path.split('/');\\n        const bindings = {};\\n        if (pathSegments.length !== this.segments.length) {\\n            // if the path contains a wildcard, then the length may differ by 1.\\n            if (!this.data.includes('**')) {\\n                throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same.`);\\n            }\\n            else if (pathSegments.length !== this.segments.length + 1) {\\n                throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same with one wildcard.`);\\n            }\\n        }\\n        for (let index = 0; index \u003c this.segments.length \u0026\u0026 pathSegments.length \u003e 0; index++) {\\n            if (this.segments[index] !== pathSegments[0]) {\\n                if (!this.segments[index].includes('*')) {\\n                    throw new TypeError(`segment does not match, ${this.segments[index]} and  ${pathSegments[index]}.`);\\n                }\\n                else {\\n                    let segment = this.segments[index];\\n                    const matches = segment.match(/\\\\{[$0-9a-zA-Z_]+=.*?\\\\}/g);\\n                    if (!matches) {\\n                        throw new Error(`Error processing path template segment ${segment}`);\\n                    }\\n                    const variables = matches.map(str =\u003e str.replace(/^\\\\{/, '').replace(/=.*/, ''));\\n                    if (segment.includes('**')) {\\n                        bindings[variables[0]] = pathSegments[0] + '/' + pathSegments[1];\\n                        pathSegments = pathSegments.slice(2);\\n                    }\\n                    else {\\n                        // atomic resource\\n                        if (variables.length === 1) {\\n                            bindings[variables[0]] = pathSegments[0];\\n                        }\\n                        else {\\n                            // non-slash resource\\n                            // segment: {blurb_id=*}.{legacy_user=*} to match pathSegments: ['bar.user2']\\n                            // split the match pathSegments[0] -\u003e value: ['bar', 'user2']\\n                            // compare the length of two arrays, and compare array items\\n                            const value = pathSegments[0].split(/[-_.~]/);\\n                            if (value.length !== variables.length) {\\n                                throw new Error(`segment ${segment} does not match ${pathSegments[0]}`);\\n                            }\\n                            for (const v of variables) {\\n                                bindings[v] = value[0];\\n                                segment = segment.replace(`{${v}=*}`, `${value[0]}`);\\n                                value.shift();\\n                            }\\n                            // segment: {blurb_id=*}.{legacy_user=*} matching pathSegments: ['bar~user2'] should fail\\n                            if (segment !== pathSegments[0]) {\\n                                throw new TypeError(`non slash resource pattern ${this.segments[index]} and ${pathSegments[0]} should have same separator`);\\n                            }\\n                        }\\n                        pathSegments.shift();\\n                    }\\n                }\\n            }\\n            else {\\n                pathSegments.shift();\\n            }\\n        }\\n        return bindings;\\n    }\\n    /**\\n     * Renders a path template using the provided bindings.\\n     *\\n     * @param {Object} bindings a mapping of const names to binding strings\\n     * @return {String} a rendered representation of the path template\\n     * @throws {TypeError} if a key is missing, or if a sub-template cannot be\\n     *   parsed\\n     */\\n    render(bindings) {\\n        if (Object.keys(bindings).length !== Object.keys(this.bindings).length) {\\n            throw new TypeError(`The number of variables ${Object.keys(bindings).length} does not match the number of needed variables ${Object.keys(this.bindings).length}`);\\n        }\\n        let path = this.inspect();\\n        for (const key of Object.keys(bindings)) {\\n            const b = bindings[key].toString();\\n            if (!this.bindings[key]) {\\n                throw new TypeError(`render fails for not matching ${bindings[key]}`);\\n            }\\n            const variable = this.bindings[key];\\n            if (variable === '*') {\\n                if (!b.match(/[^/{}]+/)) {\\n                    throw new TypeError(`render fails for not matching ${b}`);\\n                }\\n                path = path.replace(`{${key}=*}`, `${b}`);\\n            }\\n            else if (variable === '**') {\\n                if (!b.match(/[^{}]+/)) {\\n                    throw new TypeError(`render fails for not matching ${b}`);\\n                }\\n                path = path.replace(`{${key}=**}`, `${b}`);\\n            }\\n        }\\n        return path;\\n    }\\n    /**\\n     * Renders the path template.\\n     *\\n     * @return {string} contains const names matched to binding values\\n     */\\n    inspect() {\\n        return this.segments.join('/');\\n    }\\n    /**\\n     * Parse the path template.\\n     *\\n     * @return {string[]} return segments of the input path.\\n     * For example: 'buckets/{hello}'' will give back ['buckets', {hello=*}]\\n     */\\n    parsePathTemplate(data) {\\n        const pathSegments = splitPathTemplate(data);\\n        let index = 0;\\n        let wildCardCount = 0;\\n        const segments = [];\\n        let matches;\\n        pathSegments.forEach(segment =\u003e {\\n            // * or ** -\u003e segments.push('{$0=*}');\\n            //         -\u003e bindings['$0'] = '*'\\n            if (segment === '*' || segment === '**') {\\n                this.bindings[`$${index}`] = segment;\\n                segments.push(`{$${index}=${segment}}`);\\n                index = index + 1;\\n                if (segment === '**') {\\n                    ++wildCardCount;\\n                }\\n            }\\n            else if ((matches = segment.match(/\\\\{[0-9a-zA-Z-.~_]+(?:=.*?)?\\\\}/g))) {\\n                for (const subsegment of matches) {\\n                    const pairMatch = subsegment.match(/^\\\\{([0-9a-zA-Z-.~_]+)(?:=(.*?))?\\\\}$/);\\n                    if (!pairMatch) {\\n                        throw new Error(`Cannot process path template segment ${subsegment}`);\\n                    }\\n                    const key = pairMatch[1];\\n                    let value = pairMatch[2];\\n                    if (!value) {\\n                        value = '*';\\n                        segment = segment.replace(key, key + '=*');\\n                        this.bindings[key] = value;\\n                    }\\n                    else if (value === '*') {\\n                        this.bindings[key] = value;\\n                    }\\n                    else if (value === '**') {\\n                        ++wildCardCount;\\n                        this.bindings[key] = value;\\n                    }\\n                }\\n                segments.push(segment);\\n            }\\n            else if (segment.match(/[0-9a-zA-Z-.~_]+/)) {\\n                segments.push(segment);\\n            }\\n        });\\n        if (wildCardCount \u003e 1) {\\n            throw new TypeError('Can not have more than one wildcard.');\\n        }\\n        return segments;\\n    }\\n},\\\"name\\\",{value:\\\"PathTemplate\\\"})\"\n"])</script><script>self.__next_f.push([1,"d5:\"$EObject.defineProperty(class OperationsClient {\\n    constructor(gaxGrpc, \\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    operationsProtos, options) {\\n        const opts = Object.assign({\\n            servicePath: exports.SERVICE_ADDRESS,\\n            port: DEFAULT_SERVICE_PORT,\\n            clientConfig: {},\\n        }, options);\\n        const googleApiClient = ['gl-node/' + process.versions.node];\\n        if (opts.libName \u0026\u0026 opts.libVersion) {\\n            googleApiClient.push(opts.libName + '/' + opts.libVersion);\\n        }\\n        googleApiClient.push(CODE_GEN_NAME_VERSION, 'gax/' + version);\\n        if (opts.fallback) {\\n            googleApiClient.push('gl-web/' + version);\\n        }\\n        else {\\n            googleApiClient.push('grpc/' + gaxGrpc.grpcVersion);\\n        }\\n        const defaults = gaxGrpc.constructSettings('google.longrunning.Operations', configData, opts.clientConfig || {}, { 'x-goog-api-client': googleApiClient.join(' ') });\\n        this.auth = gaxGrpc.auth;\\n        // Set up a dictionary of \\\"inner API calls\\\"; the core implementation\\n        // of calling the API is handled in `google-gax`, with this code\\n        // merely providing the destination and request information.\\n        this.innerApiCalls = {};\\n        this.descriptor = {\\n            listOperations: new descriptor_1.PageDescriptor('pageToken', 'nextPageToken', 'operations'),\\n        };\\n        // Put together the \\\"service stub\\\" for\\n        // google.longrunning.Operations.\\n        this.operationsStub = gaxGrpc.createStub(opts.fallback\\n            ? operationsProtos.lookupService('google.longrunning.Operations')\\n            : operationsProtos.google.longrunning.Operations, opts);\\n        const operationsStubMethods = [\\n            'getOperation',\\n            'listOperations',\\n            'cancelOperation',\\n            'deleteOperation',\\n        ];\\n        for (const methodName of operationsStubMethods) {\\n            const innerCallPromise = this.operationsStub.then(stub =\u003e (...args) =\u003e {\\n                const func = stub[methodName];\\n                return func.apply(stub, args);\\n            }, err =\u003e () =\u003e {\\n                throw err;\\n            });\\n            this.innerApiCalls[methodName] = (0, createApiCall_1.createApiCall)(innerCallPromise, defaults[methodName], this.descriptor[methodName]);\\n        }\\n    }\\n    /** Closes this operations client. */\\n    close() {\\n        this.operationsStub.then(stub =\u003e stub.close());\\n    }\\n    getProjectId(callback) {\\n        if (this.auth \u0026\u0026 'getProjectId' in this.auth) {\\n            return this.auth.getProjectId(callback);\\n        }\\n        if (callback) {\\n            callback(new Error('Cannot determine project ID.'));\\n        }\\n        else {\\n            return Promise.reject('Cannot determine project ID.');\\n        }\\n    }\\n    // Service calls\\n    getOperationInternal(request, options, callback) {\\n        request = request || {};\\n        options = options || {};\\n        return this.innerApiCalls.getOperation(request, options, callback);\\n    }\\n    /**\\n     * Gets the latest state of a long-running operation.  Clients can use this\\n     * method to poll the operation result at intervals as recommended by the API\\n     * service.\\n     *\\n     * @param {Object} request - The request object that will be sent.\\n     * @param {string} request.name - The name of the operation resource.\\n     * @param {Object=} options\\n     *   Optional parameters. You can override the default settings for this call,\\n     *   e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\\n     *   https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\\n     *   details.\\n     * @param {function(?Error, ?Object)=} callback\\n     *   The function which will be called with the result of the API call.\\n     *\\n     *   The second parameter to the callback is an object representing\\n     * [google.longrunning.Operation]{@link\\n     * external:\\\"google.longrunning.Operation\\\"}.\\n     * @return {Promise} - The promise which resolves to an array.\\n     *   The first element of the array is an object representing\\n     * [google.longrunning.Operation]{@link\\n     * external:\\\"google.longrunning.Operation\\\"}. The promise has a method named\\n     * \\\"cancel\\\" which cancels the ongoing API call.\\n     *\\n     * @example\\n     *\\n     * const client = longrunning.operationsClient();\\n     * const name = '';\\n     * const [response] = await client.getOperation({name});\\n     * // doThingsWith(response)\\n     */\\n    getOperation(request, optionsOrCallback, callback) {\\n        let options;\\n        if (optionsOrCallback instanceof Function \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        request = request || {};\\n        options = options || {};\\n        return this.innerApiCalls.getOperation(request, options, callback);\\n    }\\n    /**\\n     * Lists operations that match the specified filter in the request. If the\\n     * server doesn't support this method, it returns `UNIMPLEMENTED`.\\n     *\\n     * NOTE: the `name` binding below allows API services to override the binding\\n     * to use different resource name schemes.\\n     *\\n     * @param {Object} request - The request object that will be sent.\\n     * @param {string} request.name - The name of the operation collection.\\n     * @param {string} request.filter - The standard list filter.\\n     * @param {number=} request.pageSize\\n     *   The maximum number of resources contained in the underlying API\\n     *   response. If page streaming is performed per-resource, this\\n     *   parameter does not affect the return value. If page streaming is\\n     *   performed per-page, this determines the maximum number of\\n     *   resources in a page.\\n     * @param {Object=} options\\n     *   Optional parameters. You can override the default settings for this call,\\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\\n     * details.\\n     * @param {function(?Error, ?Array, ?Object, ?Object)=} callback\\n     *   The function which will be called with the result of the API call.\\n     *\\n     *   The second parameter to the callback is Array of\\n     * [google.longrunning.Operation]{@link\\n     * external:\\\"google.longrunning.Operation\\\"}.\\n     *\\n     *   When autoPaginate: false is specified through options, it contains the\\n     * result in a single response. If the response indicates the next page\\n     * exists, the third parameter is set to be used for the next request object.\\n     * The fourth parameter keeps the raw response object of an object\\n     * representing [google.longrunning.ListOperationsResponse]{@link\\n     * external:\\\"google.longrunning.ListOperationsResponse\\\"}.\\n     * @return {Promise} - The promise which resolves to an array.\\n     *   The first element of the array is Array of\\n     * [google.longrunning.Operation]{@link\\n     * external:\\\"google.longrunning.Operation\\\"}.\\n     *\\n     *   When autoPaginate: false is specified through options, the array has\\n     * three elements. The first element is Array of\\n     * [google.longrunning.Operation]{@link\\n     * external:\\\"google.longrunning.Operation\\\"} in a single response. The second\\n     * element is the next request object if the response indicates the next page\\n     * exists, or null. The third element is an object representing\\n     * [google.longrunning.ListOperationsResponse]{@link\\n     * external:\\\"google.longrunning.ListOperationsResponse\\\"}.\\n     *\\n     *   The promise has a method named \\\"cancel\\\" which cancels the ongoing API\\n     * call.\\n     *\\n     * @example\\n     *\\n     * const client = longrunning.operationsClient();\\n     * const request = {\\n     *     name: '',\\n     *     filter: ''\\n     * };\\n     * // Iterate over all elements.\\n     * const [resources] = await client.listOperations(request);\\n     * for (const resource of resources) {\\n     *   console.log(resources);\\n     * }\\n     *\\n     * // Or obtain the paged response.\\n     * const options = {autoPaginate: false};\\n     * let nextRequest = request;\\n     * while(nextRequest) {\\n     *   const response = await client.listOperations(nextRequest, options);\\n     *   const resources = response[0];\\n     *   nextRequest = response[1];\\n     *   const rawResponse = response[2];\\n     *   for (const resource of resources) {\\n     *     // doThingsWith(resource);\\n     *   }\\n     * };\\n     */\\n    listOperations(request, optionsOrCallback, callback) {\\n        let options;\\n        if (optionsOrCallback instanceof Function \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        request = request || {};\\n        options = options || {};\\n        return this.innerApiCalls.listOperations(request, options, callback);\\n    }\\n    /**\\n     * Equivalent to {@link listOperations}, but returns a NodeJS Stream object.\\n     *\\n     * This fetches the paged responses for {@link listOperations} continuously\\n     * and invokes the callback registered for 'data' event for each element in\\n     * the responses.\\n     *\\n     * The returned object has 'end' method when no more elements are required.\\n     *\\n     * autoPaginate option will be ignored.\\n     *\\n     * @see {@link https://nodejs.org/api/stream.html}\\n     *\\n     * @param {Object} request - The request object that will be sent.\\n     * @param {string} request.name - The name of the operation collection.\\n     * @param {string} request.filter - The standard list filter.\\n     * @param {number=} request.pageSize -\\n     *   The maximum number of resources contained in the underlying API\\n     *   response. If page streaming is performed per-resource, this\\n     *   parameter does not affect the return value. If page streaming is\\n     *   performed per-page, this determines the maximum number of\\n     *   resources in a page.\\n     * @param {Object=} options\\n     *   Optional parameters. You can override the default settings for this call,\\n     *   e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\\n     *   https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\\n     *   details.\\n     * @return {Stream} - An object stream which emits an object representing [google.longrunning.Operation]{@link external:\\\"google.longrunning.Operation\\\"} on 'data' event.\\n     *\\n     * @example\\n     *\\n     * const client = longrunning.operationsClient();\\n     * const request = {\\n     *   name: '',\\n     *   filter: ''\\n     * };\\n     * client.listOperationsStream(request)\\n     *   .on('data', element =\u003e {\\n     *     // doThingsWith(element)\\n     *   })\\n     *   .on('error', err =\u003e {\\n     *     console.error(err);\\n     *   });\\n     */\\n    listOperationsStream(request, options) {\\n        const callSettings = new gax.CallSettings(options);\\n        return this.descriptor.listOperations.createStream(this.innerApiCalls.listOperations, request, callSettings);\\n    }\\n    /**\\n     * Equivalent to {@link listOperations}, but returns an iterable object.\\n     *\\n     * for-await-of syntax is used with the iterable to recursively get response element on-demand.\\n     *\\n     * @param {Object} request - The request object that will be sent.\\n     * @param {string} request.name - The name of the operation collection.\\n     * @param {string} request.filter - The standard list filter.\\n     * @param {number=} request.pageSize -\\n     *   The maximum number of resources contained in the underlying API\\n     *   response. If page streaming is performed per-resource, this\\n     *   parameter does not affect the return value. If page streaming is\\n     *   performed per-page, this determines the maximum number of\\n     *   resources in a page.\\n     * @param {Object=} options\\n     *   Optional parameters. You can override the default settings for this call,\\n     *   e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\\n     *   https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\\n     *   details.\\n     * @returns {Object}\\n     *   An iterable Object that conforms to @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols.\\n     */\\n    listOperationsAsync(request, options) {\\n        request = request || {};\\n        options = options || {};\\n        const callSettings = new gax.CallSettings(options);\\n        return this.descriptor.listOperations.asyncIterate(this.innerApiCalls.listOperations, request, callSettings);\\n    }\\n    /**\\n     * Starts asynchronous cancellation on a long-running operation.  The server\\n     * makes a best effort to cancel the operation, but success is not\\n     * guaranteed.  If the server doesn't support this method, it returns\\n     * `google.rpc.Code.UNIMPLEMENTED`.  Clients can use\\n     * {@link Operations.GetOperation} or\\n     * other methods to check whether the cancellation succeeded or whether the\\n     * operation completed despite cancellation. On successful cancellation,\\n     * the operation is not deleted; instead, it becomes an operation with\\n     * an {@link Operation.error} value with a {@link google.rpc.Status.code} of\\n     * 1, corresponding to `Code.CANCELLED`.\\n     *\\n     * @param {Object} request - The request object that will be sent.\\n     * @param {string} request.name - The name of the operation resource to be cancelled.\\n     * @param {Object=} options\\n     *   Optional parameters. You can override the default settings for this call,\\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\\n     * details.\\n     * @param {function(?Error)=} callback\\n     *   The function which will be called with the result of the API call.\\n     * @return {Promise} - The promise which resolves when API call finishes.\\n     *   The promise has a method named \\\"cancel\\\" which cancels the ongoing API\\n     * call.\\n     *\\n     * @example\\n     *\\n     * const client = longrunning.operationsClient();\\n     * await client.cancelOperation({name: ''});\\n     */\\n    cancelOperation(request, optionsOrCallback, callback) {\\n        let options;\\n        if (optionsOrCallback instanceof Function \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        request = request || {};\\n        options = options || {};\\n        return this.innerApiCalls.cancelOperation(request, options, callback);\\n    }\\n    /**\\n     * Deletes a long-running operation. This method indicates that the client is\\n     * no longer interested in the operation result. It does not cancel the\\n     * operation. If the server doesn't support this method, it returns\\n     * `google.rpc.Code.UNIMPLEMENTED`.\\n     *\\n     * @param {Object} request - The request object that will be sent.\\n     * @param {string} request.name - The name of the operation resource to be deleted.\\n     * @param {Object=} options\\n     *   Optional parameters. You can override the default settings for this call,\\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\\n     * details.\\n     * @param {function(?Error)=} callback\\n     *   The function which will be called with the result of the API call.\\n     * @return {Promise} - The promise which resolves when API call finishes.\\n     *   The promise has a method named \\\"cancel\\\" which cancels the ongoing API\\n     * call.\\n     *\\n     * @example\\n     *\\n     * const client = longrunning.operationsClient();\\n     * await client.deleteOperation({name: ''});\\n     */\\n    deleteOperation(request, optionsOrCallback, callback) {\\n        let options;\\n        if (optionsOrCallback instanceof Function \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        request = request || {};\\n        options = options || {};\\n        return this.innerApiCalls.deleteOperation(request, options, callback);\\n    }\\n},\\\"name\\\",{value:\\\"OperationsClient\\\"})\"\n"])</script><script>self.__next_f.push([1,"d6:\"$EObject.defineProperty(class IamClient {\\n    constructor(gaxGrpc, \\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    options) {\\n        this._terminated = false;\\n        this.descriptors = { page: {}, stream: {}, longrunning: {} };\\n        this.innerApiCalls = {};\\n        this.gaxGrpc = gaxGrpc;\\n        // Ensure that options include the service address and port.\\n        const opts = Object.assign({\\n            servicePath: options.servicePath,\\n            port: options.port,\\n            clientConfig: options.clientConfig,\\n            apiEndpoint: options.apiEndpoint,\\n            fallback: options.fallback,\\n        }, options);\\n        version = opts.fallback ? fallback.version : version;\\n        opts.scopes = this.constructor.scopes;\\n        // Save options to use in initialize() method.\\n        this._opts = opts;\\n        // Save the auth object to the client, for use by other methods.\\n        this.auth = gaxGrpc.auth;\\n        // Determine the client header string.\\n        const clientHeader = [`gax/${version}`, `gapic/${version}`];\\n        if (typeof process !== 'undefined' \u0026\u0026 'versions' in process) {\\n            clientHeader.push(`gl-node/${process.versions.node}`);\\n        }\\n        else {\\n            clientHeader.push(`gl-web/${version}`);\\n        }\\n        if (!opts.fallback) {\\n            clientHeader.push(`grpc/${gaxGrpc.grpcVersion}`);\\n        }\\n        if (opts.libName \u0026\u0026 opts.libVersion) {\\n            clientHeader.push(`${opts.libName}/${opts.libVersion}`);\\n        }\\n        // Load the applicable protos.\\n        this._protos = this.gaxGrpc.loadProtoJSON(jsonProtos);\\n        // Put together the default options sent with requests.\\n        this._defaults = gaxGrpc.constructSettings('google.iam.v1.IAMPolicy', gapicConfig, opts.clientConfig || {}, { 'x-goog-api-client': clientHeader.join(' ') });\\n        this.innerApiCalls = {};\\n    }\\n    /**\\n     * Initialize the client.\\n     * Performs asynchronous operations (such as authentication) and prepares the client.\\n     * This function will be called automatically when any class method is called for the\\n     * first time, but if you need to initialize it before calling an actual method,\\n     * feel free to call initialize() directly.\\n     *\\n     * You can await on this method if you want to make sure the client is initialized.\\n     *\\n     * @returns {Promise} A promise that resolves to an authenticated service stub.\\n     */\\n    initialize() {\\n        // If the client stub promise is already initialized, return immediately.\\n        if (this.iamPolicyStub) {\\n            return this.iamPolicyStub;\\n        }\\n        // Put together the \\\"service stub\\\" for\\n        // google.iam.v1.IAMPolicy.\\n        this.iamPolicyStub = this.gaxGrpc.createStub(this._opts.fallback\\n            ? this._protos.lookupService('google.iam.v1.IAMPolicy')\\n            : this._protos.google.iam.v1.IAMPolicy, this._opts);\\n        // Iterate over each of the methods that the service provides\\n        // and create an API call method for each.\\n        const iamPolicyStubMethods = [\\n            'getIamPolicy',\\n            'setIamPolicy',\\n            'testIamPermissions',\\n        ];\\n        for (const methodName of iamPolicyStubMethods) {\\n            const innerCallPromise = this.iamPolicyStub.then(stub =\u003e (...args) =\u003e {\\n                if (this._terminated) {\\n                    return Promise.reject('The client has already been closed.');\\n                }\\n                const func = stub[methodName];\\n                return func.apply(stub, args);\\n            }, (err) =\u003e () =\u003e {\\n                throw err;\\n            });\\n            this.innerApiCalls[methodName] = (0, createApiCall_1.createApiCall)(innerCallPromise, this._defaults[methodName], this.descriptors.page[methodName]);\\n        }\\n        return this.iamPolicyStub;\\n    }\\n    /**\\n     * The DNS address for this API service.\\n     */\\n    static get servicePath() {\\n        return 'cloudkms.googleapis.com';\\n    }\\n    /**\\n     * The DNS address for this API service - same as servicePath(),\\n     * exists for compatibility reasons.\\n     */\\n    static get apiEndpoint() {\\n        return 'cloudkms.googleapis.com';\\n    }\\n    /**\\n     * The port for this API service.\\n     */\\n    static get port() {\\n        return 443;\\n    }\\n    /**\\n     * The scopes needed to make gRPC calls for every method defined\\n     * in this service.\\n     */\\n    static get scopes() {\\n        return [\\n            'https://www.googleapis.com/auth/cloud-platform',\\n            'https://www.googleapis.com/auth/cloudkms',\\n        ];\\n    }\\n    getProjectId(callback) {\\n        if (this.auth \u0026\u0026 'getProjectId' in this.auth) {\\n            return this.auth.getProjectId(callback);\\n        }\\n        if (callback) {\\n            callback(new Error('Cannot determine project ID.'));\\n        }\\n        else {\\n            return Promise.reject('Cannot determine project ID.');\\n        }\\n    }\\n    getIamPolicy(request, optionsOrCallback, callback) {\\n        let options;\\n        if (optionsOrCallback instanceof Function \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            routingHeader.fromParams({\\n                resource: request.resource,\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.getIamPolicy(request, options, callback);\\n    }\\n    setIamPolicy(request, optionsOrCallback, callback) {\\n        let options;\\n        if (optionsOrCallback instanceof Function \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            routingHeader.fromParams({\\n                resource: request.resource,\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.setIamPolicy(request, options, callback);\\n    }\\n    testIamPermissions(request, optionsOrCallback, callback) {\\n        let options;\\n        if (optionsOrCallback instanceof Function \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            routingHeader.fromParams({\\n                resource: request.resource,\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.testIamPermissions(request, options, callback);\\n    }\\n    /**\\n     * Terminate the GRPC channel and close the client.\\n     *\\n     * The client will no longer be usable and all future behavior is undefined.\\n     */\\n    close() {\\n        this.initialize();\\n        if (!this._terminated) {\\n            return this.iamPolicyStub.then(stub =\u003e {\\n                this._terminated = true;\\n                stub.close();\\n            });\\n        }\\n        return Promise.resolve();\\n    }\\n},\\\"name\\\",{value:\\\"IamClient\\\"})\"\n"])</script><script>self.__next_f.push([1,"d7:\"$EObject.defineProperty(class LocationsClient {\\n    /**\\n     * Construct an instance of LocationsClient.\\n     *\\n     * @param {object} [options] - The configuration object.\\n     * The options accepted by the constructor are described in detail\\n     * in [this document](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#creating-the-client-instance).\\n     * The common options are:\\n     * @param {object} [options.credentials] - Credentials object.\\n     * @param {string} [options.credentials.client_email]\\n     * @param {string} [options.credentials.private_key]\\n     * @param {string} [options.email] - Account email address. Required when\\n     *     using a .pem or .p12 keyFilename.\\n     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or\\n     *     .p12 key downloaded from the Google Developers Console. If you provide\\n     *     a path to a JSON file, the projectId option below is not necessary.\\n     *     NOTE: .pem and .p12 require you to specify options.email as well.\\n     * @param {number} [options.port] - The port on which to connect to\\n     *     the remote host.\\n     * @param {string} [options.projectId] - The project ID from the Google\\n     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check\\n     *     the environment variable GCLOUD_PROJECT for your project ID. If your\\n     *     app is running in an environment which supports\\n     *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},\\n     *     your project ID will be detected automatically.\\n     * @param {string} [options.apiEndpoint] - The domain name of the\\n     *     API remote host.\\n     * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.\\n     *     Follows the structure of {@link gapicConfig}.\\n     * @param {boolean} [options.fallback] - Use HTTP fallback mode.\\n     *     In fallback mode, a special browser-compatible transport implementation is used\\n     *     instead of gRPC transport. In browser context (if the `window` object is defined)\\n     *     the fallback mode is enabled automatically; set `options.fallback` to `false`\\n     *     if you need to override this behavior.\\n     */\\n    constructor(gaxGrpc, \\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    opts) {\\n        var _a, _b;\\n        this._terminated = false;\\n        this.descriptors = {\\n            page: {},\\n            stream: {},\\n            longrunning: {},\\n            batching: {},\\n        };\\n        // Ensure that options include all the required fields.\\n        this.gaxGrpc = gaxGrpc;\\n        const staticMembers = this.constructor;\\n        const servicePath = (opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint) || staticMembers.servicePath;\\n        this._providedCustomServicePath = !!((opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint));\\n        const port = (opts === null || opts === void 0 ? void 0 : opts.port) || staticMembers.port;\\n        const clientConfig = (_a = opts === null || opts === void 0 ? void 0 : opts.clientConfig) !== null \u0026\u0026 _a !== void 0 ? _a : {};\\n        const fallback = (_b = opts === null || opts === void 0 ? void 0 : opts.fallback) !== null \u0026\u0026 _b !== void 0 ? _b : (typeof window !== 'undefined' \u0026\u0026 typeof (window === null || window === void 0 ? void 0 : window.fetch) === 'function');\\n        opts = Object.assign({ servicePath, port, clientConfig, fallback }, opts);\\n        // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.\\n        if (servicePath !== staticMembers.servicePath \u0026\u0026 !('scopes' in opts)) {\\n            opts['scopes'] = staticMembers.scopes;\\n        }\\n        // Save options to use in initialize() method.\\n        this._opts = opts;\\n        // Save the auth object to the client, for use by other methods.\\n        this.auth = gaxGrpc.auth;\\n        // Set the default scopes in auth client if needed.\\n        if (servicePath === staticMembers.servicePath) {\\n            this.auth.defaultScopes = staticMembers.scopes;\\n        }\\n        // Determine the client header string.\\n        const clientHeader = [`gax/${version}`, `gapic/${version}`];\\n        if (typeof process !== 'undefined' \u0026\u0026 'versions' in process) {\\n            clientHeader.push(`gl-node/${process.versions.node}`);\\n        }\\n        else {\\n            clientHeader.push(`gl-web/${version}`);\\n        }\\n        if (!opts.fallback) {\\n            clientHeader.push(`grpc/${gaxGrpc.grpcVersion}`);\\n        }\\n        else if (opts.fallback === 'rest') {\\n            clientHeader.push(`rest/${gaxGrpc.grpcVersion}`);\\n        }\\n        if (opts.libName \u0026\u0026 opts.libVersion) {\\n            clientHeader.push(`${opts.libName}/${opts.libVersion}`);\\n        }\\n        // Load the applicable protos.\\n        this._protos = gaxGrpc.loadProtoJSON(jsonProtos);\\n        // Some of the methods on this service return \\\"paged\\\" results,\\n        // (e.g. 50 results at a time, with tokens to get subsequent\\n        // pages). Denote the keys used for pagination and results.\\n        this.descriptors.page = {\\n            listLocations: new pageDescriptor_1.PageDescriptor('pageToken', 'nextPageToken', 'locations'),\\n        };\\n        // Put together the default options sent with requests.\\n        this._defaults = gaxGrpc.constructSettings('google.cloud.location.Locations', gapicConfig, opts.clientConfig || {}, { 'x-goog-api-client': clientHeader.join(' ') });\\n        // Set up a dictionary of \\\"inner API calls\\\"; the core implementation\\n        // of calling the API is handled in `google-gax`, with this code\\n        // merely providing the destination and request information.\\n        this.innerApiCalls = {};\\n        // Add a warn function to the client constructor so it can be easily tested.\\n        this.warn = warnings_1.warn;\\n    }\\n    /**\\n     * Initialize the client.\\n     * Performs asynchronous operations (such as authentication) and prepares the client.\\n     * This function will be called automatically when any class method is called for the\\n     * first time, but if you need to initialize it before calling an actual method,\\n     * feel free to call initialize() directly.\\n     *\\n     * You can await on this method if you want to make sure the client is initialized.\\n     *\\n     * @returns {Promise} A promise that resolves to an authenticated service stub.\\n     */\\n    initialize() {\\n        // If the client stub promise is already initialized, return immediately.\\n        if (this.locationsStub) {\\n            return this.locationsStub;\\n        }\\n        // Put together the \\\"service stub\\\" for\\n        // google.cloud.location.Locations.\\n        this.locationsStub = this.gaxGrpc.createStub(this._opts.fallback\\n            ? this._protos.lookupService('google.cloud.location.Locations')\\n            : // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n                this._protos.google.cloud.location.Locations, this._opts, this._providedCustomServicePath);\\n        // Iterate over each of the methods that the service provides\\n        // and create an API call method for each.\\n        const locationsStubMethods = ['listLocations', 'getLocation'];\\n        for (const methodName of locationsStubMethods) {\\n            const callPromise = this.locationsStub.then(stub =\u003e (...args) =\u003e {\\n                if (this._terminated) {\\n                    return Promise.reject('The client has already been closed.');\\n                }\\n                const func = stub[methodName];\\n                return func.apply(stub, args);\\n            }, (err) =\u003e () =\u003e {\\n                throw err;\\n            });\\n            const descriptor = this.descriptors.page[methodName] || undefined;\\n            const apiCall = (0, createApiCall_1.createApiCall)(callPromise, this._defaults[methodName], descriptor);\\n            this.innerApiCalls[methodName] = apiCall;\\n        }\\n        return this.locationsStub;\\n    }\\n    /**\\n     * The DNS address for this API service.\\n     * @returns {string} The DNS address for this service.\\n     */\\n    static get servicePath() {\\n        return 'cloud.googleapis.com';\\n    }\\n    /**\\n     * The DNS address for this API service - same as servicePath(),\\n     * exists for compatibility reasons.\\n     * @returns {string} The DNS address for this service.\\n     */\\n    static get apiEndpoint() {\\n        return 'cloud.googleapis.com';\\n    }\\n    /**\\n     * The port for this API service.\\n     * @returns {number} The default port for this service.\\n     */\\n    static get port() {\\n        return 443;\\n    }\\n    /**\\n     * The scopes needed to make gRPC calls for every method defined\\n     * in this service.\\n     * @returns {string[]} List of default scopes.\\n     */\\n    static get scopes() {\\n        return ['https://www.googleapis.com/auth/cloud-platform'];\\n    }\\n    getProjectId(callback) {\\n        if (callback) {\\n            this.auth.getProjectId(callback);\\n            return;\\n        }\\n        return this.auth.getProjectId();\\n    }\\n    /**\\n     * Gets information about a location.\\n     *\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.name\\n     *   Resource name for the location.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Promise} - The promise which resolves to an array.\\n     *   The first element of the array is an object representing [Location]{@link google.cloud.location.Location}.\\n     *   Please see the\\n     *   [documentation](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#regular-methods)\\n     *   for more details and examples.\\n     * @example\\n     * const [response] = await client.getLocation(request);\\n     */\\n    getLocation(request, optionsOrCallback, callback) {\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            routingHeader.fromParams({\\n                name: request.name || '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.getLocation(request, options, callback);\\n    }\\n    /**\\n     * Lists information about the supported locations for this service.\\n     *\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.name\\n     *   The resource that owns the locations collection, if applicable.\\n     * @param {string} request.filter\\n     *   The standard list filter.\\n     * @param {number} request.pageSize\\n     *   The standard list page size.\\n     * @param {string} request.pageToken\\n     *   The standard list page token.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Promise} - The promise which resolves to an array.\\n     *   The first element of the array is Array of [Location]{@link google.cloud.location.Location}.\\n     *   The client library will perform auto-pagination by default: it will call the API as many\\n     *   times as needed and will merge results from all the pages into this array.\\n     *   Note that it can affect your quota.\\n     *   We recommend using `listLocationsAsync()`\\n     *   method described below for async iteration which you can stop as needed.\\n     *   Please see the\\n     *   [documentation](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#auto-pagination)\\n     *   for more details and examples.\\n     */\\n    listLocations(request, optionsOrCallback, callback) {\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            routingHeader.fromParams({\\n                name: request.name || '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.listLocations(request, options, callback);\\n    }\\n    /**\\n     * Equivalent to `listLocations`, but returns an iterable object.\\n     *\\n     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.name\\n     *   The resource that owns the locations collection, if applicable.\\n     * @param {string} request.filter\\n     *   The standard list filter.\\n     * @param {number} request.pageSize\\n     *   The standard list page size.\\n     * @param {string} request.pageToken\\n     *   The standard list page token.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Object}\\n     *   An iterable Object that allows [async iteration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).\\n     *   When you iterate the returned iterable, each element will be an object representing\\n     *   [Location]{@link google.cloud.location.Location}. The API will be called under the hood as needed, once per the page,\\n     *   so you can stop the iteration when you don't need more results.\\n     *   Please see the\\n     *   [documentation](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#auto-pagination)\\n     *   for more details and examples.\\n     * @example\\n     * const iterable = client.listLocationsAsync(request);\\n     * for await (const response of iterable) {\\n     *   // process response\\n     * }\\n     */\\n    listLocationsAsync(request, options) {\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            routingHeader.fromParams({\\n                name: request.name || '',\\n            });\\n        options = options || {};\\n        const callSettings = new gax.CallSettings(options);\\n        this.initialize();\\n        return this.descriptors.page.listLocations.asyncIterate(this.innerApiCalls['listLocations'], request, callSettings);\\n    }\\n    /**\\n     * Terminate the gRPC channel and close the client.\\n     *\\n     * The client will no longer be usable and all future behavior is undefined.\\n     * @returns {Promise} A promise that resolves when the client is closed.\\n     */\\n    close() {\\n        this.initialize();\\n        if (!this._terminated) {\\n            return this.locationsStub.then(stub =\u003e {\\n                this._terminated = true;\\n                stub.close();\\n            });\\n        }\\n        return Promise.resolve();\\n    }\\n},\\\"name\\\",{value:\\\"LocationsClient\\\"})\"\n"])</script><script>self.__next_f.push([1,"d8:\"$EObject.defineProperty(createByteLengthFunction(message) {\\n        return gax.createByteLengthFunction(message);\\n    },\\\"name\\\",{value:\\\"createByteLengthFunction\\\"})\"\nd9:\"$EObject.defineProperty(function makeUUID() {\\n    return (0, uuid_1.v4)();\\n},\\\"name\\\",{value:\\\"makeUUID\\\"})\"\nda:\"$EObject.defineProperty(function warn(code, message, warnType) {\\n    // Only show a given warning once\\n    if (emittedWarnings.has(code)) {\\n        return;\\n    }\\n    emittedWarnings.add(code);\\n    if (!(0, featureDetection_1.isNodeJS)()) {\\n        console.warn(message);\\n    }\\n    else if (typeof warnType !== 'undefined') {\\n        process.emitWarning(message, {\\n            type: warnType,\\n        });\\n    }\\n    else {\\n        process.emitWarning(message);\\n    }\\n},\\\"name\\\",{value:\\\"warn\\\"})\"\ndb:\"$EObject.defineProperty(function lro(options) {\\n    options = Object.assign({ scopes: lro.ALL_SCOPES }, options);\\n    const gaxGrpc = new grpc_1.GrpcClient(options);\\n    return new operationsClient.OperationsClientBuilder(gaxGrpc);\\n},\\\"name\\\",{value:\\\"lro\\\"})\"\n"])</script><script>self.__next_f.push([1,"a3:{\"GoogleAuth\":\"$a4\",\"grpc\":{\"credentials\":\"$Y\",\"Metadata\":\"$a5\",\"logVerbosity\":\"$Y\",\"status\":\"$Y\",\"connectivityState\":\"$Y\",\"propagate\":\"$Y\",\"compressionAlgorithms\":\"$Y\",\"Client\":\"$a6\",\"loadPackageDefinition\":\"$a7\",\"makeClientConstructor\":\"$a8\",\"makeGenericClientConstructor\":\"$a8\",\"Channel\":\"$a9\",\"closeClient\":\"$aa\",\"waitForClientReady\":\"$ab\",\"ChannelCredentials\":\"$ac\",\"CallCredentials\":\"$ad\",\"loadObject\":\"$ae\",\"load\":\"$af\",\"setLogger\":\"$b0\",\"setLogVerbosity\":\"$b1\",\"Server\":\"$b2\",\"ServerCredentials\":\"$b3\",\"getClientChannel\":\"$b4\",\"StatusBuilder\":\"$b5\",\"ListenerBuilder\":\"$b6\",\"RequesterBuilder\":\"$b7\",\"InterceptingCall\":\"$b8\",\"InterceptorConfigurationError\":\"$b9\",\"getChannelzServiceDefinition\":\"$ba\",\"getChannelzHandlers\":\"$bb\",\"addAdminServicesToServer\":\"$bc\",\"ServerListenerBuilder\":\"$bd\",\"ResponderBuilder\":\"$be\",\"ServerInterceptingCall\":\"$bf\",\"experimental\":\"$Y\"},\"OngoingCall\":\"$c0\",\"createApiCall\":\"$c1\",\"BundleDescriptor\":\"$c2\",\"LongrunningDescriptor\":\"$c3\",\"PageDescriptor\":\"$c4\",\"StreamDescriptor\":\"$c5\",\"CallSettings\":\"$c6\",\"constructSettings\":\"$c7\",\"RetryOptions\":\"$c8\",\"createRetryOptions\":\"$c9\",\"createBundleOptions\":\"$ca\",\"createBackoffSettings\":\"$cb\",\"createDefaultBackoffSettings\":\"$cc\",\"createMaxRetriesBackoffSettings\":\"$cd\",\"GoogleError\":\"$ce\",\"ClientStub\":\"$cf\",\"GoogleProtoFilesRoot\":\"$d0\",\"GrpcClient\":\"$d1\",\"Operation\":\"$d2\",\"operation\":\"$d3\",\"PathTemplate\":\"$d4\",\"Status\":\"$Y\",\"StreamType\":\"$Y\",\"routingHeader\":\"$Y\",\"operationsProtos\":\"$Y\",\"IamProtos\":\"$Y\",\"LocationProtos\":\"$Y\",\"OperationsClient\":\"$d5\",\"IamClient\":\"$d6\",\"LocationsClient\":\"$d7\",\"createByteLengthFunction\":\"$d8\",\"version\":\"4.4.1\",\"protobuf\":\"$Y\",\"protobufMinimal\":\"$Y\",\"fallback\":\"$Y\",\"makeUUID\":\"$d9\",\"ChannelCredentials\":\"$ac\",\"warn\":\"$da\",\"serializer\":\"$Y\",\"lro\":\"$db\"}\n"])</script><script>self.__next_f.push([1,"df:{}\ne0:{\"refresh_token\":\"jwt-placeholder\",\"expiry_date\":1}\ne4:[]\ne3:\"$Qe4\"\ne5:{}\ne6:{\"request\":\"$Y\",\"response\":\"$Y\"}\n"])</script><script>self.__next_f.push([1,"e8:\"$EObject.defineProperty(class Gaxios {\\n    /**\\n     * The Gaxios class is responsible for making HTTP requests.\\n     * @param defaults The default set of options to be used for this instance.\\n     */\\n    constructor(defaults) {\\n        _Gaxios_instances.add(this);\\n        this.agentCache = new Map();\\n        this.defaults = defaults || {};\\n        this.interceptors = {\\n            request: new interceptor_1.GaxiosInterceptorManager(),\\n            response: new interceptor_1.GaxiosInterceptorManager(),\\n        };\\n    }\\n    /**\\n     * Perform an HTTP request with the given options.\\n     * @param opts Set of HTTP options that will be used for this HTTP request.\\n     */\\n    async request(opts = {}) {\\n        opts = await __classPrivateFieldGet(this, _Gaxios_instances, \\\"m\\\", _Gaxios_prepareRequest).call(this, opts);\\n        opts = await __classPrivateFieldGet(this, _Gaxios_instances, \\\"m\\\", _Gaxios_applyRequestInterceptors).call(this, opts);\\n        return __classPrivateFieldGet(this, _Gaxios_instances, \\\"m\\\", _Gaxios_applyResponseInterceptors).call(this, this._request(opts));\\n    }\\n    async _defaultAdapter(opts) {\\n        const fetchImpl = opts.fetchImplementation || fetch;\\n        const res = (await fetchImpl(opts.url, opts));\\n        const data = await this.getResponseData(opts, res);\\n        return this.translateResponse(opts, res, data);\\n    }\\n    /**\\n     * Internal, retryable version of the `request` method.\\n     * @param opts Set of HTTP options that will be used for this HTTP request.\\n     */\\n    async _request(opts = {}) {\\n        var _b;\\n        try {\\n            let translatedResponse;\\n            if (opts.adapter) {\\n                translatedResponse = await opts.adapter(opts, this._defaultAdapter.bind(this));\\n            }\\n            else {\\n                translatedResponse = await this._defaultAdapter(opts);\\n            }\\n            if (!opts.validateStatus(translatedResponse.status)) {\\n                if (opts.responseType === 'stream') {\\n                    let response = '';\\n                    await new Promise(resolve =\u003e {\\n                        (translatedResponse === null || translatedResponse === void 0 ? void 0 : translatedResponse.data).on('data', chunk =\u003e {\\n                            response += chunk;\\n                        });\\n                        (translatedResponse === null || translatedResponse === void 0 ? void 0 : translatedResponse.data).on('end', resolve);\\n                    });\\n                    translatedResponse.data = response;\\n                }\\n                throw new common_1.GaxiosError(`Request failed with status code ${translatedResponse.status}`, opts, translatedResponse);\\n            }\\n            return translatedResponse;\\n        }\\n        catch (e) {\\n            const err = e instanceof common_1.GaxiosError\\n                ? e\\n                : new common_1.GaxiosError(e.message, opts, undefined, e);\\n            const { shouldRetry, config } = await (0, retry_1.getRetryConfig)(err);\\n            if (shouldRetry \u0026\u0026 config) {\\n                err.config.retryConfig.currentRetryAttempt =\\n                    config.retryConfig.currentRetryAttempt;\\n                // The error's config could be redacted - therefore we only want to\\n                // copy the retry state over to the existing config\\n                opts.retryConfig = (_b = err.config) === null || _b === void 0 ? void 0 : _b.retryConfig;\\n                return this._request(opts);\\n            }\\n            throw err;\\n        }\\n    }\\n    async getResponseData(opts, res) {\\n        switch (opts.responseType) {\\n            case 'stream':\\n                return res.body;\\n            case 'json': {\\n                let data = await res.text();\\n                try {\\n                    data = JSON.parse(data);\\n                }\\n                catch (_b) {\\n                    // continue\\n                }\\n                return data;\\n            }\\n            case 'arraybuffer':\\n                return res.arrayBuffer();\\n            case 'blob':\\n                return res.blob();\\n            case 'text':\\n                return res.text();\\n            default:\\n                return this.getResponseDataFromContentType(res);\\n        }\\n    }\\n    /**\\n     * By default, throw for any non-2xx status code\\n     * @param status status code from the HTTP response\\n     */\\n    validateStatus(status) {\\n        return status \u003e= 200 \u0026\u0026 status \u003c 300;\\n    }\\n    /**\\n     * Encode a set of key/value pars into a querystring format (?foo=bar\u0026baz=boo)\\n     * @param params key value pars to encode\\n     */\\n    paramsSerializer(params) {\\n        return querystring_1.default.stringify(params);\\n    }\\n    translateResponse(opts, res, data) {\\n        // headers need to be converted from a map to an obj\\n        const headers = {};\\n        res.headers.forEach((value, key) =\u003e {\\n            headers[key] = value;\\n        });\\n        return {\\n            config: opts,\\n            data: data,\\n            headers,\\n            status: res.status,\\n            statusText: res.statusText,\\n            // XMLHttpRequestLike\\n            request: {\\n                responseURL: res.url,\\n            },\\n        };\\n    }\\n    /**\\n     * Attempts to parse a response by looking at the Content-Type header.\\n     * @param {FetchResponse} response the HTTP response.\\n     * @returns {Promise\u003cany\u003e} a promise that resolves to the response data.\\n     */\\n    async getResponseDataFromContentType(response) {\\n        let contentType = response.headers.get('Content-Type');\\n        if (contentType === null) {\\n            // Maintain existing functionality by calling text()\\n            return response.text();\\n        }\\n        contentType = contentType.toLowerCase();\\n        if (contentType.includes('application/json')) {\\n            let data = await response.text();\\n            try {\\n                data = JSON.parse(data);\\n            }\\n            catch (_b) {\\n                // continue\\n            }\\n            return data;\\n        }\\n        else if (contentType.match(/^text\\\\//)) {\\n            return response.text();\\n        }\\n        else {\\n            // If the content type is something not easily handled, just return the raw data (blob)\\n            return response.blob();\\n        }\\n    }\\n    /**\\n     * Creates an async generator that yields the pieces of a multipart/related request body.\\n     * This implementation follows the spec: https://www.ietf.org/rfc/rfc2387.txt. However, recursive\\n     * multipart/related requests are not currently supported.\\n     *\\n     * @param {GaxioMultipartOptions[]} multipartOptions the pieces to turn into a multipart/related body.\\n     * @param {string} boundary the boundary string to be placed between each part.\\n     */\\n    async *getMultipartRequest(multipartOptions, boundary) {\\n        const finale = `--${boundary}--`;\\n        for (const currentPart of multipartOptions) {\\n            const partContentType = currentPart.headers['Content-Type'] || 'application/octet-stream';\\n            const preamble = `--${boundary}\\\\r\\\\nContent-Type: ${partContentType}\\\\r\\\\n\\\\r\\\\n`;\\n            yield preamble;\\n            if (typeof currentPart.content === 'string') {\\n                yield currentPart.content;\\n            }\\n            else {\\n                yield* currentPart.content;\\n            }\\n            yield '\\\\r\\\\n';\\n        }\\n        yield finale;\\n    }\\n},\\\"name\\\",{value:\\\"Gaxios\\\"})\"\n"])</script><script>self.__next_f.push([1,"e7:\"$e8\"\ne2:{\"agentCache\":\"$e3\",\"defaults\":\"$e5\",\"interceptors\":\"$e6\",\"\":\"$Pe7\"}\n"])</script><script>self.__next_f.push([1,"ea:\"$EObject.defineProperty(class DefaultTransporter {\\n    constructor() {\\n        /**\\n         * A configurable, replacable `Gaxios` instance.\\n         */\\n        this.instance = new gaxios_1.Gaxios();\\n    }\\n    /**\\n     * Configures request options before making a request.\\n     * @param opts GaxiosOptions options.\\n     * @return Configured options.\\n     */\\n    configure(opts = {}) {\\n        opts.headers = opts.headers || {};\\n        if (typeof window === 'undefined') {\\n            // set transporter user agent if not in browser\\n            const uaValue = opts.headers['User-Agent'];\\n            if (!uaValue) {\\n                opts.headers['User-Agent'] = DefaultTransporter.USER_AGENT;\\n            }\\n            else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {\\n                opts.headers['User-Agent'] =\\n                    `${uaValue} ${DefaultTransporter.USER_AGENT}`;\\n            }\\n            // track google-auth-library-nodejs version:\\n            if (!opts.headers['x-goog-api-client']) {\\n                const nodeVersion = process.version.replace(/^v/, '');\\n                opts.headers['x-goog-api-client'] = `gl-node/${nodeVersion}`;\\n            }\\n        }\\n        return opts;\\n    }\\n    /**\\n     * Makes a request using Gaxios with given options.\\n     * @param opts GaxiosOptions options.\\n     * @param callback optional callback that contains GaxiosResponse object.\\n     * @return GaxiosPromise, assuming no callback is passed.\\n     */\\n    request(opts) {\\n        // ensure the user isn't passing in request-style options\\n        opts = this.configure(opts);\\n        (0, options_1.validate)(opts);\\n        return this.instance.request(opts).catch(e =\u003e {\\n            throw this.processError(e);\\n        });\\n    }\\n    get defaults() {\\n        return this.instance.defaults;\\n    }\\n    set defaults(opts) {\\n        this.instance.defaults = opts;\\n    }\\n    /**\\n     * Changes the error to include details from the body.\\n     */\\n    processError(e) {\\n        const res = e.response;\\n        const err = e;\\n        const body = res ? res.data : null;\\n        if (res \u0026\u0026 body \u0026\u0026 body.error \u0026\u0026 res.status !== 200) {\\n            if (typeof body.error === 'string') {\\n                err.message = body.error;\\n                err.status = res.status;\\n            }\\n            else if (Array.isArray(body.error.errors)) {\\n                err.message = body.error.errors\\n                    .map((err2) =\u003e err2.message)\\n                    .join('\\\\n');\\n                err.code = body.error.code;\\n                err.errors = body.error.errors;\\n            }\\n            else {\\n                err.message = body.error.message;\\n                err.code = body.error.code;\\n            }\\n        }\\n        else if (res \u0026\u0026 res.status \u003e= 400) {\\n            // Consider all 4xx and 5xx responses errors.\\n            err.message = body;\\n            err.status = res.status;\\n        }\\n        return err;\\n    }\\n},\\\"name\\\",{value:\\\"DefaultTransporter\\\"})\"\n"])</script><script>self.__next_f.push([1,"e9:\"$ea\"\ne1:{\"instance\":\"$e2\",\"\":\"$Pe9\"}\neb:{}\ned:[]\nec:\"$Qed\"\nee:{\"tokenInfoUrl\":\"https://oauth2.googleapis.com/tokeninfo\",\"oauth2AuthBaseUrl\":\"https://accounts.google.com/o/oauth2/v2/auth\",\"oauth2TokenUrl\":\"https://oauth2.googleapis.com/token\",\"oauth2RevokeUrl\":\"https://oauth2.googleapis.com/revoke\",\"oauth2FederatedSignonPemCertsUrl\":\"https://www.googleapis.com/oauth2/v1/certs\",\"oauth2FederatedSignonJwkCertsUrl\":\"https://www.googleapis.com/oauth2/v3/certs\",\"oauth2IapPublicKeyUrl\":\"https://www.gstatic.com/iap/verify/public_key\"}\nef:[\"accounts.google.com\",\"https://accounts.google.com\",\"googleapis.com\"]\nf0:[\"https://www.googleapis.com/auth/cloud-platform\",\"https://www.googleapis.com/auth/datastore\"]\nf4:\"$EObject.defineProperty(class LRUCache {\\n    constructor(options) {\\n        _LRUCache_instances.add(this);\\n        /**\\n         * Maps are in order. Thus, the older item is the first item.\\n         *\\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map}\\n         */\\n        _LRUCache_cache.set(this, new Map());\\n        this.capacity = options.capacity;\\n        this.maxAge = options.maxAge;\\n    }\\n    /**\\n     * Add an item to the cache.\\n     *\\n     * @param key the key to upsert\\n     * @param value the value of the key\\n     */\\n    set(key, value) {\\n        __classPrivateFieldGet(this, _LRUCache_instances, \\\"m\\\", _LRUCache_moveToEnd).call(this, key, value);\\n        __classPrivateFieldGet(this, _LRUCache_instances, \\\"m\\\", _LRUCache_evict).call(this);\\n    }\\n    /**\\n     * Get an item from the cache.\\n     *\\n     * @param key the key to retrieve\\n     */\\n    get(key) {\\n        const item = __classPrivateFieldGet(this, _LRUCache_cache, \\\"f\\\").get(key);\\n        if (!item)\\n            return;\\n        __classPrivateFieldGet(this, _LRUCache_instances, \\\"m\\\", _LRUCache_moveToEnd).call(this, key, item.value);\\n        __classPrivateFieldGet(this, _LRUCache_instances, \\\"m\\\", _LRUCache_evict).call(this);\\n        return item.value;\\n    }\\n},\\\"name\\\",{value:\\\"LRUCache\\\"})\"\nf3:\"$f4\"\nf2:{\"capacity\":500,\"maxAge\":3600000,\"\":\"$Pf3\"}\n"])</script><script>self.__next_f.push([1,"f6:\"$EObject.defineProperty(class JWTAccess {\\n    /**\\n     * JWTAccess service account credentials.\\n     *\\n     * Create a new access token by using the credential to create a new JWT token\\n     * that's recognized as the access token.\\n     *\\n     * @param email the service account email address.\\n     * @param key the private key that will be used to sign the token.\\n     * @param keyId the ID of the private key used to sign the token.\\n     */\\n    constructor(email, key, keyId, eagerRefreshThresholdMillis) {\\n        this.cache = new util_1.LRUCache({\\n            capacity: 500,\\n            maxAge: 60 * 60 * 1000,\\n        });\\n        this.email = email;\\n        this.key = key;\\n        this.keyId = keyId;\\n        this.eagerRefreshThresholdMillis =\\n            eagerRefreshThresholdMillis !== null \u0026\u0026 eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1000;\\n    }\\n    /**\\n     * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url\\n     *\\n     * @param url The URI being authorized.\\n     * @param scopes The scope or scopes being authorized\\n     * @returns A string that returns the cached key.\\n     */\\n    getCachedKey(url, scopes) {\\n        let cacheKey = url;\\n        if (scopes \u0026\u0026 Array.isArray(scopes) \u0026\u0026 scopes.length) {\\n            cacheKey = url ? `${url}_${scopes.join('_')}` : `${scopes.join('_')}`;\\n        }\\n        else if (typeof scopes === 'string') {\\n            cacheKey = url ? `${url}_${scopes}` : scopes;\\n        }\\n        if (!cacheKey) {\\n            throw Error('Scopes or url must be provided');\\n        }\\n        return cacheKey;\\n    }\\n    /**\\n     * Get a non-expired access token, after refreshing if necessary.\\n     *\\n     * @param url The URI being authorized.\\n     * @param additionalClaims An object with a set of additional claims to\\n     * include in the payload.\\n     * @returns An object that includes the authorization header.\\n     */\\n    getRequestHeaders(url, additionalClaims, scopes) {\\n        // Return cached authorization headers, unless we are within\\n        // eagerRefreshThresholdMillis ms of them expiring:\\n        const key = this.getCachedKey(url, scopes);\\n        const cachedToken = this.cache.get(key);\\n        const now = Date.now();\\n        if (cachedToken \u0026\u0026\\n            cachedToken.expiration - now \u003e this.eagerRefreshThresholdMillis) {\\n            return cachedToken.headers;\\n        }\\n        const iat = Math.floor(Date.now() / 1000);\\n        const exp = JWTAccess.getExpirationTime(iat);\\n        let defaultClaims;\\n        // Turn scopes into space-separated string\\n        if (Array.isArray(scopes)) {\\n            scopes = scopes.join(' ');\\n        }\\n        // If scopes are specified, sign with scopes\\n        if (scopes) {\\n            defaultClaims = {\\n                iss: this.email,\\n                sub: this.email,\\n                scope: scopes,\\n                exp,\\n                iat,\\n            };\\n        }\\n        else {\\n            defaultClaims = {\\n                iss: this.email,\\n                sub: this.email,\\n                aud: url,\\n                exp,\\n                iat,\\n            };\\n        }\\n        // if additionalClaims are provided, ensure they do not collide with\\n        // other required claims.\\n        if (additionalClaims) {\\n            for (const claim in defaultClaims) {\\n                if (additionalClaims[claim]) {\\n                    throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);\\n                }\\n            }\\n        }\\n        const header = this.keyId\\n            ? { ...DEFAULT_HEADER, kid: this.keyId }\\n            : DEFAULT_HEADER;\\n        const payload = Object.assign(defaultClaims, additionalClaims);\\n        // Sign the jwt and add it to the cache\\n        const signedJWT = jws.sign({ header, payload, secret: this.key });\\n        const headers = { Authorization: `Bearer ${signedJWT}` };\\n        this.cache.set(key, {\\n            expiration: exp * 1000,\\n            headers,\\n        });\\n        return headers;\\n    }\\n    /**\\n     * Returns an expiration time for the JWT token.\\n     *\\n     * @param iat The issued at time for the JWT.\\n     * @returns An expiration time for the JWT.\\n     */\\n    static getExpirationTime(iat) {\\n        const exp = iat + 3600; // 3600 seconds = 1 hour\\n        return exp;\\n    }\\n    /**\\n     * Create a JWTAccess credentials instance using the given input options.\\n     * @param json The input object.\\n     */\\n    fromJSON(json) {\\n        if (!json) {\\n            throw new Error('Must pass in a JSON object containing the service account auth settings.');\\n        }\\n        if (!json.client_email) {\\n            throw new Error('The incoming JSON object does not contain a client_email field');\\n        }\\n        if (!json.private_key) {\\n            throw new Error('The incoming JSON object does not contain a private_key field');\\n        }\\n        // Extract the relevant information from the json key file.\\n        this.email = json.client_email;\\n        this.key = json.private_key;\\n        this.keyId = json.private_key_id;\\n        this.projectId = json.project_id;\\n    }\\n    fromStream(inputStream, callback) {\\n        if (callback) {\\n            this.fromStreamAsync(inputStream).then(() =\u003e callback(), callback);\\n        }\\n        else {\\n            return this.fromStreamAsync(inputStream);\\n        }\\n    }\\n    fromStreamAsync(inputStream) {\\n        return new Promise((resolve, reject) =\u003e {\\n            if (!inputStream) {\\n                reject(new Error('Must pass in a stream containing the service account auth settings.'));\\n            }\\n            let s = '';\\n            inputStream\\n                .setEncoding('utf8')\\n                .on('data', chunk =\u003e (s += chunk))\\n                .on('error', reject)\\n                .on('end', () =\u003e {\\n                try {\\n                    const data = JSON.parse(s);\\n                    this.fromJSON(data);\\n                    resolve();\\n                }\\n                catch (err) {\\n                    reject(err);\\n                }\\n            });\\n        });\\n    }\\n},\\\"name\\\",{value:\\\"JWTAccess\\\"})\"\n"])</script><script>self.__next_f.push([1,"f5:\"$f6\"\nf1:{\"cache\":\"$f2\",\"email\":\"firebase-adminsdk-fbsvc@resumemaker-b590f.iam.gserviceaccount.com\",\"key\":\"$Y\",\"keyId\":\"$undefined\",\"eagerRefreshThresholdMillis\":300000,\"\":\"$Pf5\"}\n"])</script><script>self.__next_f.push([1,"f8:\"$EObject.defineProperty(class JWT extends oauth2client_1.OAuth2Client {\\n    constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId) {\\n        const opts = optionsOrEmail \u0026\u0026 typeof optionsOrEmail === 'object'\\n            ? optionsOrEmail\\n            : { email: optionsOrEmail, keyFile, key, keyId, scopes, subject };\\n        super(opts);\\n        this.email = opts.email;\\n        this.keyFile = opts.keyFile;\\n        this.key = opts.key;\\n        this.keyId = opts.keyId;\\n        this.scopes = opts.scopes;\\n        this.subject = opts.subject;\\n        this.additionalClaims = opts.additionalClaims;\\n        // Start with an expired refresh token, which will automatically be\\n        // refreshed before the first API call is made.\\n        this.credentials = { refresh_token: 'jwt-placeholder', expiry_date: 1 };\\n    }\\n    /**\\n     * Creates a copy of the credential with the specified scopes.\\n     * @param scopes List of requested scopes or a single scope.\\n     * @return The cloned instance.\\n     */\\n    createScoped(scopes) {\\n        const jwt = new JWT(this);\\n        jwt.scopes = scopes;\\n        return jwt;\\n    }\\n    /**\\n     * Obtains the metadata to be sent with the request.\\n     *\\n     * @param url the URI being authorized.\\n     */\\n    async getRequestMetadataAsync(url) {\\n        url = this.defaultServicePath ? `https://${this.defaultServicePath}/` : url;\\n        const useSelfSignedJWT = (!this.hasUserScopes() \u0026\u0026 url) ||\\n            (this.useJWTAccessWithScope \u0026\u0026 this.hasAnyScopes()) ||\\n            this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;\\n        if (this.subject \u0026\u0026 this.universeDomain !== authclient_1.DEFAULT_UNIVERSE) {\\n            throw new RangeError(`Service Account user is configured for the credential. Domain-wide delegation is not supported in universes other than ${authclient_1.DEFAULT_UNIVERSE}`);\\n        }\\n        if (!this.apiKey \u0026\u0026 useSelfSignedJWT) {\\n            if (this.additionalClaims \u0026\u0026\\n                this.additionalClaims.target_audience) {\\n                const { tokens } = await this.refreshToken();\\n                return {\\n                    headers: this.addSharedMetadataHeaders({\\n                        Authorization: `Bearer ${tokens.id_token}`,\\n                    }),\\n                };\\n            }\\n            else {\\n                // no scopes have been set, but a uri has been provided. Use JWTAccess\\n                // credentials.\\n                if (!this.access) {\\n                    this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);\\n                }\\n                let scopes;\\n                if (this.hasUserScopes()) {\\n                    scopes = this.scopes;\\n                }\\n                else if (!url) {\\n                    scopes = this.defaultScopes;\\n                }\\n                const useScopes = this.useJWTAccessWithScope ||\\n                    this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;\\n                const headers = await this.access.getRequestHeaders(url !== null \u0026\u0026 url !== void 0 ? url : undefined, this.additionalClaims, \\n                // Scopes take precedent over audience for signing,\\n                // so we only provide them if `useJWTAccessWithScope` is on or\\n                // if we are in a non-default universe\\n                useScopes ? scopes : undefined);\\n                return { headers: this.addSharedMetadataHeaders(headers) };\\n            }\\n        }\\n        else if (this.hasAnyScopes() || this.apiKey) {\\n            return super.getRequestMetadataAsync(url);\\n        }\\n        else {\\n            // If no audience, apiKey, or scopes are provided, we should not attempt\\n            // to populate any headers:\\n            return { headers: {} };\\n        }\\n    }\\n    /**\\n     * Fetches an ID token.\\n     * @param targetAudience the audience for the fetched ID token.\\n     */\\n    async fetchIdToken(targetAudience) {\\n        // Create a new gToken for fetching an ID token\\n        const gtoken = new gtoken_1.GoogleToken({\\n            iss: this.email,\\n            sub: this.subject,\\n            scope: this.scopes || this.defaultScopes,\\n            keyFile: this.keyFile,\\n            key: this.key,\\n            additionalClaims: { target_audience: targetAudience },\\n            transporter: this.transporter,\\n        });\\n        await gtoken.getToken({\\n            forceRefresh: true,\\n        });\\n        if (!gtoken.idToken) {\\n            throw new Error('Unknown error: Failed to fetch ID token');\\n        }\\n        return gtoken.idToken;\\n    }\\n    /**\\n     * Determine if there are currently scopes available.\\n     */\\n    hasUserScopes() {\\n        if (!this.scopes) {\\n            return false;\\n        }\\n        return this.scopes.length \u003e 0;\\n    }\\n    /**\\n     * Are there any default or user scopes defined.\\n     */\\n    hasAnyScopes() {\\n        if (this.scopes \u0026\u0026 this.scopes.length \u003e 0)\\n            return true;\\n        if (this.defaultScopes \u0026\u0026 this.defaultScopes.length \u003e 0)\\n            return true;\\n        return false;\\n    }\\n    authorize(callback) {\\n        if (callback) {\\n            this.authorizeAsync().then(r =\u003e callback(null, r), callback);\\n        }\\n        else {\\n            return this.authorizeAsync();\\n        }\\n    }\\n    async authorizeAsync() {\\n        const result = await this.refreshToken();\\n        if (!result) {\\n            throw new Error('No result returned');\\n        }\\n        this.credentials = result.tokens;\\n        this.credentials.refresh_token = 'jwt-placeholder';\\n        this.key = this.gtoken.key;\\n        this.email = this.gtoken.iss;\\n        return result.tokens;\\n    }\\n    /**\\n     * Refreshes the access token.\\n     * @param refreshToken ignored\\n     * @private\\n     */\\n    async refreshTokenNoCache(\\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\\n    refreshToken) {\\n        const gtoken = this.createGToken();\\n        const token = await gtoken.getToken({\\n            forceRefresh: this.isTokenExpiring(),\\n        });\\n        const tokens = {\\n            access_token: token.access_token,\\n            token_type: 'Bearer',\\n            expiry_date: gtoken.expiresAt,\\n            id_token: gtoken.idToken,\\n        };\\n        this.emit('tokens', tokens);\\n        return { res: null, tokens };\\n    }\\n    /**\\n     * Create a gToken if it doesn't already exist.\\n     */\\n    createGToken() {\\n        if (!this.gtoken) {\\n            this.gtoken = new gtoken_1.GoogleToken({\\n                iss: this.email,\\n                sub: this.subject,\\n                scope: this.scopes || this.defaultScopes,\\n                keyFile: this.keyFile,\\n                key: this.key,\\n                additionalClaims: this.additionalClaims,\\n                transporter: this.transporter,\\n            });\\n        }\\n        return this.gtoken;\\n    }\\n    /**\\n     * Create a JWT credentials instance using the given input options.\\n     * @param json The input object.\\n     *\\n     * @remarks\\n     *\\n     * **Important**: If you accept a credential configuration (credential JSON/File/Stream) from an external source for authentication to Google Cloud, you must validate it before providing it to any Google API or library. Providing an unvalidated credential configuration to Google APIs can compromise the security of your systems and data. For more information, refer to {@link https://cloud.google.com/docs/authentication/external/externally-sourced-credentials Validate credential configurations from external sources}.\\n     */\\n    fromJSON(json) {\\n        if (!json) {\\n            throw new Error('Must pass in a JSON object containing the service account auth settings.');\\n        }\\n        if (!json.client_email) {\\n            throw new Error('The incoming JSON object does not contain a client_email field');\\n        }\\n        if (!json.private_key) {\\n            throw new Error('The incoming JSON object does not contain a private_key field');\\n        }\\n        // Extract the relevant information from the json key file.\\n        this.email = json.client_email;\\n        this.key = json.private_key;\\n        this.keyId = json.private_key_id;\\n        this.projectId = json.project_id;\\n        this.quotaProjectId = json.quota_project_id;\\n        this.universeDomain = json.universe_domain || this.universeDomain;\\n    }\\n    fromStream(inputStream, callback) {\\n        if (callback) {\\n            this.fromStreamAsync(inputStream).then(() =\u003e callback(), callback);\\n        }\\n        else {\\n            return this.fromStreamAsync(inputStream);\\n        }\\n    }\\n    fromStreamAsync(inputStream) {\\n        return new Promise((resolve, reject) =\u003e {\\n            if (!inputStream) {\\n                throw new Error('Must pass in a stream containing the service account auth settings.');\\n            }\\n            let s = '';\\n            inputStream\\n                .setEncoding('utf8')\\n                .on('error', reject)\\n                .on('data', chunk =\u003e (s += chunk))\\n                .on('end', () =\u003e {\\n                try {\\n                    const data = JSON.parse(s);\\n                    this.fromJSON(data);\\n                    resolve();\\n                }\\n                catch (e) {\\n                    reject(e);\\n                }\\n            });\\n        });\\n    }\\n    /**\\n     * Creates a JWT credentials instance using an API Key for authentication.\\n     * @param apiKey The API Key in string form.\\n     */\\n    fromAPIKey(apiKey) {\\n        if (typeof apiKey !== 'string') {\\n            throw new Error('Must provide an API Key string.');\\n        }\\n        this.apiKey = apiKey;\\n    }\\n    /**\\n     * Using the key or keyFile on the JWT client, obtain an object that contains\\n     * the key and the client email.\\n     */\\n    async getCredentials() {\\n        if (this.key) {\\n            return { private_key: this.key, client_email: this.email };\\n        }\\n        else if (this.keyFile) {\\n            const gtoken = this.createGToken();\\n            const creds = await gtoken.getCredentials(this.keyFile);\\n            return { private_key: creds.privateKey, client_email: creds.clientEmail };\\n        }\\n        throw new Error('A key or a keyFile must be provided to getCredentials.');\\n    }\\n},\\\"name\\\",{value:\\\"JWT\\\"})\"\n"])</script><script>self.__next_f.push([1,"f7:\"$f8\"\nde:{\"_events\":\"$df\",\"_eventsCount\":0,\"_maxListeners\":\"$undefined\",\"credentials\":\"$e0\",\"eagerRefreshThresholdMillis\":300000,\"forceRefreshOnFailure\":false,\"universeDomain\":\"googleapis.com\",\"apiKey\":\"$undefined\",\"projectId\":\"$undefined\",\"quotaProjectId\":\"$undefined\",\"transporter\":\"$e1\",\"certificateCache\":\"$eb\",\"certificateExpiry\":null,\"certificateCacheFormat\":\"PEM\",\"refreshTokenPromises\":\"$ec\",\"_clientId\":\"$undefined\",\"_clientSecret\":\"$undefined\",\"redirectUri\":\"$undefined\",\"endpoints\":\"$ee\",\"clientAuthentication\":\"ClientSecretPost\",\"issuers\":\"$ef\",\"email\":\"firebase-adminsdk-fbsvc@resumemaker-b590f.iam.gserviceaccount.com\",\"keyFile\":\"$undefined\",\"key\":\"$Y\",\"keyId\":\"$undefined\",\"scopes\":\"$undefined\",\"subject\":\"$undefined\",\"additionalClaims\":\"$undefined\",\"defaultServicePath\":\"firestore.googleapis.com\",\"useJWTAccessWithScope\":true,\"defaultScopes\":\"$f0\",\"access\":\"$f1\",\"\":\"$Pf7\"}\nf9:{\"scopes\":\"$undefined\"}\ndd:{\"checkIsGCE\":\"$undefined\",\"jsonContent\":\"$8b:credentials\",\"cachedCredential\":\"$de\",\"clientOptions\":\"$f9\",\"_cachedProjectId\":\"resumemaker-b590f\",\"keyFilename\":\"$undefined\",\"scopes\":\"$undefined\",\"apiKey\":null,\"useJWTAccessWithScope\":true,\"defaultServicePath\":\"firestore.googleapis.com\",\"defaultScopes\":\"$f0\",\"\":\"$Pa4\"}\ndc:{\"auth\":\"$dd\",\"fallback\":false,\"grpc\":\"$a3:grpc\",\"grpcVersion\":\"1.13.2\",\"\":\"$Pd1\"}\nfa:{\"servicePath\":\"firestore.googleapis.com\",\"port\":443,\"clientConfig\":\"$Y\",\"fallback\":false,\"credentials\":\"$8b:credentials\",\"projectId\":\"resumemaker-b590f\",\"firebaseVersion\":\"13.2.0\",\"firebaseAdminVersion\":\"13.2.0\",\"preferRest\":\"$undefined\",\"databaseId\":\"(default)\",\"libName\":\"gccl\",\"libVersion\":\"7.11.0 fire/13.2.0 fire-admin/13.2.0\",\"toJSON\":\"$8c\",\"numericEnums\":true,\"universeDomain\":\"googleapis.com\"}\nfc:{\"page\":\"$Y\",\"stream\":\"$Y\",\"longrunning\":\"$Y\",\"batching\":\"$Y\"}\nfd:{\"servicePath\":\"firestore.googleapis.com\",\"port\":443,\"clientConfig\":\"$Y\",\"fallback\":false,\"credentials\":\"$8b:credentials\",\"projectId\":\"resumemaker-b590f\",\"firebaseVersion\":\"13.2.0\",\"firebaseAdminVersion\":\"13.2.0\",\"preferRest\":\"$undefined\",\"databaseId\":\"(default)\",\"libName\":\"gccl\",\"libVersion\":\"7.11.0 fire/13.2.0 fire-admin/13.2.0\",\"toJSON\":\"$8c\",\"numericEnums\":true,\"scopes\":\"$Y\"}\nfe:{\"google\":\"$Y\"}\nff:{\"listLocations\":\"$Y\",\"getLocation\":\"$Y\"}\n100:{}\nfb:{\"_terminated\":false,\"descriptors\":\"$fc\",\"gaxGrpc\":\"$dc\",\"_providedCustomServicePath\":true,\"_opts\":\"$fd\",\"auth\":\"$dd\",\"_protos\":\"$fe\",\"_defaults\":\"$ff\",\"innerApiCalls\":\"$100\",\"warn\":\"$da\",\"\":\"$Pd7\"}\n101:{\"google\":\"$Y\"}\n102:{\"getDocument\":\"$Y\",\"listDocuments\":\"$Y\",\"updateDocument\":\"$Y\",\"deleteDocument\":\"$Y\",\"batchGetDocuments\":\"$Y\",\"beginTransaction\":\"$Y\",\"commit\":\"$Y\",\"rollback\":\"$Y\",\"runQuery\":\"$Y\",\"runAggregationQuery\":\"$Y\",\"partitionQuery\":\"$Y\",\"write\":\"$Y\",\"listen\":\"$Y\",\"listCollectionIds\":\"$Y\",\"batchWrite\":\"$Y\",\"createDocument\":\"$Y\"}\n"])</script><script>self.__next_f.push([1,"104:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"105:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"106:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"107:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"108:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"109:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"10a:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"10b:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"10c:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"10d:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"10e:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"10f:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"110:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"111:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"112:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"113:\"$EObject.defineProperty((request, callOptions, callback) =\u003e {\\n        var _a, _b;\\n        let currentApiCaller = apiCaller;\\n        let thisSettings;\\n        if (currentApiCaller instanceof streamingApiCaller_1.StreamingApiCaller) {\\n            const gaxStreamingRetries = (_b = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.gaxStreamingRetries) !== null \u0026\u0026 _b !== void 0 ? _b : false;\\n            // If Gax streaming retries are enabled, check settings passed at call time and convert parameters if needed\\n            const convertedRetryOptions = (0, gax_1.convertRetryOptions)(callOptions, gaxStreamingRetries);\\n            thisSettings = settings.merge(convertedRetryOptions);\\n        }\\n        else {\\n            thisSettings = settings.merge(callOptions);\\n        }\\n        // special case: if bundling is disabled for this one call,\\n        // use default API caller instead\\n        if (settings.isBundling \u0026\u0026 !thisSettings.isBundling) {\\n            currentApiCaller = (0, apiCaller_1.createAPICaller)(settings, undefined);\\n        }\\n        const ongoingCall = currentApiCaller.init(callback);\\n        funcPromise\\n            .then((func) =\u003e {\\n            var _a, _b;\\n            var _c;\\n            // Initially, the function is just what gRPC server stub contains.\\n            func = currentApiCaller.wrap(func);\\n            const streaming = (_a = currentApiCaller.descriptor) === null || _a === void 0 ? void 0 : _a.streaming;\\n            const retry = thisSettings.retry;\\n            if (streaming \u0026\u0026 retry) {\\n                if (retry.retryCodes.length \u003e 0 \u0026\u0026 retry.shouldRetryFn) {\\n                    (0, warnings_1.warn)('either_retrycodes_or_shouldretryfn', 'Only one of retryCodes or shouldRetryFn may be defined. Ignoring retryCodes.');\\n                    retry.retryCodes = [];\\n                }\\n                if (!currentApiCaller.descriptor\\n                    .gaxStreamingRetries \u0026\u0026\\n                    retry.getResumptionRequestFn) {\\n                    throw new Error('getResumptionRequestFn can only be used when gaxStreamingRetries is set to true.');\\n                }\\n            }\\n            if (!streaming \u0026\u0026 retry) {\\n                if (retry.shouldRetryFn) {\\n                    throw new Error('Using a function to determine retry eligibility is only supported with server streaming calls');\\n                }\\n                if (retry.getResumptionRequestFn) {\\n                    throw new Error('Resumption strategy can only be used with server streaming retries');\\n                }\\n                if (retry.retryCodes \u0026\u0026 retry.retryCodes.length \u003e 0) {\\n                    (_b = (_c = retry.backoffSettings).initialRpcTimeoutMillis) !== null \u0026\u0026 _b !== void 0 ? _b : (_c.initialRpcTimeoutMillis = thisSettings.timeout);\\n                    return (0, retries_1.retryable)(func, thisSettings.retry, thisSettings.otherArgs, thisSettings.apiName);\\n                }\\n            }\\n            return (0, timeout_1.addTimeoutArg)(func, thisSettings.timeout, thisSettings.otherArgs);\\n        })\\n            .then((apiCall) =\u003e {\\n            // After adding retries / timeouts, the call function becomes simpler:\\n            // it only accepts request and callback.\\n            currentApiCaller.call(apiCall, request, thisSettings, ongoingCall);\\n        })\\n            .catch(err =\u003e {\\n            currentApiCaller.fail(ongoingCall, err);\\n        });\\n        // Calls normally return a \\\"cancellable promise\\\" that can be used to `await` for the actual result,\\n        // or to cancel the ongoing call.\\n        return currentApiCaller.result(ongoingCall);\\n    },\\\"name\\\",{value:\\\"\\\"})\"\n"])</script><script>self.__next_f.push([1,"103:{\"getDocument\":\"$104\",\"listDocuments\":\"$105\",\"updateDocument\":\"$106\",\"deleteDocument\":\"$107\",\"batchGetDocuments\":\"$108\",\"beginTransaction\":\"$109\",\"commit\":\"$10a\",\"rollback\":\"$10b\",\"runQuery\":\"$10c\",\"runAggregationQuery\":\"$10d\",\"partitionQuery\":\"$10e\",\"write\":\"$10f\",\"listen\":\"$110\",\"listCollectionIds\":\"$111\",\"batchWrite\":\"$112\",\"createDocument\":\"$113\"}\n"])</script><script>self.__next_f.push([1,"116:\"$EObject.defineProperty(class FirestoreClient {\\n    /**\\n     * Construct an instance of FirestoreClient.\\n     *\\n     * @param {object} [options] - The configuration object.\\n     * The options accepted by the constructor are described in detail\\n     * in [this document](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#creating-the-client-instance).\\n     * The common options are:\\n     * @param {object} [options.credentials] - Credentials object.\\n     * @param {string} [options.credentials.client_email]\\n     * @param {string} [options.credentials.private_key]\\n     * @param {string} [options.email] - Account email address. Required when\\n     *     using a .pem or .p12 keyFilename.\\n     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or\\n     *     .p12 key downloaded from the Google Developers Console. If you provide\\n     *     a path to a JSON file, the projectId option below is not necessary.\\n     *     NOTE: .pem and .p12 require you to specify options.email as well.\\n     * @param {number} [options.port] - The port on which to connect to\\n     *     the remote host.\\n     * @param {string} [options.projectId] - The project ID from the Google\\n     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check\\n     *     the environment variable GCLOUD_PROJECT for your project ID. If your\\n     *     app is running in an environment which supports\\n     *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},\\n     *     your project ID will be detected automatically.\\n     * @param {string} [options.apiEndpoint] - The domain name of the\\n     *     API remote host.\\n     * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.\\n     *     Follows the structure of {@link gapicConfig}.\\n     * @param {boolean} [options.fallback] - Use HTTP/1.1 REST mode.\\n     *     For more information, please check the\\n     *     {@link https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#http11-rest-api-mode documentation}.\\n     * @param {gax} [gaxInstance]: loaded instance of `google-gax`. Useful if you\\n     *     need to avoid loading the default gRPC version and want to use the fallback\\n     *     HTTP implementation. Load only fallback version and pass it to the constructor:\\n     *     ```\\n     *     const gax = require('google-gax/build/src/fallback'); // avoids loading google-gax with gRPC\\n     *     const client = new FirestoreClient({fallback: true}, gax);\\n     *     ```\\n     */\\n    constructor(opts, gaxInstance) {\\n        var _a, _b, _c, _d, _e;\\n        this._terminated = false;\\n        this.descriptors = {\\n            page: {},\\n            stream: {},\\n            longrunning: {},\\n            batching: {},\\n        };\\n        // Ensure that options include all the required fields.\\n        const staticMembers = this.constructor;\\n        if ((opts === null || opts === void 0 ? void 0 : opts.universe_domain) \u0026\u0026\\n            (opts === null || opts === void 0 ? void 0 : opts.universeDomain) \u0026\u0026\\n            (opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== (opts === null || opts === void 0 ? void 0 : opts.universeDomain)) {\\n            throw new Error('Please set either universe_domain or universeDomain, but not both.');\\n        }\\n        const universeDomainEnvVar = typeof process === 'object' \u0026\u0026 typeof process.env === 'object'\\n            ? process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN']\\n            : undefined;\\n        this._universeDomain =\\n            (_c = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.universeDomain) !== null \u0026\u0026 _a !== void 0 ? _a : opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== null \u0026\u0026 _b !== void 0 ? _b : universeDomainEnvVar) !== null \u0026\u0026 _c !== void 0 ? _c : 'googleapis.com';\\n        this._servicePath = 'firestore.' + this._universeDomain;\\n        const servicePath = (opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint) || this._servicePath;\\n        this._providedCustomServicePath = !!((opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint));\\n        const port = (opts === null || opts === void 0 ? void 0 : opts.port) || staticMembers.port;\\n        const clientConfig = (_d = opts === null || opts === void 0 ? void 0 : opts.clientConfig) !== null \u0026\u0026 _d !== void 0 ? _d : {};\\n        const fallback = (_e = opts === null || opts === void 0 ? void 0 : opts.fallback) !== null \u0026\u0026 _e !== void 0 ? _e : (typeof window !== 'undefined' \u0026\u0026 typeof (window === null || window === void 0 ? void 0 : window.fetch) === 'function');\\n        opts = Object.assign({ servicePath, port, clientConfig, fallback }, opts);\\n        // Request numeric enum values if REST transport is used.\\n        opts.numericEnums = true;\\n        // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.\\n        if (servicePath !== this._servicePath \u0026\u0026 !('scopes' in opts)) {\\n            opts['scopes'] = staticMembers.scopes;\\n        }\\n        // Load google-gax module synchronously if needed\\n        if (!gaxInstance) {\\n            gaxInstance = require('google-gax');\\n        }\\n        // Choose either gRPC or proto-over-HTTP implementation of google-gax.\\n        this._gaxModule = opts.fallback ? gaxInstance.fallback : gaxInstance;\\n        // Create a `gaxGrpc` object, with any grpc-specific options sent to the client.\\n        this._gaxGrpc = new this._gaxModule.GrpcClient(opts);\\n        // Save options to use in initialize() method.\\n        this._opts = opts;\\n        // Save the auth object to the client, for use by other methods.\\n        this.auth = this._gaxGrpc.auth;\\n        // Set useJWTAccessWithScope on the auth object.\\n        this.auth.useJWTAccessWithScope = true;\\n        // Set defaultServicePath on the auth object.\\n        this.auth.defaultServicePath = this._servicePath;\\n        // Set the default scopes in auth client if needed.\\n        if (servicePath === this._servicePath) {\\n            this.auth.defaultScopes = staticMembers.scopes;\\n        }\\n        this.locationsClient = new this._gaxModule.LocationsClient(this._gaxGrpc, opts);\\n        // Determine the client header string.\\n        const clientHeader = [`gax/${this._gaxModule.version}`, `gapic/${version}`];\\n        if (typeof process === 'object' \u0026\u0026 'versions' in process) {\\n            clientHeader.push(`gl-node/${process.versions.node}`);\\n        }\\n        else {\\n            clientHeader.push(`gl-web/${this._gaxModule.version}`);\\n        }\\n        if (!opts.fallback) {\\n            clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);\\n        }\\n        else {\\n            clientHeader.push(`rest/${this._gaxGrpc.grpcVersion}`);\\n        }\\n        if (opts.libName \u0026\u0026 opts.libVersion) {\\n            clientHeader.push(`${opts.libName}/${opts.libVersion}`);\\n        }\\n        // Load the applicable protos.\\n        this._protos = this._gaxGrpc.loadProtoJSON(jsonProtos);\\n        // Some of the methods on this service return \\\"paged\\\" results,\\n        // (e.g. 50 results at a time, with tokens to get subsequent\\n        // pages). Denote the keys used for pagination and results.\\n        this.descriptors.page = {\\n            listDocuments: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'documents'),\\n            partitionQuery: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'partitions'),\\n            listCollectionIds: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'collectionIds'),\\n        };\\n        // Some of the methods on this service provide streaming responses.\\n        // Provide descriptors for these.\\n        this.descriptors.stream = {\\n            batchGetDocuments: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.SERVER_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries),\\n            runQuery: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.SERVER_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries),\\n            runAggregationQuery: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.SERVER_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries),\\n            write: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.BIDI_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries),\\n            listen: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.BIDI_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries),\\n        };\\n        // Put together the default options sent with requests.\\n        this._defaults = this._gaxGrpc.constructSettings('google.firestore.v1.Firestore', gapicConfig, opts.clientConfig || {}, { 'x-goog-api-client': clientHeader.join(' ') });\\n        // Set up a dictionary of \\\"inner API calls\\\"; the core implementation\\n        // of calling the API is handled in `google-gax`, with this code\\n        // merely providing the destination and request information.\\n        this.innerApiCalls = {};\\n        // Add a warn function to the client constructor so it can be easily tested.\\n        this.warn = this._gaxModule.warn;\\n    }\\n    /**\\n     * Initialize the client.\\n     * Performs asynchronous operations (such as authentication) and prepares the client.\\n     * This function will be called automatically when any class method is called for the\\n     * first time, but if you need to initialize it before calling an actual method,\\n     * feel free to call initialize() directly.\\n     *\\n     * You can await on this method if you want to make sure the client is initialized.\\n     *\\n     * @returns {Promise} A promise that resolves to an authenticated service stub.\\n     */\\n    initialize() {\\n        // If the client stub promise is already initialized, return immediately.\\n        if (this.firestoreStub) {\\n            return this.firestoreStub;\\n        }\\n        // Put together the \\\"service stub\\\" for\\n        // google.firestore.v1.Firestore.\\n        this.firestoreStub = this._gaxGrpc.createStub(this._opts.fallback\\n            ? this._protos.lookupService('google.firestore.v1.Firestore')\\n            : // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n                this._protos.google.firestore.v1.Firestore, this._opts, this._providedCustomServicePath);\\n        // Iterate over each of the methods that the service provides\\n        // and create an API call method for each.\\n        const firestoreStubMethods = [\\n            'getDocument',\\n            'listDocuments',\\n            'updateDocument',\\n            'deleteDocument',\\n            'batchGetDocuments',\\n            'beginTransaction',\\n            'commit',\\n            'rollback',\\n            'runQuery',\\n            'runAggregationQuery',\\n            'partitionQuery',\\n            'write',\\n            'listen',\\n            'listCollectionIds',\\n            'batchWrite',\\n            'createDocument',\\n        ];\\n        for (const methodName of firestoreStubMethods) {\\n            const callPromise = this.firestoreStub.then(stub =\u003e (...args) =\u003e {\\n                if (this._terminated) {\\n                    if (methodName in this.descriptors.stream) {\\n                        const stream = new stream_1.PassThrough();\\n                        setImmediate(() =\u003e {\\n                            stream.emit('error', new this._gaxModule.GoogleError('The client has already been closed.'));\\n                        });\\n                        return stream;\\n                    }\\n                    return Promise.reject('The client has already been closed.');\\n                }\\n                const func = stub[methodName];\\n                return func.apply(stub, args);\\n            }, (err) =\u003e () =\u003e {\\n                throw err;\\n            });\\n            const descriptor = this.descriptors.page[methodName] ||\\n                this.descriptors.stream[methodName] ||\\n                undefined;\\n            const apiCall = this._gaxModule.createApiCall(callPromise, this._defaults[methodName], descriptor, this._opts.fallback);\\n            this.innerApiCalls[methodName] = apiCall;\\n        }\\n        return this.firestoreStub;\\n    }\\n    /**\\n     * The DNS address for this API service.\\n     * @deprecated Use the apiEndpoint method of the client instance.\\n     * @returns {string} The DNS address for this service.\\n     */\\n    static get servicePath() {\\n        if (typeof process === 'object' \u0026\u0026\\n            typeof process.emitWarning === 'function') {\\n            process.emitWarning('Static servicePath is deprecated, please use the instance method instead.', 'DeprecationWarning');\\n        }\\n        return 'firestore.googleapis.com';\\n    }\\n    /**\\n     * The DNS address for this API service - same as servicePath.\\n     * @deprecated Use the apiEndpoint method of the client instance.\\n     * @returns {string} The DNS address for this service.\\n     */\\n    static get apiEndpoint() {\\n        if (typeof process === 'object' \u0026\u0026\\n            typeof process.emitWarning === 'function') {\\n            process.emitWarning('Static apiEndpoint is deprecated, please use the instance method instead.', 'DeprecationWarning');\\n        }\\n        return 'firestore.googleapis.com';\\n    }\\n    /**\\n     * The DNS address for this API service.\\n     * @returns {string} The DNS address for this service.\\n     */\\n    get apiEndpoint() {\\n        return this._servicePath;\\n    }\\n    get universeDomain() {\\n        return this._universeDomain;\\n    }\\n    /**\\n     * The port for this API service.\\n     * @returns {number} The default port for this service.\\n     */\\n    static get port() {\\n        return 443;\\n    }\\n    /**\\n     * The scopes needed to make gRPC calls for every method defined\\n     * in this service.\\n     * @returns {string[]} List of default scopes.\\n     */\\n    static get scopes() {\\n        return [\\n            'https://www.googleapis.com/auth/cloud-platform',\\n            'https://www.googleapis.com/auth/datastore',\\n        ];\\n    }\\n    /**\\n     * Return the project ID used by this class.\\n     * @returns {Promise} A promise that resolves to string containing the project ID.\\n     */\\n    getProjectId(callback) {\\n        if (callback) {\\n            this.auth.getProjectId(callback);\\n            return;\\n        }\\n        return this.auth.getProjectId();\\n    }\\n    getDocument(request, optionsOrCallback, callback) {\\n        var _a;\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                name: (_a = request.name) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.getDocument(request, options, callback);\\n    }\\n    updateDocument(request, optionsOrCallback, callback) {\\n        var _a;\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                'document.name': (_a = request.document.name) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.updateDocument(request, options, callback);\\n    }\\n    deleteDocument(request, optionsOrCallback, callback) {\\n        var _a;\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                name: (_a = request.name) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.deleteDocument(request, options, callback);\\n    }\\n    beginTransaction(request, optionsOrCallback, callback) {\\n        var _a;\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                database: (_a = request.database) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.beginTransaction(request, options, callback);\\n    }\\n    commit(request, optionsOrCallback, callback) {\\n        var _a;\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                database: (_a = request.database) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.commit(request, options, callback);\\n    }\\n    rollback(request, optionsOrCallback, callback) {\\n        var _a;\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                database: (_a = request.database) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.rollback(request, options, callback);\\n    }\\n    batchWrite(request, optionsOrCallback, callback) {\\n        var _a;\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                database: (_a = request.database) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.batchWrite(request, options, callback);\\n    }\\n    createDocument(request, optionsOrCallback, callback) {\\n        var _a, _b;\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                parent: (_a = request.parent) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n                collection_id: (_b = request.collectionId) !== null \u0026\u0026 _b !== void 0 ? _b : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.createDocument(request, options, callback);\\n    }\\n    /**\\n     * Gets multiple documents.\\n     *\\n     * Documents returned by this method are not guaranteed to be returned in the\\n     * same order that they were requested.\\n     *\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.database\\n     *   Required. The database name. In the format:\\n     *   `projects/{project_id}/databases/{database_id}`.\\n     * @param {string[]} request.documents\\n     *   The names of the documents to retrieve. In the format:\\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\\n     *   The request will fail if any of the document is not a child resource of the\\n     *   given `database`. Duplicate names will be elided.\\n     * @param {google.firestore.v1.DocumentMask} request.mask\\n     *   The fields to return. If not set, returns all fields.\\n     *\\n     *   If a document has a field that is not present in this mask, that field will\\n     *   not be returned in the response.\\n     * @param {Buffer} request.transaction\\n     *   Reads documents in a transaction.\\n     * @param {google.firestore.v1.TransactionOptions} request.newTransaction\\n     *   Starts a new transaction and reads the documents.\\n     *   Defaults to a read-only transaction.\\n     *   The new transaction ID will be returned as the first response in the\\n     *   stream.\\n     * @param {google.protobuf.Timestamp} request.readTime\\n     *   Reads documents as they were at the given time.\\n     *\\n     *   This must be a microsecond precision timestamp within the past one hour,\\n     *   or if Point-in-Time Recovery is enabled, can additionally be a whole\\n     *   minute timestamp within the past 7 days.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Stream}\\n     *   An object stream which emits {@link protos.google.firestore.v1.BatchGetDocumentsResponse|BatchGetDocumentsResponse} on 'data' event.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#server-streaming | documentation }\\n     *   for more details and examples.\\n     * @example \u003ccaption\u003einclude:samples/generated/v1/firestore.batch_get_documents.js\u003c/caption\u003e\\n     * region_tag:firestore_v1_generated_Firestore_BatchGetDocuments_async\\n     */\\n    batchGetDocuments(request, options) {\\n        var _a;\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                database: (_a = request.database) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.batchGetDocuments(request, options);\\n    }\\n    /**\\n     * Runs a query.\\n     *\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.parent\\n     *   Required. The parent resource name. In the format:\\n     *   `projects/{project_id}/databases/{database_id}/documents` or\\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\\n     *   For example:\\n     *   `projects/my-project/databases/my-database/documents` or\\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\\n     * @param {google.firestore.v1.StructuredQuery} request.structuredQuery\\n     *   A structured query.\\n     * @param {Buffer} request.transaction\\n     *   Run the query within an already active transaction.\\n     *\\n     *   The value here is the opaque transaction ID to execute the query in.\\n     * @param {google.firestore.v1.TransactionOptions} request.newTransaction\\n     *   Starts a new transaction and reads the documents.\\n     *   Defaults to a read-only transaction.\\n     *   The new transaction ID will be returned as the first response in the\\n     *   stream.\\n     * @param {google.protobuf.Timestamp} request.readTime\\n     *   Reads documents as they were at the given time.\\n     *\\n     *   This must be a microsecond precision timestamp within the past one hour,\\n     *   or if Point-in-Time Recovery is enabled, can additionally be a whole\\n     *   minute timestamp within the past 7 days.\\n     * @param {google.firestore.v1.ExplainOptions} [request.explainOptions]\\n     *   Optional. Explain options for the query. If set, additional query\\n     *   statistics will be returned. If not, only query results will be returned.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Stream}\\n     *   An object stream which emits {@link protos.google.firestore.v1.RunQueryResponse|RunQueryResponse} on 'data' event.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#server-streaming | documentation }\\n     *   for more details and examples.\\n     * @example \u003ccaption\u003einclude:samples/generated/v1/firestore.run_query.js\u003c/caption\u003e\\n     * region_tag:firestore_v1_generated_Firestore_RunQuery_async\\n     */\\n    runQuery(request, options) {\\n        var _a;\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                parent: (_a = request.parent) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.runQuery(request, options);\\n    }\\n    /**\\n     * Runs an aggregation query.\\n     *\\n     * Rather than producing {@link protos.google.firestore.v1.Document|Document} results like\\n     * {@link protos.google.firestore.v1.Firestore.RunQuery|Firestore.RunQuery}, this API\\n     * allows running an aggregation to produce a series of\\n     * {@link protos.google.firestore.v1.AggregationResult|AggregationResult} server-side.\\n     *\\n     * High-Level Example:\\n     *\\n     * ```\\n     * -- Return the number of documents in table given a filter.\\n     * SELECT COUNT(*) FROM ( SELECT * FROM k where a = true );\\n     * ```\\n     *\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.parent\\n     *   Required. The parent resource name. In the format:\\n     *   `projects/{project_id}/databases/{database_id}/documents` or\\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\\n     *   For example:\\n     *   `projects/my-project/databases/my-database/documents` or\\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\\n     * @param {google.firestore.v1.StructuredAggregationQuery} request.structuredAggregationQuery\\n     *   An aggregation query.\\n     * @param {Buffer} request.transaction\\n     *   Run the aggregation within an already active transaction.\\n     *\\n     *   The value here is the opaque transaction ID to execute the query in.\\n     * @param {google.firestore.v1.TransactionOptions} request.newTransaction\\n     *   Starts a new transaction as part of the query, defaulting to read-only.\\n     *\\n     *   The new transaction ID will be returned as the first response in the\\n     *   stream.\\n     * @param {google.protobuf.Timestamp} request.readTime\\n     *   Executes the query at the given timestamp.\\n     *\\n     *   This must be a microsecond precision timestamp within the past one hour,\\n     *   or if Point-in-Time Recovery is enabled, can additionally be a whole\\n     *   minute timestamp within the past 7 days.\\n     * @param {google.firestore.v1.ExplainOptions} [request.explainOptions]\\n     *   Optional. Explain options for the query. If set, additional query\\n     *   statistics will be returned. If not, only query results will be returned.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Stream}\\n     *   An object stream which emits {@link protos.google.firestore.v1.RunAggregationQueryResponse|RunAggregationQueryResponse} on 'data' event.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#server-streaming | documentation }\\n     *   for more details and examples.\\n     * @example \u003ccaption\u003einclude:samples/generated/v1/firestore.run_aggregation_query.js\u003c/caption\u003e\\n     * region_tag:firestore_v1_generated_Firestore_RunAggregationQuery_async\\n     */\\n    runAggregationQuery(request, options) {\\n        var _a;\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                parent: (_a = request.parent) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.runAggregationQuery(request, options);\\n    }\\n    /**\\n     * Streams batches of document updates and deletes, in order. This method is\\n     * only available via gRPC or WebChannel (not REST).\\n     *\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Stream}\\n     *   An object stream which is both readable and writable. It accepts objects\\n     *   representing {@link protos.google.firestore.v1.WriteRequest|WriteRequest} for write() method, and\\n     *   will emit objects representing {@link protos.google.firestore.v1.WriteResponse|WriteResponse} on 'data' event asynchronously.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#bi-directional-streaming | documentation }\\n     *   for more details and examples.\\n     * @example \u003ccaption\u003einclude:samples/generated/v1/firestore.write.js\u003c/caption\u003e\\n     * region_tag:firestore_v1_generated_Firestore_Write_async\\n     */\\n    write(options) {\\n        this.initialize();\\n        return this.innerApiCalls.write(null, options);\\n    }\\n    /**\\n     * Listens to changes. This method is only available via gRPC or WebChannel\\n     * (not REST).\\n     *\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Stream}\\n     *   An object stream which is both readable and writable. It accepts objects\\n     *   representing {@link protos.google.firestore.v1.ListenRequest|ListenRequest} for write() method, and\\n     *   will emit objects representing {@link protos.google.firestore.v1.ListenResponse|ListenResponse} on 'data' event asynchronously.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#bi-directional-streaming | documentation }\\n     *   for more details and examples.\\n     * @example \u003ccaption\u003einclude:samples/generated/v1/firestore.listen.js\u003c/caption\u003e\\n     * region_tag:firestore_v1_generated_Firestore_Listen_async\\n     */\\n    listen(options) {\\n        this.initialize();\\n        return this.innerApiCalls.listen(null, options);\\n    }\\n    listDocuments(request, optionsOrCallback, callback) {\\n        var _a, _b;\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                parent: (_a = request.parent) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n                collection_id: (_b = request.collectionId) !== null \u0026\u0026 _b !== void 0 ? _b : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.listDocuments(request, options, callback);\\n    }\\n    /**\\n     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.parent\\n     *   Required. The parent resource name. In the format:\\n     *   `projects/{project_id}/databases/{database_id}/documents` or\\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\\n     *\\n     *   For example:\\n     *   `projects/my-project/databases/my-database/documents` or\\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\\n     * @param {string} [request.collectionId]\\n     *   Optional. The collection ID, relative to `parent`, to list.\\n     *\\n     *   For example: `chatrooms` or `messages`.\\n     *\\n     *   This is optional, and when not provided, Firestore will list documents\\n     *   from all collections under the provided `parent`.\\n     * @param {number} [request.pageSize]\\n     *   Optional. The maximum number of documents to return in a single response.\\n     *\\n     *   Firestore may return fewer than this value.\\n     * @param {string} [request.pageToken]\\n     *   Optional. A page token, received from a previous `ListDocuments` response.\\n     *\\n     *   Provide this to retrieve the subsequent page. When paginating, all other\\n     *   parameters (with the exception of `page_size`) must match the values set\\n     *   in the request that generated the page token.\\n     * @param {string} [request.orderBy]\\n     *   Optional. The optional ordering of the documents to return.\\n     *\\n     *   For example: `priority desc, __name__ desc`.\\n     *\\n     *   This mirrors the {@link protos.google.firestore.v1.StructuredQuery.order_by|`ORDER BY`}\\n     *   used in Firestore queries but in a string representation. When absent,\\n     *   documents are ordered based on `__name__ ASC`.\\n     * @param {google.firestore.v1.DocumentMask} [request.mask]\\n     *   Optional. The fields to return. If not set, returns all fields.\\n     *\\n     *   If a document has a field that is not present in this mask, that field\\n     *   will not be returned in the response.\\n     * @param {Buffer} request.transaction\\n     *   Perform the read as part of an already active transaction.\\n     * @param {google.protobuf.Timestamp} request.readTime\\n     *   Perform the read at the provided time.\\n     *\\n     *   This must be a microsecond precision timestamp within the past one hour,\\n     *   or if Point-in-Time Recovery is enabled, can additionally be a whole\\n     *   minute timestamp within the past 7 days.\\n     * @param {boolean} request.showMissing\\n     *   If the list should show missing documents.\\n     *\\n     *   A document is missing if it does not exist, but there are sub-documents\\n     *   nested underneath it. When true, such missing documents will be returned\\n     *   with a key but will not have fields,\\n     *   {@link protos.google.firestore.v1.Document.create_time|`create_time`}, or\\n     *   {@link protos.google.firestore.v1.Document.update_time|`update_time`} set.\\n     *\\n     *   Requests with `show_missing` may not specify `where` or `order_by`.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Stream}\\n     *   An object stream which emits an object representing {@link protos.google.firestore.v1.Document|Document} on 'data' event.\\n     *   The client library will perform auto-pagination by default: it will call the API as many\\n     *   times as needed. Note that it can affect your quota.\\n     *   We recommend using `listDocumentsAsync()`\\n     *   method described below for async iteration which you can stop as needed.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }\\n     *   for more details and examples.\\n     */\\n    listDocumentsStream(request, options) {\\n        var _a, _b;\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                parent: (_a = request.parent) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n                collection_id: (_b = request.collectionId) !== null \u0026\u0026 _b !== void 0 ? _b : '',\\n            });\\n        const defaultCallSettings = this._defaults['listDocuments'];\\n        const callSettings = defaultCallSettings.merge(options);\\n        this.initialize();\\n        return this.descriptors.page.listDocuments.createStream(this.innerApiCalls.listDocuments, request, callSettings);\\n    }\\n    /**\\n     * Equivalent to `listDocuments`, but returns an iterable object.\\n     *\\n     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.parent\\n     *   Required. The parent resource name. In the format:\\n     *   `projects/{project_id}/databases/{database_id}/documents` or\\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\\n     *\\n     *   For example:\\n     *   `projects/my-project/databases/my-database/documents` or\\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\\n     * @param {string} [request.collectionId]\\n     *   Optional. The collection ID, relative to `parent`, to list.\\n     *\\n     *   For example: `chatrooms` or `messages`.\\n     *\\n     *   This is optional, and when not provided, Firestore will list documents\\n     *   from all collections under the provided `parent`.\\n     * @param {number} [request.pageSize]\\n     *   Optional. The maximum number of documents to return in a single response.\\n     *\\n     *   Firestore may return fewer than this value.\\n     * @param {string} [request.pageToken]\\n     *   Optional. A page token, received from a previous `ListDocuments` response.\\n     *\\n     *   Provide this to retrieve the subsequent page. When paginating, all other\\n     *   parameters (with the exception of `page_size`) must match the values set\\n     *   in the request that generated the page token.\\n     * @param {string} [request.orderBy]\\n     *   Optional. The optional ordering of the documents to return.\\n     *\\n     *   For example: `priority desc, __name__ desc`.\\n     *\\n     *   This mirrors the {@link protos.google.firestore.v1.StructuredQuery.order_by|`ORDER BY`}\\n     *   used in Firestore queries but in a string representation. When absent,\\n     *   documents are ordered based on `__name__ ASC`.\\n     * @param {google.firestore.v1.DocumentMask} [request.mask]\\n     *   Optional. The fields to return. If not set, returns all fields.\\n     *\\n     *   If a document has a field that is not present in this mask, that field\\n     *   will not be returned in the response.\\n     * @param {Buffer} request.transaction\\n     *   Perform the read as part of an already active transaction.\\n     * @param {google.protobuf.Timestamp} request.readTime\\n     *   Perform the read at the provided time.\\n     *\\n     *   This must be a microsecond precision timestamp within the past one hour,\\n     *   or if Point-in-Time Recovery is enabled, can additionally be a whole\\n     *   minute timestamp within the past 7 days.\\n     * @param {boolean} request.showMissing\\n     *   If the list should show missing documents.\\n     *\\n     *   A document is missing if it does not exist, but there are sub-documents\\n     *   nested underneath it. When true, such missing documents will be returned\\n     *   with a key but will not have fields,\\n     *   {@link protos.google.firestore.v1.Document.create_time|`create_time`}, or\\n     *   {@link protos.google.firestore.v1.Document.update_time|`update_time`} set.\\n     *\\n     *   Requests with `show_missing` may not specify `where` or `order_by`.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Object}\\n     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.\\n     *   When you iterate the returned iterable, each element will be an object representing\\n     *   {@link protos.google.firestore.v1.Document|Document}. The API will be called under the hood as needed, once per the page,\\n     *   so you can stop the iteration when you don't need more results.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }\\n     *   for more details and examples.\\n     * @example \u003ccaption\u003einclude:samples/generated/v1/firestore.list_documents.js\u003c/caption\u003e\\n     * region_tag:firestore_v1_generated_Firestore_ListDocuments_async\\n     */\\n    listDocumentsAsync(request, options) {\\n        var _a, _b;\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                parent: (_a = request.parent) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n                collection_id: (_b = request.collectionId) !== null \u0026\u0026 _b !== void 0 ? _b : '',\\n            });\\n        const defaultCallSettings = this._defaults['listDocuments'];\\n        const callSettings = defaultCallSettings.merge(options);\\n        this.initialize();\\n        return this.descriptors.page.listDocuments.asyncIterate(this.innerApiCalls['listDocuments'], request, callSettings);\\n    }\\n    partitionQuery(request, optionsOrCallback, callback) {\\n        var _a;\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                parent: (_a = request.parent) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.partitionQuery(request, options, callback);\\n    }\\n    /**\\n     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.parent\\n     *   Required. The parent resource name. In the format:\\n     *   `projects/{project_id}/databases/{database_id}/documents`.\\n     *   Document resource names are not supported; only database resource names\\n     *   can be specified.\\n     * @param {google.firestore.v1.StructuredQuery} request.structuredQuery\\n     *   A structured query.\\n     *   Query must specify collection with all descendants and be ordered by name\\n     *   ascending. Other filters, order bys, limits, offsets, and start/end\\n     *   cursors are not supported.\\n     * @param {number} request.partitionCount\\n     *   The desired maximum number of partition points.\\n     *   The partitions may be returned across multiple pages of results.\\n     *   The number must be positive. The actual number of partitions\\n     *   returned may be fewer.\\n     *\\n     *   For example, this may be set to one fewer than the number of parallel\\n     *   queries to be run, or in running a data pipeline job, one fewer than the\\n     *   number of workers or compute instances available.\\n     * @param {string} request.pageToken\\n     *   The `next_page_token` value returned from a previous call to\\n     *   PartitionQuery that may be used to get an additional set of results.\\n     *   There are no ordering guarantees between sets of results. Thus, using\\n     *   multiple sets of results will require merging the different result sets.\\n     *\\n     *   For example, two subsequent calls using a page_token may return:\\n     *\\n     *    * cursor B, cursor M, cursor Q\\n     *    * cursor A, cursor U, cursor W\\n     *\\n     *   To obtain a complete result set ordered with respect to the results of the\\n     *   query supplied to PartitionQuery, the results sets should be merged:\\n     *   cursor A, cursor B, cursor M, cursor Q, cursor U, cursor W\\n     * @param {number} request.pageSize\\n     *   The maximum number of partitions to return in this call, subject to\\n     *   `partition_count`.\\n     *\\n     *   For example, if `partition_count` = 10 and `page_size` = 8, the first call\\n     *   to PartitionQuery will return up to 8 partitions and a `next_page_token`\\n     *   if more results exist. A second call to PartitionQuery will return up to\\n     *   2 partitions, to complete the total of 10 specified in `partition_count`.\\n     * @param {google.protobuf.Timestamp} request.readTime\\n     *   Reads documents as they were at the given time.\\n     *\\n     *   This must be a microsecond precision timestamp within the past one hour,\\n     *   or if Point-in-Time Recovery is enabled, can additionally be a whole\\n     *   minute timestamp within the past 7 days.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Stream}\\n     *   An object stream which emits an object representing {@link protos.google.firestore.v1.Cursor|Cursor} on 'data' event.\\n     *   The client library will perform auto-pagination by default: it will call the API as many\\n     *   times as needed. Note that it can affect your quota.\\n     *   We recommend using `partitionQueryAsync()`\\n     *   method described below for async iteration which you can stop as needed.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }\\n     *   for more details and examples.\\n     */\\n    partitionQueryStream(request, options) {\\n        var _a;\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                parent: (_a = request.parent) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        const defaultCallSettings = this._defaults['partitionQuery'];\\n        const callSettings = defaultCallSettings.merge(options);\\n        this.initialize();\\n        return this.descriptors.page.partitionQuery.createStream(this.innerApiCalls.partitionQuery, request, callSettings);\\n    }\\n    /**\\n     * Equivalent to `partitionQuery`, but returns an iterable object.\\n     *\\n     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.parent\\n     *   Required. The parent resource name. In the format:\\n     *   `projects/{project_id}/databases/{database_id}/documents`.\\n     *   Document resource names are not supported; only database resource names\\n     *   can be specified.\\n     * @param {google.firestore.v1.StructuredQuery} request.structuredQuery\\n     *   A structured query.\\n     *   Query must specify collection with all descendants and be ordered by name\\n     *   ascending. Other filters, order bys, limits, offsets, and start/end\\n     *   cursors are not supported.\\n     * @param {number} request.partitionCount\\n     *   The desired maximum number of partition points.\\n     *   The partitions may be returned across multiple pages of results.\\n     *   The number must be positive. The actual number of partitions\\n     *   returned may be fewer.\\n     *\\n     *   For example, this may be set to one fewer than the number of parallel\\n     *   queries to be run, or in running a data pipeline job, one fewer than the\\n     *   number of workers or compute instances available.\\n     * @param {string} request.pageToken\\n     *   The `next_page_token` value returned from a previous call to\\n     *   PartitionQuery that may be used to get an additional set of results.\\n     *   There are no ordering guarantees between sets of results. Thus, using\\n     *   multiple sets of results will require merging the different result sets.\\n     *\\n     *   For example, two subsequent calls using a page_token may return:\\n     *\\n     *    * cursor B, cursor M, cursor Q\\n     *    * cursor A, cursor U, cursor W\\n     *\\n     *   To obtain a complete result set ordered with respect to the results of the\\n     *   query supplied to PartitionQuery, the results sets should be merged:\\n     *   cursor A, cursor B, cursor M, cursor Q, cursor U, cursor W\\n     * @param {number} request.pageSize\\n     *   The maximum number of partitions to return in this call, subject to\\n     *   `partition_count`.\\n     *\\n     *   For example, if `partition_count` = 10 and `page_size` = 8, the first call\\n     *   to PartitionQuery will return up to 8 partitions and a `next_page_token`\\n     *   if more results exist. A second call to PartitionQuery will return up to\\n     *   2 partitions, to complete the total of 10 specified in `partition_count`.\\n     * @param {google.protobuf.Timestamp} request.readTime\\n     *   Reads documents as they were at the given time.\\n     *\\n     *   This must be a microsecond precision timestamp within the past one hour,\\n     *   or if Point-in-Time Recovery is enabled, can additionally be a whole\\n     *   minute timestamp within the past 7 days.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Object}\\n     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.\\n     *   When you iterate the returned iterable, each element will be an object representing\\n     *   {@link protos.google.firestore.v1.Cursor|Cursor}. The API will be called under the hood as needed, once per the page,\\n     *   so you can stop the iteration when you don't need more results.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }\\n     *   for more details and examples.\\n     * @example \u003ccaption\u003einclude:samples/generated/v1/firestore.partition_query.js\u003c/caption\u003e\\n     * region_tag:firestore_v1_generated_Firestore_PartitionQuery_async\\n     */\\n    partitionQueryAsync(request, options) {\\n        var _a;\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                parent: (_a = request.parent) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        const defaultCallSettings = this._defaults['partitionQuery'];\\n        const callSettings = defaultCallSettings.merge(options);\\n        this.initialize();\\n        return this.descriptors.page.partitionQuery.asyncIterate(this.innerApiCalls['partitionQuery'], request, callSettings);\\n    }\\n    listCollectionIds(request, optionsOrCallback, callback) {\\n        var _a;\\n        request = request || {};\\n        let options;\\n        if (typeof optionsOrCallback === 'function' \u0026\u0026 callback === undefined) {\\n            callback = optionsOrCallback;\\n            options = {};\\n        }\\n        else {\\n            options = optionsOrCallback;\\n        }\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                parent: (_a = request.parent) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        this.initialize();\\n        return this.innerApiCalls.listCollectionIds(request, options, callback);\\n    }\\n    /**\\n     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.parent\\n     *   Required. The parent document. In the format:\\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\\n     *   For example:\\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\\n     * @param {number} request.pageSize\\n     *   The maximum number of results to return.\\n     * @param {string} request.pageToken\\n     *   A page token. Must be a value from\\n     *   {@link protos.google.firestore.v1.ListCollectionIdsResponse|ListCollectionIdsResponse}.\\n     * @param {google.protobuf.Timestamp} request.readTime\\n     *   Reads documents as they were at the given time.\\n     *\\n     *   This must be a microsecond precision timestamp within the past one hour,\\n     *   or if Point-in-Time Recovery is enabled, can additionally be a whole\\n     *   minute timestamp within the past 7 days.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Stream}\\n     *   An object stream which emits an object representing string on 'data' event.\\n     *   The client library will perform auto-pagination by default: it will call the API as many\\n     *   times as needed. Note that it can affect your quota.\\n     *   We recommend using `listCollectionIdsAsync()`\\n     *   method described below for async iteration which you can stop as needed.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }\\n     *   for more details and examples.\\n     */\\n    listCollectionIdsStream(request, options) {\\n        var _a;\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                parent: (_a = request.parent) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        const defaultCallSettings = this._defaults['listCollectionIds'];\\n        const callSettings = defaultCallSettings.merge(options);\\n        this.initialize();\\n        return this.descriptors.page.listCollectionIds.createStream(this.innerApiCalls.listCollectionIds, request, callSettings);\\n    }\\n    /**\\n     * Equivalent to `listCollectionIds`, but returns an iterable object.\\n     *\\n     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.parent\\n     *   Required. The parent document. In the format:\\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\\n     *   For example:\\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\\n     * @param {number} request.pageSize\\n     *   The maximum number of results to return.\\n     * @param {string} request.pageToken\\n     *   A page token. Must be a value from\\n     *   {@link protos.google.firestore.v1.ListCollectionIdsResponse|ListCollectionIdsResponse}.\\n     * @param {google.protobuf.Timestamp} request.readTime\\n     *   Reads documents as they were at the given time.\\n     *\\n     *   This must be a microsecond precision timestamp within the past one hour,\\n     *   or if Point-in-Time Recovery is enabled, can additionally be a whole\\n     *   minute timestamp within the past 7 days.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Object}\\n     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.\\n     *   When you iterate the returned iterable, each element will be an object representing\\n     *   string. The API will be called under the hood as needed, once per the page,\\n     *   so you can stop the iteration when you don't need more results.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }\\n     *   for more details and examples.\\n     * @example \u003ccaption\u003einclude:samples/generated/v1/firestore.list_collection_ids.js\u003c/caption\u003e\\n     * region_tag:firestore_v1_generated_Firestore_ListCollectionIds_async\\n     */\\n    listCollectionIdsAsync(request, options) {\\n        var _a;\\n        request = request || {};\\n        options = options || {};\\n        options.otherArgs = options.otherArgs || {};\\n        options.otherArgs.headers = options.otherArgs.headers || {};\\n        options.otherArgs.headers['x-goog-request-params'] =\\n            this._gaxModule.routingHeader.fromParams({\\n                parent: (_a = request.parent) !== null \u0026\u0026 _a !== void 0 ? _a : '',\\n            });\\n        const defaultCallSettings = this._defaults['listCollectionIds'];\\n        const callSettings = defaultCallSettings.merge(options);\\n        this.initialize();\\n        return this.descriptors.page.listCollectionIds.asyncIterate(this.innerApiCalls['listCollectionIds'], request, callSettings);\\n    }\\n    /**\\n     * Gets information about a location.\\n     *\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.name\\n     *   Resource name for the location.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html | CallOptions} for more details.\\n     * @returns {Promise} - The promise which resolves to an array.\\n     *   The first element of the array is an object representing {@link google.cloud.location.Location | Location}.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods | documentation }\\n     *   for more details and examples.\\n     * @example\\n     * ```\\n     * const [response] = await client.getLocation(request);\\n     * ```\\n     */\\n    getLocation(request, options, callback) {\\n        return this.locationsClient.getLocation(request, options, callback);\\n    }\\n    /**\\n     * Lists information about the supported locations for this service. Returns an iterable object.\\n     *\\n     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.\\n     * @param {Object} request\\n     *   The request object that will be sent.\\n     * @param {string} request.name\\n     *   The resource that owns the locations collection, if applicable.\\n     * @param {string} request.filter\\n     *   The standard list filter.\\n     * @param {number} request.pageSize\\n     *   The standard list page size.\\n     * @param {string} request.pageToken\\n     *   The standard list page token.\\n     * @param {object} [options]\\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\\n     * @returns {Object}\\n     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.\\n     *   When you iterate the returned iterable, each element will be an object representing\\n     *   {@link google.cloud.location.Location | Location}. The API will be called under the hood as needed, once per the page,\\n     *   so you can stop the iteration when you don't need more results.\\n     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }\\n     *   for more details and examples.\\n     * @example\\n     * ```\\n     * const iterable = client.listLocationsAsync(request);\\n     * for await (const response of iterable) {\\n     *   // process response\\n     * }\\n     * ```\\n     */\\n    listLocationsAsync(request, options) {\\n        return this.locationsClient.listLocationsAsync(request, options);\\n    }\\n    /**\\n     * Terminate the gRPC channel and close the client.\\n     *\\n     * The client will no longer be usable and all future behavior is undefined.\\n     * @returns {Promise} A promise that resolves when the client is closed.\\n     */\\n    close() {\\n        if (this.firestoreStub \u0026\u0026 !this._terminated) {\\n            return this.firestoreStub.then(stub =\u003e {\\n                this._terminated = true;\\n                stub.close();\\n                this.locationsClient.close();\\n            });\\n        }\\n        return Promise.resolve();\\n    }\\n},\\\"name\\\",{value:\\\"FirestoreClient\\\"})\"\n"])</script><script>self.__next_f.push([1,"115:\"$116\"\na1:[[{\"_terminated\":false,\"descriptors\":\"$a2\",\"_universeDomain\":\"googleapis.com\",\"_servicePath\":\"firestore.googleapis.com\",\"_providedCustomServicePath\":false,\"_gaxModule\":\"$a3\",\"_gaxGrpc\":\"$dc\",\"_opts\":\"$fa\",\"auth\":\"$dd\",\"locationsClient\":\"$fb\",\"_protos\":\"$101\",\"_defaults\":\"$102\",\"innerApiCalls\":\"$103\",\"warn\":\"$da\",\"firestoreStub\":\"$@114\",\"\":\"$P115\"},{\"grpcEnabled\":false,\"activeRequestCount\":1}]]\na0:\"$Qa1\"\n118:[]\n117:\"$W118\"\n11a:\"$EObject.defineProperty(function () { [native code] },\\\"name\\\",{value:\\\"\\\"})\"\n11b:\"$EObject.defineProperty(function () { [native code] },\\\"name\\\",{value:\\\"\\\"})\"\n11e:\"$EObject.defineProperty(class Deferred {\\n    constructor() {\\n        this.resolve = () =\u003e { };\\n        this.reject = () =\u003e { };\\n        this.promise = new Promise((resolve, reject) =\u003e {\\n            this.resolve = resolve;\\n            this.reject = reject;\\n        });\\n    }\\n},\\\"name\\\",{value:\\\"Deferred\\\"})\"\n11d:\"$11e\"\n119:{\"resolve\":\"$11a\",\"reject\":\"$11b\",\"promise\":\"$@11c\",\"\":\"$P11d\"}\n"])</script><script>self.__next_f.push([1,"120:\"$EObject.defineProperty(class ClientPool {\\n    /**\\n     * @param concurrentOperationLimit The number of operations that each client\\n     * can handle.\\n     * @param maxIdleClients The maximum number of idle clients to keep before\\n     * garbage collecting.\\n     * @param clientFactory A factory function called as needed when new clients\\n     * are required.\\n     * @param clientDestructor A cleanup function that is called when a client is\\n     * disposed of.\\n     */\\n    constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = () =\u003e Promise.resolve()) {\\n        this.concurrentOperationLimit = concurrentOperationLimit;\\n        this.maxIdleClients = maxIdleClients;\\n        this.clientFactory = clientFactory;\\n        this.clientDestructor = clientDestructor;\\n        this.grpcEnabled = false;\\n        /**\\n         * Stores each active clients and how many operations it has outstanding.\\n         */\\n        this.activeClients = new Map();\\n        /**\\n         * A set of clients that have seen RST_STREAM errors (see\\n         * https://github.com/googleapis/nodejs-firestore/issues/1023) and should\\n         * no longer be used.\\n         */\\n        this.failedClients = new Set();\\n        /**\\n         * Whether the Firestore instance has been terminated. Once terminated, the\\n         * ClientPool can longer schedule new operations.\\n         */\\n        this.terminated = false;\\n        /**\\n         * Deferred promise that is resolved when there are no active operations on\\n         * the client pool after terminate() has been called.\\n         */\\n        this.terminateDeferred = new util_1.Deferred();\\n    }\\n    /**\\n     * Returns an already existing client if it has less than the maximum number\\n     * of concurrent operations or initializes and returns a new client.\\n     *\\n     * @private\\n     * @internal\\n     */\\n    acquire(requestTag, requiresGrpc) {\\n        let selectedClient = null;\\n        let selectedClientRequestCount = -1;\\n        // Transition to grpc when we see the first operation that requires grpc.\\n        this.grpcEnabled = this.grpcEnabled || requiresGrpc;\\n        // Require a grpc client for this operation if we have transitioned to grpc.\\n        requiresGrpc = requiresGrpc || this.grpcEnabled;\\n        for (const [client, metadata] of this.activeClients) {\\n            // Use the \\\"most-full\\\" client that can still accommodate the request\\n            // in order to maximize the number of idle clients as operations start to\\n            // complete.\\n            if (!this.failedClients.has(client) \u0026\u0026\\n                metadata.activeRequestCount \u003e selectedClientRequestCount \u0026\u0026\\n                metadata.activeRequestCount \u003c this.concurrentOperationLimit \u0026\u0026\\n                (metadata.grpcEnabled || !requiresGrpc)) {\\n                selectedClient = client;\\n                selectedClientRequestCount = metadata.activeRequestCount;\\n            }\\n        }\\n        if (selectedClient) {\\n            (0, logger_1.logger)('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - selectedClientRequestCount);\\n        }\\n        else {\\n            (0, logger_1.logger)('ClientPool.acquire', requestTag, 'Creating a new client (requiresGrpc: %s)', requiresGrpc);\\n            selectedClient = this.clientFactory(requiresGrpc);\\n            selectedClientRequestCount = 0;\\n            assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\\n        }\\n        this.activeClients.set(selectedClient, {\\n            grpcEnabled: requiresGrpc,\\n            activeRequestCount: selectedClientRequestCount + 1,\\n        });\\n        return selectedClient;\\n    }\\n    /**\\n     * Reduces the number of operations for the provided client, potentially\\n     * removing it from the pool of active clients.\\n     * @private\\n     * @internal\\n     */\\n    async release(requestTag, client) {\\n        const metadata = this.activeClients.get(client);\\n        assert(metadata \u0026\u0026 metadata.activeRequestCount \u003e 0, 'No active requests');\\n        this.activeClients.set(client, {\\n            grpcEnabled: metadata.grpcEnabled,\\n            activeRequestCount: metadata.activeRequestCount - 1,\\n        });\\n        if (this.terminated \u0026\u0026 this.opCount === 0) {\\n            this.terminateDeferred.resolve();\\n        }\\n        if (this.shouldGarbageCollectClient(client)) {\\n            this.activeClients.delete(client);\\n            this.failedClients.delete(client);\\n            await this.clientDestructor(client);\\n            (0, logger_1.logger)('ClientPool.release', requestTag, 'Garbage collected 1 client');\\n        }\\n    }\\n    /**\\n     * Given the current operation counts, determines if the given client should\\n     * be garbage collected.\\n     * @private\\n     * @internal\\n     */\\n    shouldGarbageCollectClient(client) {\\n        const clientMetadata = this.activeClients.get(client);\\n        if (clientMetadata.activeRequestCount !== 0) {\\n            // Don't garbage collect clients that have active requests.\\n            return false;\\n        }\\n        if (this.grpcEnabled !== clientMetadata.grpcEnabled) {\\n            // We are transitioning to GRPC. Garbage collect REST clients.\\n            return true;\\n        }\\n        // Idle clients that have received RST_STREAM errors are always garbage\\n        // collected.\\n        if (this.failedClients.has(client)) {\\n            return true;\\n        }\\n        // Otherwise, only garbage collect if we have too much idle capacity (e.g.\\n        // more than 100 idle capacity with default settings).\\n        let idleCapacityCount = 0;\\n        for (const [, metadata] of this.activeClients) {\\n            idleCapacityCount +=\\n                this.concurrentOperationLimit - metadata.activeRequestCount;\\n        }\\n        return (idleCapacityCount \u003e this.maxIdleClients * this.concurrentOperationLimit);\\n    }\\n    /**\\n     * The number of currently registered clients.\\n     *\\n     * @return Number of currently registered clients.\\n     * @private\\n     * @internal\\n     */\\n    // Visible for testing.\\n    get size() {\\n        return this.activeClients.size;\\n    }\\n    /**\\n     * The number of currently active operations.\\n     *\\n     * @return Number of currently active operations.\\n     * @private\\n     * @internal\\n     */\\n    // Visible for testing.\\n    get opCount() {\\n        let activeOperationCount = 0;\\n        this.activeClients.forEach(metadata =\u003e (activeOperationCount += metadata.activeRequestCount));\\n        return activeOperationCount;\\n    }\\n    /**\\n     * The currently active clients.\\n     *\\n     * @return The currently active clients.\\n     * @private\\n     * @internal\\n     */\\n    // Visible for testing.\\n    get _activeClients() {\\n        return this.activeClients;\\n    }\\n    /**\\n     * Runs the provided operation in this pool. This function may create an\\n     * additional client if all existing clients already operate at the concurrent\\n     * operation limit.\\n     *\\n     * @param requestTag A unique client-assigned identifier for this operation.\\n     * @param op A callback function that returns a Promise. The client T will\\n     * be returned to the pool when callback finishes.\\n     * @return A Promise that resolves with the result of `op`.\\n     * @private\\n     * @internal\\n     */\\n    run(requestTag, requiresGrpc, op) {\\n        if (this.terminated) {\\n            return Promise.reject(new Error(exports.CLIENT_TERMINATED_ERROR_MSG));\\n        }\\n        const client = this.acquire(requestTag, requiresGrpc);\\n        return op(client)\\n            .catch(async (err) =\u003e {\\n            var _a;\\n            if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.match(/RST_STREAM/)) {\\n                // Once a client has seen a RST_STREAM error, the GRPC channel can\\n                // no longer be used. We mark the client as failed, which ensures that\\n                // we open a new GRPC channel for the next request.\\n                this.failedClients.add(client);\\n            }\\n            await this.release(requestTag, client);\\n            return Promise.reject(err);\\n        })\\n            .then(async (res) =\u003e {\\n            await this.release(requestTag, client);\\n            return res;\\n        });\\n    }\\n    async terminate() {\\n        this.terminated = true;\\n        // Wait for all pending operations to complete before terminating.\\n        if (this.opCount \u003e 0) {\\n            (0, logger_1.logger)('ClientPool.terminate', \\n            /* requestTag= */ null, 'Waiting for %s pending operations to complete before terminating', this.opCount);\\n            await this.terminateDeferred.promise;\\n        }\\n        for (const [client] of this.activeClients) {\\n            this.activeClients.delete(client);\\n            await this.clientDestructor(client);\\n        }\\n    }\\n},\\\"name\\\",{value:\\\"ClientPool\\\"})\"\n"])</script><script>self.__next_f.push([1,"11f:\"$120\"\n9d:{\"concurrentOperationLimit\":100,\"maxIdleClients\":1,\"clientFactory\":\"$9e\",\"clientDestructor\":\"$9f\",\"grpcEnabled\":false,\"activeClients\":\"$a0\",\"failedClients\":\"$117\",\"terminated\":false,\"terminateDeferred\":\"$119\",\"\":\"$P11f\"}\n"])</script><script>self.__next_f.push([1,"122:\"$EObject.defineProperty(class Firestore {\\n    /**\\n     * Lazy-load the Firestore's default BulkWriter.\\n     *\\n     * @private\\n     * @internal\\n     */\\n    getBulkWriter() {\\n        if (!this._bulkWriter) {\\n            this._bulkWriter = this.bulkWriter();\\n        }\\n        return this._bulkWriter;\\n    }\\n    /**\\n     * @param {Object=} settings [Configuration object](#/docs).\\n     * @param {string=} settings.projectId The project ID from the Google\\n     * Developer's Console, e.g. 'grape-spaceship-123'. We will also check the\\n     * environment variable GCLOUD_PROJECT for your project ID.  Can be omitted in\\n     * environments that support\\n     * {@link https://cloud.google.com/docs/authentication Application Default\\n     * Credentials}\\n     * @param {string=} settings.keyFilename Local file containing the Service\\n     * Account credentials as downloaded from the Google Developers Console. Can\\n     * be omitted in environments that support\\n     * {@link https://cloud.google.com/docs/authentication Application Default\\n     * Credentials}. To configure Firestore with custom credentials, use\\n     * `settings.credentials` and provide the `client_email` and `private_key` of\\n     * your service account.\\n     * @param {{client_email:string=, private_key:string=}=} settings.credentials\\n     * The `client_email` and `private_key` properties of the service account\\n     * to use with your Firestore project. Can be omitted in environments that\\n     * support {@link https://cloud.google.com/docs/authentication Application\\n     * Default Credentials}. If your credentials are stored in a JSON file, you\\n     * can specify a `keyFilename` instead.\\n     * @param {string=} settings.host The host to connect to.\\n     * @param {boolean=} settings.ssl Whether to use SSL when connecting.\\n     * @param {number=} settings.maxIdleChannels The maximum number of idle GRPC\\n     * channels to keep. A smaller number of idle channels reduces memory usage\\n     * but increases request latency for clients with fluctuating request rates.\\n     * If set to 0, shuts down all GRPC channels when the client becomes idle.\\n     * Defaults to 1.\\n     * @param {boolean=} settings.ignoreUndefinedProperties Whether to skip nested\\n     * properties that are set to `undefined` during object serialization. If set\\n     * to `true`, these properties are skipped and not written to Firestore. If\\n     * set `false` or omitted, the SDK throws an exception when it encounters\\n     * properties of type `undefined`.\\n     * @param {boolean=} settings.preferRest Whether to force the use of HTTP/1.1 REST\\n     * transport until a method that requires gRPC is called. When a method requires gRPC,\\n     * this Firestore client will load dependent gRPC libraries and then use gRPC transport\\n     * for communication from that point forward. Currently the only operation\\n     * that requires gRPC is creating a snapshot listener with the method\\n     * `DocumentReference\u003cT\u003e.onSnapshot()`, `CollectionReference\u003cT\u003e.onSnapshot()`, or\\n     * `Query\u003cT\u003e.onSnapshot()`. If specified, this setting value will take precedent over the\\n     * environment variable `FIRESTORE_PREFER_REST`. If not specified, the\\n     * SDK will use the value specified in the environment variable `FIRESTORE_PREFER_REST`.\\n     * Valid values of `FIRESTORE_PREFER_REST` are `true` ('1') or `false` (`0`). Values are\\n     * not case-sensitive. Any other value for the environment variable will be ignored and\\n     * a warning will be logged to the console.\\n     */\\n    constructor(settings) {\\n        /**\\n         * The configuration options for the GAPIC client.\\n         * @private\\n         * @internal\\n         */\\n        this._settings = {};\\n        /**\\n         * Whether the initialization settings can still be changed by invoking\\n         * `settings()`.\\n         * @private\\n         * @internal\\n         */\\n        this._settingsFrozen = false;\\n        /**\\n         * The serializer to use for the Protobuf transformation.\\n         * @private\\n         * @internal\\n         */\\n        this._serializer = null;\\n        /**\\n         * The project ID for this client.\\n         *\\n         * The project ID is auto-detected during the first request unless a project\\n         * ID is passed to the constructor (or provided via `.settings()`).\\n         * @private\\n         * @internal\\n         */\\n        this._projectId = undefined;\\n        /**\\n         * The database ID provided via `.settings()`.\\n         *\\n         * @private\\n         * @internal\\n         */\\n        this._databaseId = undefined;\\n        /**\\n         * Count of listeners that have been registered on the client.\\n         *\\n         * The client can only be terminated when there are no pending writes or\\n         * registered listeners.\\n         * @private\\n         * @internal\\n         */\\n        this.registeredListenersCount = 0;\\n        /**\\n         * Number of pending operations on the client.\\n         *\\n         * The client can only be terminated when there are no pending writes or\\n         * registered listeners.\\n         * @private\\n         * @internal\\n         */\\n        this.bulkWritersCount = 0;\\n        const libraryHeader = {\\n            libName: 'gccl',\\n            libVersion,\\n        };\\n        if (settings \u0026\u0026 settings.firebaseVersion) {\\n            libraryHeader.libVersion += ' fire/' + settings.firebaseVersion;\\n        }\\n        if (settings \u0026\u0026 settings.firebaseAdminVersion) {\\n            libraryHeader.libVersion +=\\n                ' fire-admin/' + settings.firebaseAdminVersion;\\n        }\\n        this.validateAndApplySettings({ ...settings, ...libraryHeader });\\n        this._traceUtil = this.newTraceUtilInstance(this._settings);\\n        const retryConfig = serviceConfig.retry_params.default;\\n        this._backoffSettings = {\\n            initialDelayMs: retryConfig.initial_retry_delay_millis,\\n            maxDelayMs: retryConfig.max_retry_delay_millis,\\n            backoffFactor: retryConfig.retry_delay_multiplier,\\n        };\\n        const maxIdleChannels = this._settings.maxIdleChannels === undefined\\n            ? exports.DEFAULT_MAX_IDLE_CHANNELS\\n            : this._settings.maxIdleChannels;\\n        this._clientPool = new pool_1.ClientPool(MAX_CONCURRENT_REQUESTS_PER_CLIENT, maxIdleChannels, \\n        /* clientFactory= */ (requiresGrpc) =\u003e {\\n            var _a;\\n            let client;\\n            // Use the rest fallback if enabled and if the method does not require GRPC\\n            const useFallback = !this._settings.preferRest || requiresGrpc ? false : 'rest';\\n            let gax;\\n            if (useFallback) {\\n                if (!this._gaxFallback) {\\n                    gax = this._gaxFallback = require('google-gax/build/src/fallback');\\n                }\\n                else {\\n                    gax = this._gaxFallback;\\n                }\\n            }\\n            else {\\n                if (!this._gax) {\\n                    gax = this._gax = require('google-gax');\\n                }\\n                else {\\n                    gax = this._gax;\\n                }\\n            }\\n            if (this._settings.ssl === false) {\\n                const grpcModule = (_a = this._settings.grpc) !== null \u0026\u0026 _a !== void 0 ? _a : require('google-gax').grpc;\\n                const sslCreds = grpcModule.credentials.createInsecure();\\n                const settings = {\\n                    sslCreds,\\n                    ...this._settings,\\n                    fallback: useFallback,\\n                };\\n                // Since `ssl === false`, if we're using the GAX fallback then\\n                // also set the `protocol` option for GAX fallback to force http\\n                if (useFallback) {\\n                    settings.protocol = 'http';\\n                }\\n                client = new module.exports.v1(settings, gax);\\n            }\\n            else {\\n                client = new module.exports.v1({\\n                    ...this._settings,\\n                    fallback: useFallback,\\n                }, gax);\\n            }\\n            (0, logger_1.logger)('clientFactory', null, 'Initialized Firestore GAPIC Client (useFallback: %s)', useFallback);\\n            return client;\\n        }, \\n        /* clientDestructor= */ client =\u003e client.close());\\n        (0, logger_1.logger)('Firestore', null, 'Initialized Firestore');\\n    }\\n    /**\\n     * Specifies custom settings to be used to configure the `Firestore`\\n     * instance. Can only be invoked once and before any other Firestore method.\\n     *\\n     * If settings are provided via both `settings()` and the `Firestore`\\n     * constructor, both settings objects are merged and any settings provided via\\n     * `settings()` take precedence.\\n     *\\n     * @param {object} settings The settings to use for all Firestore operations.\\n     */\\n    settings(settings) {\\n        (0, validate_1.validateObject)('settings', settings);\\n        (0, validate_1.validateString)('settings.projectId', settings.projectId, { optional: true });\\n        (0, validate_1.validateString)('settings.databaseId', settings.databaseId, {\\n            optional: true,\\n        });\\n        if (this._settingsFrozen) {\\n            throw new Error('Firestore has already been initialized. You can only call ' +\\n                'settings() once, and only before calling any other methods on a ' +\\n                'Firestore object.');\\n        }\\n        const mergedSettings = { ...this._settings, ...settings };\\n        this.validateAndApplySettings(mergedSettings);\\n        this._traceUtil = this.newTraceUtilInstance(this._settings);\\n        this._settingsFrozen = true;\\n    }\\n    validateAndApplySettings(settings) {\\n        var _a;\\n        if (settings.projectId !== undefined) {\\n            (0, validate_1.validateString)('settings.projectId', settings.projectId);\\n            this._projectId = settings.projectId;\\n        }\\n        if (settings.databaseId !== undefined) {\\n            (0, validate_1.validateString)('settings.databaseId', settings.databaseId);\\n            this._databaseId = settings.databaseId;\\n        }\\n        let url = null;\\n        // If preferRest is not specified in settings, but is set as environment variable,\\n        // then use the environment variable value.\\n        const preferRestEnvValue = (0, util_1.tryGetPreferRestEnvironmentVariable)();\\n        if (settings.preferRest === undefined \u0026\u0026 preferRestEnvValue !== undefined) {\\n            settings = {\\n                ...settings,\\n                preferRest: preferRestEnvValue,\\n            };\\n        }\\n        // If the environment variable is set, it should always take precedence\\n        // over any user passed in settings.\\n        if (process.env.FIRESTORE_EMULATOR_HOST) {\\n            (0, validate_1.validateHost)('FIRESTORE_EMULATOR_HOST', process.env.FIRESTORE_EMULATOR_HOST);\\n            settings = {\\n                ...settings,\\n                host: process.env.FIRESTORE_EMULATOR_HOST,\\n                ssl: false,\\n            };\\n            url = new url_1.URL(`http://${settings.host}`);\\n        }\\n        else if (settings.host !== undefined) {\\n            (0, validate_1.validateHost)('settings.host', settings.host);\\n            url = new url_1.URL(`http://${settings.host}`);\\n        }\\n        // Only store the host if a valid value was provided in `host`.\\n        if (url !== null) {\\n            if ((settings.servicePath !== undefined \u0026\u0026\\n                settings.servicePath !== url.hostname) ||\\n                (settings.apiEndpoint !== undefined \u0026\u0026\\n                    settings.apiEndpoint !== url.hostname)) {\\n                // eslint-disable-next-line no-console\\n                console.warn(`The provided host (${url.hostname}) in \\\"settings\\\" does not ` +\\n                    `match the existing host (${(_a = settings.servicePath) !== null \u0026\u0026 _a !== void 0 ? _a : settings.apiEndpoint}). Using the provided host.`);\\n            }\\n            settings.servicePath = url.hostname;\\n            if (url.port !== '' \u0026\u0026 settings.port === undefined) {\\n                settings.port = Number(url.port);\\n            }\\n            // We need to remove the `host` and `apiEndpoint` setting, in case a user\\n            // calls `settings()`, which will compare the the provided `host` to the\\n            // existing hostname stored on `servicePath`.\\n            delete settings.host;\\n            delete settings.apiEndpoint;\\n        }\\n        if (settings.ssl !== undefined) {\\n            (0, validate_1.validateBoolean)('settings.ssl', settings.ssl);\\n        }\\n        if (settings.maxIdleChannels !== undefined) {\\n            (0, validate_1.validateInteger)('settings.maxIdleChannels', settings.maxIdleChannels, {\\n                minValue: 0,\\n            });\\n        }\\n        this._settings = settings;\\n        this._settings.toJSON = function () {\\n            const temp = Object.assign({}, this);\\n            if (temp.credentials) {\\n                temp.credentials = { private_key: '***', client_email: '***' };\\n            }\\n            return temp;\\n        };\\n        this._serializer = new serializer_1.Serializer(this);\\n    }\\n    newTraceUtilInstance(settings) {\\n        let createEnabledInstance = true;\\n        // The environment variable can override options to enable/disable telemetry collection.\\n        if ('FIRESTORE_ENABLE_TRACING' in process.env) {\\n            const enableTracingEnvVar = process.env.FIRESTORE_ENABLE_TRACING.toLowerCase();\\n            if (enableTracingEnvVar === 'on' || enableTracingEnvVar === 'true') {\\n                createEnabledInstance = true;\\n            }\\n            if (enableTracingEnvVar === 'off' || enableTracingEnvVar === 'false') {\\n                createEnabledInstance = false;\\n            }\\n        }\\n        if (createEnabledInstance) {\\n            return new enabled_trace_util_1.EnabledTraceUtil(settings);\\n        }\\n        else {\\n            return new disabled_trace_util_1.DisabledTraceUtil();\\n        }\\n    }\\n    /**\\n     * Returns the Project ID for this Firestore instance. Validates that\\n     * `initializeIfNeeded()` was called before.\\n     *\\n     * @private\\n     * @internal\\n     */\\n    get projectId() {\\n        if (this._projectId === undefined) {\\n            throw new Error('INTERNAL ERROR: Client is not yet ready to issue requests.');\\n        }\\n        return this._projectId;\\n    }\\n    /**\\n     * Returns the Database ID for this Firestore instance.\\n     */\\n    get databaseId() {\\n        return this._databaseId || path_1.DEFAULT_DATABASE_ID;\\n    }\\n    /**\\n     * Returns the root path of the database. Validates that\\n     * `initializeIfNeeded()` was called before.\\n     *\\n     * @private\\n     * @internal\\n     */\\n    get formattedName() {\\n        return `projects/${this.projectId}/databases/${this.databaseId}`;\\n    }\\n    /**\\n     * Gets a [DocumentReference]{@link DocumentReference} instance that\\n     * refers to the document at the specified path.\\n     *\\n     * @param {string} documentPath A slash-separated path to a document.\\n     * @returns {DocumentReference} The\\n     * [DocumentReference]{@link DocumentReference} instance.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('collection/document');\\n     * console.log(`Path of document is ${documentRef.path}`);\\n     * ```\\n     */\\n    doc(documentPath) {\\n        (0, path_1.validateResourcePath)('documentPath', documentPath);\\n        const path = path_1.ResourcePath.EMPTY.append(documentPath);\\n        if (!path.isDocument) {\\n            throw new Error(`Value for argument \\\"documentPath\\\" must point to a document, but was \\\"${documentPath}\\\". Your path does not contain an even number of components.`);\\n        }\\n        return new document_reference_1.DocumentReference(this, path);\\n    }\\n    /**\\n     * Gets a [CollectionReference]{@link CollectionReference} instance\\n     * that refers to the collection at the specified path.\\n     *\\n     * @param {string} collectionPath A slash-separated path to a collection.\\n     * @returns {CollectionReference} The\\n     * [CollectionReference]{@link CollectionReference} instance.\\n     *\\n     * @example\\n     * ```\\n     * let collectionRef = firestore.collection('collection');\\n     *\\n     * // Add a document with an auto-generated ID.\\n     * collectionRef.add({foo: 'bar'}).then((documentRef) =\u003e {\\n     *   console.log(`Added document at ${documentRef.path})`);\\n     * });\\n     * ```\\n     */\\n    collection(collectionPath) {\\n        (0, path_1.validateResourcePath)('collectionPath', collectionPath);\\n        const path = path_1.ResourcePath.EMPTY.append(collectionPath);\\n        if (!path.isCollection) {\\n            throw new Error(`Value for argument \\\"collectionPath\\\" must point to a collection, but was \\\"${collectionPath}\\\". Your path does not contain an odd number of components.`);\\n        }\\n        return new collection_reference_1.CollectionReference(this, path);\\n    }\\n    /**\\n     * Creates and returns a new Query that includes all documents in the\\n     * database that are contained in a collection or subcollection with the\\n     * given collectionId.\\n     *\\n     * @param {string} collectionId Identifies the collections to query over.\\n     * Every collection or subcollection with this ID as the last segment of its\\n     * path will be included. Cannot contain a slash.\\n     * @returns {CollectionGroup} The created CollectionGroup.\\n     *\\n     * @example\\n     * ```\\n     * let docA = firestore.doc('mygroup/docA').set({foo: 'bar'});\\n     * let docB = firestore.doc('abc/def/mygroup/docB').set({foo: 'bar'});\\n     *\\n     * Promise.all([docA, docB]).then(() =\u003e {\\n     *    let query = firestore.collectionGroup('mygroup');\\n     *    query = query.where('foo', '==', 'bar');\\n     *    return query.get().then(snapshot =\u003e {\\n     *       console.log(`Found ${snapshot.size} documents.`);\\n     *    });\\n     * });\\n     * ```\\n     */\\n    collectionGroup(collectionId) {\\n        if (collectionId.indexOf('/') !== -1) {\\n            throw new Error(`Invalid collectionId '${collectionId}'. Collection IDs must not contain '/'.`);\\n        }\\n        return new collection_group_1.CollectionGroup(this, collectionId, /* converter= */ undefined);\\n    }\\n    /**\\n     * Creates a [WriteBatch]{@link WriteBatch}, used for performing\\n     * multiple writes as a single atomic operation.\\n     *\\n     * @returns {WriteBatch} A WriteBatch that operates on this Firestore\\n     * client.\\n     *\\n     * @example\\n     * ```\\n     * let writeBatch = firestore.batch();\\n     *\\n     * // Add two documents in an atomic batch.\\n     * let data = { foo: 'bar' };\\n     * writeBatch.set(firestore.doc('col/doc1'), data);\\n     * writeBatch.set(firestore.doc('col/doc2'), data);\\n     *\\n     * writeBatch.commit().then(res =\u003e {\\n     *   console.log('Successfully executed batch.');\\n     * });\\n     * ```\\n     */\\n    batch() {\\n        return new write_batch_1.WriteBatch(this);\\n    }\\n    /**\\n     * Creates a [BulkWriter]{@link BulkWriter}, used for performing\\n     * multiple writes in parallel. Gradually ramps up writes as specified\\n     * by the 500/50/5 rule.\\n     *\\n     * If you pass [BulkWriterOptions]{@link BulkWriterOptions}, you can\\n     * configure the throttling rates for the created BulkWriter.\\n     *\\n     * @see [500/50/5 Documentation]{@link https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic}\\n     *\\n     * @param {BulkWriterOptions=} options BulkWriter options.\\n     * @returns {BulkWriter} A BulkWriter that operates on this Firestore\\n     * client.\\n     *\\n     * @example\\n     * ```\\n     * let bulkWriter = firestore.bulkWriter();\\n     *\\n     * bulkWriter.create(firestore.doc('col/doc1'), {foo: 'bar'})\\n     *   .then(res =\u003e {\\n     *     console.log(`Added document at ${res.writeTime}`);\\n     *   });\\n     * bulkWriter.update(firestore.doc('col/doc2'), {foo: 'bar'})\\n     *   .then(res =\u003e {\\n     *     console.log(`Updated document at ${res.writeTime}`);\\n     *   });\\n     * bulkWriter.delete(firestore.doc('col/doc3'))\\n     *   .then(res =\u003e {\\n     *     console.log(`Deleted document at ${res.writeTime}`);\\n     *   });\\n     * await bulkWriter.close().then(() =\u003e {\\n     *   console.log('Executed all writes');\\n     * });\\n     * ```\\n     */\\n    bulkWriter(options) {\\n        return new bulk_writer_1.BulkWriter(this, options);\\n    }\\n    /** @private */\\n    snapshot_(documentOrName, readTime, encoding) {\\n        // TODO: Assert that Firestore Project ID is valid.\\n        let convertTimestamp;\\n        let convertFields;\\n        if (encoding === undefined || encoding === 'protobufJS') {\\n            convertTimestamp = data =\u003e data;\\n            convertFields = data =\u003e data;\\n        }\\n        else if (encoding === 'json') {\\n            // Google Cloud Functions calls us with Proto3 JSON format data, which we\\n            // must convert to Protobuf JS.\\n            convertTimestamp = convert_1.timestampFromJson;\\n            convertFields = convert_1.fieldsFromJson;\\n        }\\n        else {\\n            throw new Error('Unsupported encoding format. Expected \\\"json\\\" or \\\"protobufJS\\\", ' +\\n                `but was \\\"${encoding}\\\".`);\\n        }\\n        let ref;\\n        let document;\\n        if (typeof documentOrName === 'string') {\\n            ref = new document_reference_1.DocumentReference(this, path_1.QualifiedResourcePath.fromSlashSeparatedString(documentOrName));\\n            document = new document_1.DocumentSnapshotBuilder(ref);\\n        }\\n        else {\\n            ref = new document_reference_1.DocumentReference(this, path_1.QualifiedResourcePath.fromSlashSeparatedString(documentOrName.name));\\n            document = new document_1.DocumentSnapshotBuilder(ref);\\n            document.fieldsProto = documentOrName.fields\\n                ? convertFields(documentOrName.fields)\\n                : {};\\n            document.createTime = timestamp_1.Timestamp.fromProto(convertTimestamp(documentOrName.createTime, 'documentOrName.createTime'));\\n            document.updateTime = timestamp_1.Timestamp.fromProto(convertTimestamp(documentOrName.updateTime, 'documentOrName.updateTime'));\\n        }\\n        if (readTime) {\\n            document.readTime = timestamp_1.Timestamp.fromProto(convertTimestamp(readTime, 'readTime'));\\n        }\\n        return document.build();\\n    }\\n    /**\\n     * Creates a new `BundleBuilder` instance to package selected Firestore data into\\n     * a bundle.\\n     *\\n     * @param bundleId. The id of the bundle. When loaded on clients, client SDKs use this id\\n     * and the timestamp associated with the built bundle to tell if it has been loaded already.\\n     * If not specified, a random identifier will be used.\\n     */\\n    bundle(name) {\\n        return new bundle_1.BundleBuilder(name || (0, util_1.autoId)());\\n    }\\n    /**\\n     * Function executed by {@link Firestore#runTransaction} within the transaction\\n     * context.\\n     *\\n     * @callback Firestore~updateFunction\\n     * @template T\\n     * @param {Transaction} transaction The transaction object for this\\n     * transaction.\\n     * @returns {Promise\u003cT\u003e} The promise returned at the end of the transaction.\\n     * This promise will be returned by {@link Firestore#runTransaction} if the\\n     * transaction completed successfully.\\n     */\\n    /**\\n     * Options object for {@link Firestore#runTransaction} to configure a\\n     * read-only transaction.\\n     *\\n     * @param {true} readOnly Set to true to indicate a read-only transaction.\\n     * @param {Timestamp=} readTime If specified, documents are read at the given\\n     * time. This may not be more than 60 seconds in the past from when the\\n     * request is processed by the server.\\n     * @typedef {Object} Firestore~ReadOnlyTransactionOptions\\n     */\\n    /**\\n     * Options object for {@link Firestore#runTransaction} to configure a\\n     * read-write transaction.\\n     *\\n     * @param {false=} readOnly Set to false or omit to indicate a read-write\\n     * transaction.\\n     * @param {number=} maxAttempts The maximum number of attempts for this\\n     * transaction. Defaults to 5.\\n     * @typedef {Object} Firestore~ReadWriteTransactionOptions\\n     */\\n    /**\\n     * Executes the given updateFunction and commits the changes applied within\\n     * the transaction.\\n     *\\n     * You can use the transaction object passed to 'updateFunction' to read and\\n     * modify Firestore documents under lock. You have to perform all reads before\\n     * before you perform any write.\\n     *\\n     * Transactions can be performed as read-only or read-write transactions. By\\n     * default, transactions are executed in read-write mode.\\n     *\\n     * A read-write transaction obtains a pessimistic lock on all documents that\\n     * are read during the transaction. These locks block other transactions,\\n     * batched writes, and other non-transactional writes from changing that\\n     * document. Any writes in a read-write transactions are committed once\\n     * 'updateFunction' resolves, which also releases all locks.\\n     *\\n     * If a read-write transaction fails with contention, the transaction is\\n     * retried up to five times. The `updateFunction` is invoked once for each\\n     * attempt.\\n     *\\n     * Read-only transactions do not lock documents. They can be used to read\\n     * documents at a consistent snapshot in time, which may be up to 60 seconds\\n     * in the past. Read-only transactions are not retried.\\n     *\\n     * Transactions time out after 60 seconds if no documents are read.\\n     * Transactions that are not committed within than 270 seconds are also\\n     * aborted. Any remaining locks are released when a transaction times out.\\n     *\\n     * @template T\\n     * @param {Firestore~updateFunction} updateFunction The user function to\\n     * execute within the transaction context.\\n     * @param {\\n     * Firestore~ReadWriteTransactionOptions|Firestore~ReadOnlyTransactionOptions=\\n     * } transactionOptions Transaction options.\\n     * @returns {Promise\u003cT\u003e} If the transaction completed successfully or was\\n     * explicitly aborted (by the updateFunction returning a failed Promise), the\\n     * Promise returned by the updateFunction will be returned here. Else if the\\n     * transaction failed, a rejected Promise with the corresponding failure\\n     * error will be returned.\\n     *\\n     * @example\\n     * ```\\n     * let counterTransaction = firestore.runTransaction(transaction =\u003e {\\n     *   let documentRef = firestore.doc('col/doc');\\n     *   return transaction.get(documentRef).then(doc =\u003e {\\n     *     if (doc.exists) {\\n     *       let count =  doc.get('count') || 0;\\n     *       if (count \u003e 10) {\\n     *         return Promise.reject('Reached maximum count');\\n     *       }\\n     *       transaction.update(documentRef, { count: ++count });\\n     *       return Promise.resolve(count);\\n     *     }\\n     *\\n     *     transaction.create(documentRef, { count: 1 });\\n     *     return Promise.resolve(1);\\n     *   });\\n     * });\\n     *\\n     * counterTransaction.then(res =\u003e {\\n     *   console.log(`Count updated to ${res}`);\\n     * });\\n     * ```\\n     */\\n    runTransaction(updateFunction, transactionOptions) {\\n        (0, validate_1.validateFunction)('updateFunction', updateFunction);\\n        const tag = (0, util_1.requestTag)();\\n        if (transactionOptions) {\\n            (0, validate_1.validateObject)('transactionOptions', transactionOptions);\\n            (0, validate_1.validateBoolean)('transactionOptions.readOnly', transactionOptions.readOnly, { optional: true });\\n            if (transactionOptions.readOnly) {\\n                (0, validate_1.validateTimestamp)('transactionOptions.readTime', transactionOptions.readTime, { optional: true });\\n            }\\n            else {\\n                (0, validate_1.validateInteger)('transactionOptions.maxAttempts', transactionOptions.maxAttempts, { optional: true, minValue: 1 });\\n            }\\n        }\\n        const transaction = new transaction_1.Transaction(this, tag, transactionOptions);\\n        return this.initializeIfNeeded(tag).then(() =\u003e transaction.runTransaction(updateFunction));\\n    }\\n    /**\\n     * Fetches the root collections that are associated with this Firestore\\n     * database.\\n     *\\n     * @returns {Promise.\u003cArray.\u003cCollectionReference\u003e\u003e} A Promise that resolves\\n     * with an array of CollectionReferences.\\n     *\\n     * @example\\n     * ```\\n     * firestore.listCollections().then(collections =\u003e {\\n     *   for (let collection of collections) {\\n     *     console.log(`Found collection with id: ${collection.id}`);\\n     *   }\\n     * });\\n     * ```\\n     */\\n    listCollections() {\\n        const rootDocument = new document_reference_1.DocumentReference(this, path_1.ResourcePath.EMPTY);\\n        return rootDocument.listCollections();\\n    }\\n    /**\\n     * Retrieves multiple documents from Firestore.\\n     *\\n     * The first argument is required and must be of type `DocumentReference`\\n     * followed by any additional `DocumentReference` documents. If used, the\\n     * optional `ReadOptions` must be the last argument.\\n     *\\n     * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\\n     * `DocumentReferences` to receive, followed by an optional field mask.\\n     * @returns {Promise\u003cArray.\u003cDocumentSnapshot\u003e\u003e} A Promise that\\n     * contains an array with the resulting document snapshots.\\n     *\\n     * @example\\n     * ```\\n     * let docRef1 = firestore.doc('col/doc1');\\n     * let docRef2 = firestore.doc('col/doc2');\\n     *\\n     * firestore.getAll(docRef1, docRef2, { fieldMask: ['user'] }).then(docs =\u003e {\\n     *   console.log(`First document: ${JSON.stringify(docs[0])}`);\\n     *   console.log(`Second document: ${JSON.stringify(docs[1])}`);\\n     * });\\n     * ```\\n     */\\n    getAll(...documentRefsOrReadOptions) {\\n        return this._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_BATCH_GET_DOCUMENTS, () =\u003e {\\n            (0, validate_1.validateMinNumberOfArguments)('Firestore.getAll', documentRefsOrReadOptions, 1);\\n            const { documents, fieldMask } = (0, transaction_1.parseGetAllArguments)(documentRefsOrReadOptions);\\n            this._traceUtil.currentSpan().setAttributes({\\n                [trace_util_1.ATTRIBUTE_KEY_IS_TRANSACTIONAL]: false,\\n                [trace_util_1.ATTRIBUTE_KEY_DOC_COUNT]: documents.length,\\n            });\\n            const tag = (0, util_1.requestTag)();\\n            // Capture the error stack to preserve stack tracing across async calls.\\n            const stack = Error().stack;\\n            return this.initializeIfNeeded(tag)\\n                .then(() =\u003e {\\n                const reader = new document_reader_1.DocumentReader(this, documents, fieldMask);\\n                return reader.get(tag);\\n            })\\n                .catch(err =\u003e {\\n                throw (0, util_1.wrapError)(err, stack);\\n            });\\n        });\\n    }\\n    /**\\n     * Registers a listener on this client, incrementing the listener count. This\\n     * is used to verify that all listeners are unsubscribed when terminate() is\\n     * called.\\n     *\\n     * @private\\n     * @internal\\n     */\\n    registerListener() {\\n        this.registeredListenersCount += 1;\\n    }\\n    /**\\n     * Unregisters a listener on this client, decrementing the listener count.\\n     * This is used to verify that all listeners are unsubscribed when terminate()\\n     * is called.\\n     *\\n     * @private\\n     * @internal\\n     */\\n    unregisterListener() {\\n        this.registeredListenersCount -= 1;\\n    }\\n    /**\\n     * Increments the number of open BulkWriter instances. This is used to verify\\n     * that all pending operations are complete when terminate() is called.\\n     *\\n     * @private\\n     * @internal\\n     */\\n    _incrementBulkWritersCount() {\\n        this.bulkWritersCount += 1;\\n    }\\n    /**\\n     * Decrements the number of open BulkWriter instances. This is used to verify\\n     * that all pending operations are complete when terminate() is called.\\n     *\\n     * @private\\n     * @internal\\n     */\\n    _decrementBulkWritersCount() {\\n        this.bulkWritersCount -= 1;\\n    }\\n    /**\\n     * Recursively deletes all documents and subcollections at and under the\\n     * specified level.\\n     *\\n     * If any delete fails, the promise is rejected with an error message\\n     * containing the number of failed deletes and the stack trace of the last\\n     * failed delete. The provided reference is deleted regardless of whether\\n     * all deletes succeeded.\\n     *\\n     * `recursiveDelete()` uses a BulkWriter instance with default settings to\\n     * perform the deletes. To customize throttling rates or add success/error\\n     * callbacks, pass in a custom BulkWriter instance.\\n     *\\n     * @param ref The reference of a document or collection to delete.\\n     * @param bulkWriter A custom BulkWriter instance used to perform the\\n     * deletes.\\n     * @return A promise that resolves when all deletes have been performed.\\n     * The promise is rejected if any of the deletes fail.\\n     *\\n     * @example\\n     * ```\\n     * // Recursively delete a reference and log the references of failures.\\n     * const bulkWriter = firestore.bulkWriter();\\n     * bulkWriter\\n     *   .onWriteError((error) =\u003e {\\n     *     if (\\n     *       error.failedAttempts \u003c MAX_RETRY_ATTEMPTS\\n     *     ) {\\n     *       return true;\\n     *     } else {\\n     *       console.log('Failed write at document: ', error.documentRef.path);\\n     *       return false;\\n     *     }\\n     *   });\\n     * await firestore.recursiveDelete(docRef, bulkWriter);\\n     * ```\\n     */\\n    recursiveDelete(ref, bulkWriter) {\\n        return this._recursiveDelete(ref, recursive_delete_1.RECURSIVE_DELETE_MAX_PENDING_OPS, recursive_delete_1.RECURSIVE_DELETE_MIN_PENDING_OPS, bulkWriter);\\n    }\\n    /**\\n     * This overload is not private in order to test the query resumption with\\n     * startAfter() once the RecursiveDelete instance has MAX_PENDING_OPS pending.\\n     *\\n     * @private\\n     * @internal\\n     */\\n    // Visible for testing\\n    _recursiveDelete(ref, maxPendingOps, minPendingOps, bulkWriter) {\\n        const writer = bulkWriter !== null \u0026\u0026 bulkWriter !== void 0 ? bulkWriter : this.getBulkWriter();\\n        const deleter = new recursive_delete_1.RecursiveDelete(this, writer, ref, maxPendingOps, minPendingOps);\\n        return deleter.run();\\n    }\\n    /**\\n     * Terminates the Firestore client and closes all open streams.\\n     *\\n     * @return A Promise that resolves when the client is terminated.\\n     */\\n    terminate() {\\n        if (this.registeredListenersCount \u003e 0 || this.bulkWritersCount \u003e 0) {\\n            return Promise.reject('All onSnapshot() listeners must be unsubscribed, and all BulkWriter ' +\\n                'instances must be closed before terminating the client. ' +\\n                `There are ${this.registeredListenersCount} active listeners and ` +\\n                `${this.bulkWritersCount} open BulkWriter instances.`);\\n        }\\n        return this._clientPool.terminate();\\n    }\\n    /**\\n     * Returns the Project ID to serve as the JSON representation of this\\n     * Firestore instance.\\n     *\\n     * @return An object that contains the project ID (or `undefined` if not yet\\n     * available).\\n     */\\n    toJSON() {\\n        return { projectId: this._projectId };\\n    }\\n    /**\\n     * Initializes the client if it is not already initialized. All methods in the\\n     * SDK can be used after this method completes.\\n     *\\n     * @private\\n     * @internal\\n     * @param requestTag A unique client-assigned identifier that caused this\\n     * initialization.\\n     * @return A Promise that resolves when the client is initialized.\\n     */\\n    async initializeIfNeeded(requestTag) {\\n        this._settingsFrozen = true;\\n        if (this._settings.ssl === false) {\\n            // If SSL is false, we assume that we are talking to the emulator. We\\n            // provide an Authorization header by default so that the connection is\\n            // recognized as admin in Firestore Emulator. (If for some reason we're\\n            // not connecting to the emulator, then this will result in denials with\\n            // invalid token, rather than behave like clients not logged in. The user\\n            // can then provide their own Authorization header, which will take\\n            // precedence).\\n            this._settings.customHeaders = {\\n                Authorization: 'Bearer owner',\\n                ...this._settings.customHeaders,\\n            };\\n        }\\n        if (this._projectId === undefined) {\\n            try {\\n                this._projectId = await this._clientPool.run(requestTag, \\n                /* requiresGrpc= */ false, gapicClient =\u003e gapicClient.getProjectId());\\n                (0, logger_1.logger)('Firestore.initializeIfNeeded', null, 'Detected project ID: %s', this._projectId);\\n                // If the project ID was undefined when the TraceUtil was set up, we\\n                // need to record it.\\n                this._traceUtil.recordProjectId(this.projectId);\\n            }\\n            catch (err) {\\n                (0, logger_1.logger)('Firestore.initializeIfNeeded', null, 'Failed to detect project ID: %s', err);\\n                return Promise.reject(err);\\n            }\\n        }\\n    }\\n    /**\\n     * Returns GAX call options that set the cloud resource header.\\n     * @private\\n     * @internal\\n     */\\n    createCallOptions(methodName, retryCodes) {\\n        var _a;\\n        const callOptions = {\\n            otherArgs: {\\n                headers: {\\n                    [CLOUD_RESOURCE_HEADER]: this.formattedName,\\n                    ...this._settings.customHeaders,\\n                    ...(_a = this._settings[methodName]) === null || _a === void 0 ? void 0 : _a.customHeaders,\\n                },\\n            },\\n        };\\n        if (retryCodes) {\\n            const retryParams = (0, util_1.getRetryParams)(methodName);\\n            callOptions.retry =\\n                new (require('google-gax/build/src/fallback').RetryOptions)(retryCodes, retryParams);\\n        }\\n        return callOptions;\\n    }\\n    /**\\n     * A function returning a Promise that can be retried.\\n     *\\n     * @private\\n     * @internal\\n     * @callback retryFunction\\n     * @returns {Promise} A Promise indicating the function's success.\\n     */\\n    /**\\n     * Helper method that retries failed Promises.\\n     *\\n     * If 'delayMs' is specified, waits 'delayMs' between invocations. Otherwise,\\n     * schedules the first attempt immediately, and then waits 100 milliseconds\\n     * for further attempts.\\n     *\\n     * @private\\n     * @internal\\n     * @param methodName Name of the Veneer API endpoint that takes a request\\n     * and GAX options.\\n     * @param requestTag A unique client-assigned identifier for this request.\\n     * @param func Method returning a Promise than can be retried.\\n     * @returns A Promise with the function's result if successful within\\n     * `attemptsRemaining`. Otherwise, returns the last rejected Promise.\\n     */\\n    async _retry(methodName, requestTag, func) {\\n        const backoff = new backoff_1.ExponentialBackoff();\\n        let lastError = undefined;\\n        for (let attempt = 0; attempt \u003c exports.MAX_REQUEST_RETRIES; ++attempt) {\\n            if (lastError) {\\n                (0, logger_1.logger)('Firestore._retry', requestTag, 'Retrying request that failed with error:', lastError);\\n            }\\n            try {\\n                await backoff.backoffAndWait();\\n                return await func();\\n            }\\n            catch (err) {\\n                lastError = err;\\n                if ((0, util_1.isPermanentRpcError)(err, methodName)) {\\n                    break;\\n                }\\n            }\\n        }\\n        (0, logger_1.logger)('Firestore._retry', requestTag, 'Request failed with error:', lastError);\\n        return Promise.reject(lastError);\\n    }\\n    /**\\n     * Waits for the provided stream to become active and returns a paused but\\n     * healthy stream. If an error occurs before the first byte is read, the\\n     * method rejects the returned Promise.\\n     *\\n     * @private\\n     * @internal\\n     * @param backendStream The Node stream to monitor.\\n     * @param lifetime A Promise that resolves when the stream receives an 'end',\\n     * 'close' or 'finish' message.\\n     * @param requestTag A unique client-assigned identifier for this request.\\n     * @param request If specified, the request that should be written to the\\n     * stream after opening.\\n     * @returns A guaranteed healthy stream that should be used instead of\\n     * `backendStream`.\\n     */\\n    _initializeStream(backendStream, lifetime, requestTag, request) {\\n        const resultStream = new stream_1.PassThrough({ objectMode: true });\\n        resultStream.pause();\\n        /**\\n         * Whether we have resolved the Promise and returned the stream to the\\n         * caller.\\n         */\\n        let streamInitialized = false;\\n        return new Promise((resolve, reject) =\u003e {\\n            function streamReady() {\\n                if (!streamInitialized) {\\n                    streamInitialized = true;\\n                    (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Stream ready');\\n                    resolve(resultStream);\\n                }\\n            }\\n            function streamEnded() {\\n                (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Received stream end');\\n                resultStream.unpipe(backendStream);\\n                resolve(resultStream);\\n                lifetime.resolve();\\n            }\\n            function streamFailed(err) {\\n                if (!streamInitialized) {\\n                    // If we receive an error before we were able to receive any data,\\n                    // reject this stream.\\n                    (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Received initial error:', err);\\n                    reject(err);\\n                }\\n                else {\\n                    (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Received stream error:', err);\\n                    // We execute the forwarding of the 'error' event via setImmediate() as\\n                    // V8 guarantees that the Promise chain returned from this method\\n                    // is resolved before any code executed via setImmediate(). This\\n                    // allows the caller to attach an error handler.\\n                    setImmediate(() =\u003e {\\n                        resultStream.emit('error', err);\\n                    });\\n                }\\n            }\\n            backendStream.on('data', () =\u003e streamReady());\\n            backendStream.on('error', err =\u003e streamFailed(err));\\n            backendStream.on('end', () =\u003e streamEnded());\\n            backendStream.on('close', () =\u003e streamEnded());\\n            backendStream.on('finish', () =\u003e streamEnded());\\n            backendStream.pipe(resultStream);\\n            if (request) {\\n                (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Sending request: %j', request);\\n                backendStream.write(request, 'utf-8', err =\u003e {\\n                    if (err) {\\n                        streamFailed(err);\\n                    }\\n                    else {\\n                        (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Marking stream as healthy');\\n                        streamReady();\\n                    }\\n                });\\n            }\\n        });\\n    }\\n    /**\\n     * A funnel for all non-streaming API requests, assigning a project ID where\\n     * necessary within the request options.\\n     *\\n     * @private\\n     * @internal\\n     * @param methodName Name of the Veneer API endpoint that takes a request\\n     * and GAX options.\\n     * @param request The Protobuf request to send.\\n     * @param requestTag A unique client-assigned identifier for this request.\\n     * @param retryCodes If provided, a custom list of retry codes. If not\\n     * provided, retry is based on the behavior as defined in the ServiceConfig.\\n     * @returns A Promise with the request result.\\n     */\\n    request(methodName, request, requestTag, retryCodes) {\\n        const callOptions = this.createCallOptions(methodName, retryCodes);\\n        return this._clientPool.run(requestTag, \\n        /* requiresGrpc= */ false, async (gapicClient) =\u003e {\\n            try {\\n                (0, logger_1.logger)('Firestore.request', requestTag, 'Sending request: %j', request);\\n                const [result] = await gapicClient[methodName](request, callOptions);\\n                (0, logger_1.logger)('Firestore.request', requestTag, 'Received response: %j', result);\\n                return result;\\n            }\\n            catch (err) {\\n                (0, logger_1.logger)('Firestore.request', requestTag, 'Received error:', err);\\n                return Promise.reject(err);\\n            }\\n        });\\n    }\\n    /**\\n     * A funnel for streaming API requests, assigning a project ID where necessary\\n     * within the request options.\\n     *\\n     * The stream is returned in paused state and needs to be resumed once all\\n     * listeners are attached.\\n     *\\n     * @private\\n     * @internal\\n     * @param methodName Name of the streaming Veneer API endpoint that\\n     * takes a request and GAX options.\\n     * @param bidrectional Whether the request is bidirectional (true) or\\n     * unidirectional (false_\\n     * @param request The Protobuf request to send.\\n     * @param requestTag A unique client-assigned identifier for this request.\\n     * @returns A Promise with the resulting read-only stream.\\n     */\\n    requestStream(methodName, bidrectional, request, requestTag) {\\n        const callOptions = this.createCallOptions(methodName);\\n        const bidirectional = methodName === 'listen';\\n        let numResponses = 0;\\n        const NUM_RESPONSES_PER_TRACE_EVENT = 100;\\n        return this._retry(methodName, requestTag, () =\u003e {\\n            const result = new util_1.Deferred();\\n            this._clientPool.run(requestTag, bidrectional, async (gapicClient) =\u003e {\\n                (0, logger_1.logger)('Firestore.requestStream', requestTag, 'Sending request: %j', request);\\n                this._traceUtil\\n                    .currentSpan()\\n                    .addEvent(`Firestore.${methodName}: Start`);\\n                try {\\n                    const stream = bidirectional\\n                        ? gapicClient[methodName](callOptions)\\n                        : gapicClient[methodName](request, callOptions);\\n                    const logStream = new stream_1.Transform({\\n                        objectMode: true,\\n                        transform: (chunk, encoding, callback) =\u003e {\\n                            (0, logger_1.logger)('Firestore.requestStream', requestTag, 'Received response: %j', chunk);\\n                            numResponses++;\\n                            if (numResponses === 1) {\\n                                this._traceUtil\\n                                    .currentSpan()\\n                                    .addEvent(`Firestore.${methodName}: First response received`);\\n                            }\\n                            else if (numResponses % NUM_RESPONSES_PER_TRACE_EVENT === 0) {\\n                                this._traceUtil\\n                                    .currentSpan()\\n                                    .addEvent(`Firestore.${methodName}: Received ${numResponses} responses`);\\n                            }\\n                            callback();\\n                        },\\n                    });\\n                    stream.pipe(logStream);\\n                    const lifetime = new util_1.Deferred();\\n                    const resultStream = await this._initializeStream(stream, lifetime, requestTag, bidirectional ? request : undefined);\\n                    resultStream.on('end', () =\u003e {\\n                        stream.end();\\n                        this._traceUtil\\n                            .currentSpan()\\n                            .addEvent(`Firestore.${methodName}: Completed`, {\\n                            [trace_util_1.ATTRIBUTE_KEY_NUM_RESPONSES]: numResponses,\\n                        });\\n                    });\\n                    result.resolve(resultStream);\\n                    // While we return the stream to the callee early, we don't want to\\n                    // release the GAPIC client until the callee has finished processing the\\n                    // stream.\\n                    return lifetime.promise;\\n                }\\n                catch (e) {\\n                    result.reject(e);\\n                }\\n            });\\n            return result.promise;\\n        });\\n    }\\n},\\\"name\\\",{value:\\\"Firestore\\\"})\"\n"])</script><script>self.__next_f.push([1,"121:\"$122\"\n8a:{\"_settings\":\"$8b\",\"_settingsFrozen\":true,\"_serializer\":\"$8d\",\"_projectId\":\"resumemaker-b590f\",\"_databaseId\":\"(default)\",\"registeredListenersCount\":0,\"bulkWritersCount\":0,\"_traceUtil\":\"$92\",\"_backoffSettings\":\"$9c\",\"_clientPool\":\"$9d\",\"_gax\":\"$a3\",\"\":\"$P121\"}\n124:[\"generated_job_roles\",\"project-manager-resume-india\"]\n"])</script><script>self.__next_f.push([1,"126:\"$EObject.defineProperty(class ResourcePath extends Path {\\n    /**\\n     * Constructs a ResourcePath.\\n     *\\n     * @private\\n     * @internal\\n     * @param segments Sequence of names of the parts of the path.\\n     */\\n    constructor(...segments) {\\n        super(segments);\\n    }\\n    /**\\n     * Indicates whether this path points to a document.\\n     * @private\\n     * @internal\\n     */\\n    get isDocument() {\\n        return this.segments.length \u003e 0 \u0026\u0026 this.segments.length % 2 === 0;\\n    }\\n    /**\\n     * Indicates whether this path points to a collection.\\n     * @private\\n     * @internal\\n     */\\n    get isCollection() {\\n        return this.segments.length % 2 === 1;\\n    }\\n    /**\\n     * The last component of the path.\\n     * @private\\n     * @internal\\n     */\\n    get id() {\\n        if (this.segments.length \u003e 0) {\\n            return this.segments[this.segments.length - 1];\\n        }\\n        return null;\\n    }\\n    /**\\n     * Returns the location of this path relative to the root of the project's\\n     * database.\\n     * @private\\n     * @internal\\n     */\\n    get relativeName() {\\n        return this.segments.join('/');\\n    }\\n    /**\\n     * Constructs a new instance of ResourcePath.\\n     *\\n     * @private\\n     * @internal\\n     * @param segments Sequence of parts of the path.\\n     * @returns The newly created ResourcePath.\\n     */\\n    construct(segments) {\\n        return new ResourcePath(...segments);\\n    }\\n    /**\\n     * Splits a string into path segments, using slashes as separators.\\n     *\\n     * @private\\n     * @internal\\n     * @param relativePath The path to split.\\n     * @returns The split path segments.\\n     */\\n    split(relativePath) {\\n        // We may have an empty segment at the beginning or end if they had a\\n        // leading or trailing slash (which we allow).\\n        return relativePath.split('/').filter(segment =\u003e segment.length \u003e 0);\\n    }\\n    /**\\n     * Converts this path to a fully qualified ResourcePath.\\n     *\\n     * @private\\n     * @internal\\n     * @param projectId The project ID of the current Firestore project.\\n     * @return A fully-qualified resource path pointing to the same element.\\n     */\\n    toQualifiedResourcePath(projectId, databaseId) {\\n        return new QualifiedResourcePath(projectId, databaseId, ...this.segments);\\n    }\\n},\\\"name\\\",{value:\\\"ResourcePath\\\"})\"\n"])</script><script>self.__next_f.push([1,"125:\"$126\"\n123:{\"segments\":\"$124\",\"\":\"$P125\"}\n128:\"$EObject.defineProperty(toFirestore(modelObject) {\\n        return modelObject;\\n    },\\\"name\\\",{value:\\\"toFirestore\\\"})\"\n129:\"$EObject.defineProperty(fromFirestore(snapshot) {\\n        return snapshot.data();\\n    },\\\"name\\\",{value:\\\"fromFirestore\\\"})\"\n127:{\"toFirestore\":\"$128\",\"fromFirestore\":\"$129\"}\n"])</script><script>self.__next_f.push([1,"12b:\"$EObject.defineProperty(class DocumentReference {\\n    /**\\n     * @private\\n     * @internal\\n     * @param _firestore The Firestore Database client.\\n     * @param _path The Path of this reference.\\n     * @param _converter The converter to use when serializing data.\\n     */\\n    constructor(_firestore, \\n    /**\\n     * @private\\n     * @internal\\n     **/\\n    _path, \\n    /**\\n     * @internal\\n     * @private\\n     **/\\n    _converter = (0, types_1.defaultConverter)()) {\\n        this._firestore = _firestore;\\n        this._path = _path;\\n        this._converter = _converter;\\n    }\\n    /**\\n     * The string representation of the DocumentReference's location.\\n     * @private\\n     * @internal\\n     * @type {string}\\n     * @name DocumentReference#formattedName\\n     */\\n    get formattedName() {\\n        const projectId = this.firestore.projectId;\\n        const databaseId = this.firestore.databaseId;\\n        return this._path.toQualifiedResourcePath(projectId, databaseId)\\n            .formattedName;\\n    }\\n    /**\\n     * The [Firestore]{@link Firestore} instance for the Firestore\\n     * database (useful for performing transactions, etc.).\\n     *\\n     * @type {Firestore}\\n     * @name DocumentReference#firestore\\n     * @readonly\\n     *\\n     * @example\\n     * ```\\n     * let collectionRef = firestore.collection('col');\\n     *\\n     * collectionRef.add({foo: 'bar'}).then(documentReference =\u003e {\\n     *   let firestore = documentReference.firestore;\\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\\n     * });\\n     * ```\\n     */\\n    get firestore() {\\n        return this._firestore;\\n    }\\n    /**\\n     * A string representing the path of the referenced document (relative\\n     * to the root of the database).\\n     *\\n     * @type {string}\\n     * @name DocumentReference#path\\n     * @readonly\\n     *\\n     * @example\\n     * ```\\n     * let collectionRef = firestore.collection('col');\\n     *\\n     * collectionRef.add({foo: 'bar'}).then(documentReference =\u003e {\\n     *   console.log(`Added document at '${documentReference.path}'`);\\n     * });\\n     * ```\\n     */\\n    get path() {\\n        return this._path.relativeName;\\n    }\\n    /**\\n     * The last path element of the referenced document.\\n     *\\n     * @type {string}\\n     * @name DocumentReference#id\\n     * @readonly\\n     *\\n     * @example\\n     * ```\\n     * let collectionRef = firestore.collection('col');\\n     *\\n     * collectionRef.add({foo: 'bar'}).then(documentReference =\u003e {\\n     *   console.log(`Added document with name '${documentReference.id}'`);\\n     * });\\n     * ```\\n     */\\n    get id() {\\n        return this._path.id;\\n    }\\n    /**\\n     * Returns a resource path for this document.\\n     * @private\\n     * @internal\\n     */\\n    get _resourcePath() {\\n        return this._path;\\n    }\\n    /**\\n     * A reference to the collection to which this DocumentReference belongs.\\n     *\\n     * @name DocumentReference#parent\\n     * @type {CollectionReference}\\n     * @readonly\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     * let collectionRef = documentRef.parent;\\n     *\\n     * collectionRef.where('foo', '==', 'bar').get().then(results =\u003e {\\n     *   console.log(`Found ${results.size} matches in parent collection`);\\n     * }):\\n     * ```\\n     */\\n    get parent() {\\n        return new collection_reference_1.CollectionReference(this._firestore, this._path.parent(), this._converter);\\n    }\\n    /**\\n     * Reads the document referred to by this DocumentReference.\\n     *\\n     * @returns {Promise.\u003cDocumentSnapshot\u003e} A Promise resolved with a\\n     * DocumentSnapshot for the retrieved document on success. For missing\\n     * documents, DocumentSnapshot.exists will be false. If the get() fails for\\n     * other reasons, the Promise will be rejected.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.get().then(documentSnapshot =\u003e {\\n     *   if (documentSnapshot.exists) {\\n     *     console.log('Document retrieved successfully.');\\n     *   }\\n     * });\\n     * ```\\n     */\\n    get() {\\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_GET, () =\u003e {\\n            return this._firestore.getAll(this).then(([result]) =\u003e result);\\n        });\\n    }\\n    /**\\n     * Gets a [CollectionReference]{@link CollectionReference} instance\\n     * that refers to the collection at the specified path.\\n     *\\n     * @param {string} collectionPath A slash-separated path to a collection.\\n     * @returns {CollectionReference} A reference to the new\\n     * subcollection.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     * let subcollection = documentRef.collection('subcollection');\\n     * console.log(`Path to subcollection: ${subcollection.path}`);\\n     * ```\\n     */\\n    collection(collectionPath) {\\n        (0, path_1.validateResourcePath)('collectionPath', collectionPath);\\n        const path = this._path.append(collectionPath);\\n        if (!path.isCollection) {\\n            throw new Error(`Value for argument \\\"collectionPath\\\" must point to a collection, but was \\\"${collectionPath}\\\". Your path does not contain an odd number of components.`);\\n        }\\n        return new collection_reference_1.CollectionReference(this._firestore, path);\\n    }\\n    /**\\n     * Fetches the subcollections that are direct children of this document.\\n     *\\n     * @returns {Promise.\u003cArray.\u003cCollectionReference\u003e\u003e} A Promise that resolves\\n     * with an array of CollectionReferences.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.listCollections().then(collections =\u003e {\\n     *   for (let collection of collections) {\\n     *     console.log(`Found subcollection with id: ${collection.id}`);\\n     *   }\\n     * });\\n     * ```\\n     */\\n    listCollections() {\\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_LIST_COLLECTIONS, () =\u003e {\\n            const tag = (0, util_1.requestTag)();\\n            return this.firestore.initializeIfNeeded(tag).then(() =\u003e {\\n                const request = {\\n                    parent: this.formattedName,\\n                    // Setting `pageSize` to an arbitrarily large value lets the backend cap\\n                    // the page size (currently to 300). Note that the backend rejects\\n                    // MAX_INT32 (b/146883794).\\n                    pageSize: Math.pow(2, 16) - 1,\\n                };\\n                return this._firestore\\n                    .request('listCollectionIds', request, tag)\\n                    .then(collectionIds =\u003e {\\n                    const collections = [];\\n                    // We can just sort this list using the default comparator since it\\n                    // will only contain collection ids.\\n                    collectionIds.sort();\\n                    for (const collectionId of collectionIds) {\\n                        collections.push(this.collection(collectionId));\\n                    }\\n                    return collections;\\n                });\\n            });\\n        });\\n    }\\n    /**\\n     * Create a document with the provided object values. This will fail the write\\n     * if a document exists at its location.\\n     *\\n     * @param {DocumentData} data An object that contains the fields and data to\\n     * serialize as the document.\\n     * @throws {Error} If the provided input is not a valid Firestore document or if the document already exists.\\n     * @returns {Promise.\u003cWriteResult\u003e} A Promise that resolves with the\\n     * write time of this create.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.collection('col').doc();\\n     *\\n     * documentRef.create({foo: 'bar'}).then((res) =\u003e {\\n     *   console.log(`Document created at ${res.updateTime}`);\\n     * }).catch((err) =\u003e {\\n     *   console.log(`Failed to create document: ${err}`);\\n     * });\\n     * ```\\n     */\\n    create(data) {\\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_CREATE, () =\u003e {\\n            const writeBatch = new index_1.WriteBatch(this._firestore);\\n            return writeBatch\\n                .create(this, data)\\n                .commit()\\n                .then(([writeResult]) =\u003e writeResult);\\n        });\\n    }\\n    /**\\n     * Deletes the document referred to by this `DocumentReference`.\\n     *\\n     * A delete for a non-existing document is treated as a success (unless\\n     * lastUptimeTime is provided).\\n     *\\n     * @param {Precondition=} precondition A precondition to enforce for this\\n     * delete.\\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\\n     * document was last updated at lastUpdateTime. Fails the delete if the\\n     * document was last updated at a different time.\\n     * @param {boolean=} precondition.exists If set, enforces that the target\\n     * document must or must not exist.\\n     * @returns {Promise.\u003cWriteResult\u003e} A Promise that resolves with the\\n     * delete time.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.delete().then(() =\u003e {\\n     *   console.log('Document successfully deleted.');\\n     * });\\n     * ```\\n     */\\n    delete(precondition) {\\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_DELETE, () =\u003e {\\n            const writeBatch = new index_1.WriteBatch(this._firestore);\\n            return writeBatch\\n                .delete(this, precondition)\\n                .commit()\\n                .then(([writeResult]) =\u003e writeResult);\\n        });\\n    }\\n    /**\\n     * Writes to the document referred to by this DocumentReference. If the\\n     * document does not yet exist, it will be created. If you pass\\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into an\\n     * existing document.\\n     *\\n     * @param {T|Partial\u003cAppModelType\u003e} data A map of the fields and values for\\n     * the document.\\n     * @param {SetOptions=} options An object to configure the set behavior.\\n     * @param {boolean=} options.merge If true, set() merges the values specified\\n     * in its data argument. Fields omitted from this set() call remain untouched.\\n     * If your input sets any field to an empty map, all nested fields are\\n     * overwritten.\\n     * @param {Array.\u003cstring|FieldPath\u003e=} options.mergeFields If provided,\\n     * set() only replaces the specified field paths. Any field path that is not\\n     * specified is ignored and remains untouched. If your input sets any field to\\n     * an empty map, all nested fields are overwritten.\\n     * @throws {Error} If the provided input is not a valid Firestore document.\\n     * @returns {Promise.\u003cWriteResult\u003e} A Promise that resolves with the\\n     * write time of this set.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.set({foo: 'bar'}).then(res =\u003e {\\n     *   console.log(`Document written at ${res.updateTime}`);\\n     * });\\n     * ```\\n     */\\n    set(data, options) {\\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_SET, () =\u003e {\\n            let writeBatch = new index_1.WriteBatch(this._firestore);\\n            if (options) {\\n                writeBatch = writeBatch.set(this, data, options);\\n            }\\n            else {\\n                writeBatch = writeBatch.set(this, data);\\n            }\\n            return writeBatch.commit().then(([writeResult]) =\u003e writeResult);\\n        });\\n    }\\n    /**\\n     * Updates fields in the document referred to by this DocumentReference.\\n     * If the document doesn't yet exist, the update fails and the returned\\n     * Promise will be rejected.\\n     *\\n     * The update() method accepts either an object with field paths encoded as\\n     * keys and field values encoded as values, or a variable number of arguments\\n     * that alternate between field paths and field values.\\n     *\\n     * A Precondition restricting this update can be specified as the last\\n     * argument.\\n     *\\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\\n     * fields and values with which to update the document or the path of the\\n     * first field to update.\\n     * @param {\\n     * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\\n     * list of field paths and values to update or a Precondition to restrict\\n     * this update.\\n     * @throws {Error} If the provided input is not valid Firestore data.\\n     * @returns {Promise.\u003cWriteResult\u003e} A Promise that resolves once the\\n     * data has been successfully written to the backend.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.update({foo: 'bar'}).then(res =\u003e {\\n     *   console.log(`Document updated at ${res.updateTime}`);\\n     * });\\n     * ```\\n     */\\n    update(dataOrField, ...preconditionOrValues) {\\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_UPDATE, () =\u003e {\\n            // eslint-disable-next-line prefer-rest-params\\n            (0, validate_1.validateMinNumberOfArguments)('DocumentReference.update', arguments, 1);\\n            const writeBatch = new index_1.WriteBatch(this._firestore);\\n            return writeBatch\\n                .update(this, dataOrField, ...preconditionOrValues)\\n                .commit()\\n                .then(([writeResult]) =\u003e writeResult);\\n        });\\n    }\\n    /**\\n     * Attaches a listener for DocumentSnapshot events.\\n     *\\n     * @param {documentSnapshotCallback} onNext A callback to be called every\\n     * time a new `DocumentSnapshot` is available.\\n     * @param {errorCallback=} onError A callback to be called if the listen fails\\n     * or is cancelled. No further callbacks will occur. If unset, errors will be\\n     * logged to the console.\\n     *\\n     * @returns {function()} An unsubscribe function that can be called to cancel\\n     * the snapshot listener.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * let unsubscribe = documentRef.onSnapshot(documentSnapshot =\u003e {\\n     *   if (documentSnapshot.exists) {\\n     *     console.log(documentSnapshot.data());\\n     *   }\\n     * }, err =\u003e {\\n     *   console.log(`Encountered error: ${err}`);\\n     * });\\n     *\\n     * // Remove this listener.\\n     * unsubscribe();\\n     * ```\\n     */\\n    onSnapshot(onNext, onError) {\\n        (0, validate_1.validateFunction)('onNext', onNext);\\n        (0, validate_1.validateFunction)('onError', onError, { optional: true });\\n        const watch = new (require('../watch').DocumentWatch)(this.firestore, this);\\n        return watch.onSnapshot((readTime, size, docs) =\u003e {\\n            for (const document of docs()) {\\n                if (document.ref.path === this.path) {\\n                    onNext(document);\\n                    return;\\n                }\\n            }\\n            // The document is missing.\\n            const ref = new DocumentReference(this._firestore, this._path, this._converter);\\n            const document = new document_1.DocumentSnapshotBuilder(ref);\\n            document.readTime = readTime;\\n            onNext(document.build());\\n        }, onError || console.error);\\n    }\\n    /**\\n     * Returns true if this `DocumentReference` is equal to the provided value.\\n     *\\n     * @param {*} other The value to compare against.\\n     * @return {boolean} true if this `DocumentReference` is equal to the provided\\n     * value.\\n     */\\n    isEqual(other) {\\n        return (this === other ||\\n            (other instanceof DocumentReference \u0026\u0026\\n                this._firestore === other._firestore \u0026\u0026\\n                this._path.isEqual(other._path) \u0026\u0026\\n                this._converter === other._converter));\\n    }\\n    /**\\n     * Converts this DocumentReference to the Firestore Proto representation.\\n     *\\n     * @private\\n     * @internal\\n     */\\n    toProto() {\\n        return { referenceValue: this.formattedName };\\n    }\\n    /**\\n     * Applies a custom data converter to this DocumentReference, allowing you to\\n     * use your own custom model objects with Firestore. When you call set(),\\n     * get(), etc. on the returned DocumentReference instance, the provided\\n     * converter will convert between Firestore data of type `NewDbModelType` and\\n     * your custom type `NewAppModelType`.\\n     *\\n     * Using the converter allows you to specify generic type arguments when\\n     * storing and retrieving objects from Firestore.\\n     *\\n     * Passing in `null` as the converter parameter removes the current\\n     * converter.\\n     *\\n     * @example\\n     * ```\\n     * class Post {\\n     *   constructor(readonly title: string, readonly author: string) {}\\n     *\\n     *   toString(): string {\\n     *     return this.title + ', by ' + this.author;\\n     *   }\\n     * }\\n     *\\n     * const postConverter = {\\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\\n     *     return {title: post.title, author: post.author};\\n     *   },\\n     *   fromFirestore(\\n     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\\n     *   ): Post {\\n     *     const data = snapshot.data();\\n     *     return new Post(data.title, data.author);\\n     *   }\\n     * };\\n     *\\n     * const postSnap = await Firestore()\\n     *   .collection('posts')\\n     *   .withConverter(postConverter)\\n     *   .doc().get();\\n     * const post = postSnap.data();\\n     * if (post !== undefined) {\\n     *   post.title; // string\\n     *   post.toString(); // Should be defined\\n     *   post.someNonExistentProperty; // TS error\\n     * }\\n     *\\n     * ```\\n     * @param {FirestoreDataConverter | null} converter Converts objects to and\\n     * from Firestore. Passing in `null` removes the current converter.\\n     * @return A DocumentReference that uses the provided converter.\\n     */\\n    withConverter(converter) {\\n        return new DocumentReference(this.firestore, this._path, converter !== null \u0026\u0026 converter !== void 0 ? converter : (0, types_1.defaultConverter)());\\n    }\\n},\\\"name\\\",{value:\\\"DocumentReference\\\"})\"\n"])</script><script>self.__next_f.push([1,"12a:\"$12b\"\n89:{\"_firestore\":\"$8a\",\"_path\":\"$123\",\"_converter\":\"$127\",\"\":\"$P12a\"}\n"])</script><script>self.__next_f.push([1,"12e:\"$EObject.defineProperty(class Timestamp {\\n    /**\\n     * Creates a new timestamp with the current date, with millisecond precision.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.set({ updateTime:Firestore.Timestamp.now() });\\n     *\\n     * ```\\n     * @return {Timestamp} A new `Timestamp` representing the current date.\\n     */\\n    static now() {\\n        return Timestamp.fromMillis(Date.now());\\n    }\\n    /**\\n     * Creates a new timestamp from the given date.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * let date = Date.parse('01 Jan 2000 00:00:00 GMT');\\n     * documentRef.set({ startTime:Firestore.Timestamp.fromDate(date) });\\n     *\\n     * ```\\n     * @param {Date} date The date to initialize the `Timestamp` from.\\n     * @return {Timestamp} A new `Timestamp` representing the same point in time\\n     * as the given date.\\n     */\\n    static fromDate(date) {\\n        return Timestamp.fromMillis(date.getTime());\\n    }\\n    /**\\n     * Creates a new timestamp from the given number of milliseconds.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.set({ startTime:Firestore.Timestamp.fromMillis(42) });\\n     *\\n     * ```\\n     * @param {number} milliseconds Number of milliseconds since Unix epoch\\n     * 1970-01-01T00:00:00Z.\\n     * @return {Timestamp}  A new `Timestamp` representing the same point in time\\n     * as the given number of milliseconds.\\n     */\\n    static fromMillis(milliseconds) {\\n        const seconds = Math.floor(milliseconds / 1000);\\n        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\\n        return new Timestamp(seconds, nanos);\\n    }\\n    /**\\n     * Generates a `Timestamp` object from a Timestamp proto.\\n     *\\n     * @private\\n     * @internal\\n     * @param {Object} timestamp The `Timestamp` Protobuf object.\\n     */\\n    static fromProto(timestamp) {\\n        return new Timestamp(Number(timestamp.seconds || 0), timestamp.nanos || 0);\\n    }\\n    /**\\n     * Creates a new timestamp.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.set({ startTime:new Firestore.Timestamp(42, 0) });\\n     *\\n     * ```\\n     * @param {number} seconds The number of seconds of UTC time since Unix epoch\\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\\n     * 9999-12-31T23:59:59Z inclusive.\\n     * @param {number} nanoseconds The non-negative fractions of a second at\\n     * nanosecond resolution. Negative second values with fractions must still\\n     * have non-negative nanoseconds values that count forward in time. Must be\\n     * from 0 to 999,999,999 inclusive.\\n     */\\n    constructor(seconds, nanoseconds) {\\n        (0, validate_1.validateInteger)('seconds', seconds, {\\n            minValue: MIN_SECONDS,\\n            maxValue: MAX_SECONDS,\\n        });\\n        (0, validate_1.validateInteger)('nanoseconds', nanoseconds, {\\n            minValue: 0,\\n            maxValue: 999999999,\\n        });\\n        this._seconds = seconds;\\n        this._nanoseconds = nanoseconds;\\n    }\\n    /**\\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.get().then(snap =\u003e {\\n     *   let updated = snap.updateTime;\\n     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\\n     * });\\n     *\\n     * ```\\n     * @type {number}\\n     */\\n    get seconds() {\\n        return this._seconds;\\n    }\\n    /**\\n     * The non-negative fractions of a second at nanosecond resolution.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.get().then(snap =\u003e {\\n     *   let updated = snap.updateTime;\\n     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\\n     * });\\n     *\\n     * ```\\n     * @type {number}\\n     */\\n    get nanoseconds() {\\n        return this._nanoseconds;\\n    }\\n    /**\\n     * Returns a new `Date` corresponding to this timestamp. This may lose\\n     * precision.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.get().then(snap =\u003e {\\n     *   console.log(`Document updated at: ${snap.updateTime.toDate()}`);\\n     * });\\n     *\\n     * ```\\n     * @return {Date} JavaScript `Date` object representing the same point in time\\n     * as this `Timestamp`, with millisecond precision.\\n     */\\n    toDate() {\\n        return new Date(this._seconds * 1000 + Math.round(this._nanoseconds / MS_TO_NANOS));\\n    }\\n    /**\\n     * Returns the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.get().then(snap =\u003e {\\n     *   let startTime = snap.get('startTime');\\n     *   let endTime = snap.get('endTime');\\n     *   console.log(`Duration: ${endTime - startTime}`);\\n     * });\\n     *\\n     * ```\\n     * @return {number} The point in time corresponding to this timestamp,\\n     * represented as the number of milliseconds since Unix epoch\\n     * 1970-01-01T00:00:00Z.\\n     */\\n    toMillis() {\\n        return this._seconds * 1000 + Math.floor(this._nanoseconds / MS_TO_NANOS);\\n    }\\n    /**\\n     * Returns 'true' if this `Timestamp` is equal to the provided one.\\n     *\\n     * @example\\n     * ```\\n     * let documentRef = firestore.doc('col/doc');\\n     *\\n     * documentRef.get().then(snap =\u003e {\\n     *   if (snap.createTime.isEqual(snap.updateTime)) {\\n     *     console.log('Document is in its initial state.');\\n     *   }\\n     * });\\n     *\\n     * ```\\n     * @param {any} other The `Timestamp` to compare against.\\n     * @return {boolean} 'true' if this `Timestamp` is equal to the provided one.\\n     */\\n    isEqual(other) {\\n        return (this === other ||\\n            (other instanceof Timestamp \u0026\u0026\\n                this._seconds === other.seconds \u0026\u0026\\n                this._nanoseconds === other.nanoseconds));\\n    }\\n    /**\\n     * Generates the Protobuf `Timestamp` object for this timestamp.\\n     *\\n     * @private\\n     * @internal\\n     * @returns {Object} The `Timestamp` Protobuf object.\\n     */\\n    toProto() {\\n        const timestamp = {};\\n        if (this.seconds) {\\n            timestamp.seconds = this.seconds.toString();\\n        }\\n        if (this.nanoseconds) {\\n            timestamp.nanos = this.nanoseconds;\\n        }\\n        return { timestampValue: timestamp };\\n    }\\n    /**\\n     * Converts this object to a primitive `string`, which allows `Timestamp` objects to be compared\\n     * using the `\u003e`, `\u003c=`, `\u003e=` and `\u003e` operators.\\n     *\\n     * @return {string} a string encoding of this object.\\n     */\\n    valueOf() {\\n        // This method returns a string of the form \u003cseconds\u003e.\u003cnanoseconds\u003e where \u003cseconds\u003e is\\n        // translated to have a non-negative value and both \u003cseconds\u003e and \u003cnanoseconds\u003e are left-padded\\n        // with zeroes to be a consistent length. Strings with this format then have a lexicographical\\n        // ordering that matches the expected ordering. The \u003cseconds\u003e translation is done to avoid\\n        // having a leading negative sign (i.e. a leading '-' character) in its string representation,\\n        // which would affect its lexicographical ordering.\\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\\n        // Note: Up to 12 decimal digits are required to represent all valid 'seconds' values.\\n        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\\n        return formattedSeconds + '.' + formattedNanoseconds;\\n    }\\n},\\\"name\\\",{value:\\\"Timestamp\\\"})\"\n"])</script><script>self.__next_f.push([1,"12d:\"$12e\"\n12c:{\"_seconds\":1766030868,\"_nanoseconds\":299162000,\"\":\"$P12d\"}\n12f:{\"_seconds\":1765909774,\"_nanoseconds\":674155000,\"\":\"$P12e\"}\n130:{\"_seconds\":1765909774,\"_nanoseconds\":674155000,\"\":\"$P12e\"}\n"])</script><script>self.__next_f.push([1,"132:\"$EObject.defineProperty(class QueryDocumentSnapshot extends DocumentSnapshot {\\n    /**\\n     * The time the document was created.\\n     *\\n     * @type {Timestamp}\\n     * @name QueryDocumentSnapshot#createTime\\n     * @readonly\\n     * @override\\n     *\\n     * @example\\n     * ```\\n     * let query = firestore.collection('col');\\n     *\\n     * query.get().forEach(snapshot =\u003e {\\n     *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\\n     * });\\n     * ```\\n     */\\n    get createTime() {\\n        return super.createTime;\\n    }\\n    /**\\n     * The time the document was last updated (at the time the snapshot was\\n     * generated).\\n     *\\n     * @type {Timestamp}\\n     * @name QueryDocumentSnapshot#updateTime\\n     * @readonly\\n     * @override\\n     *\\n     * @example\\n     * ```\\n     * let query = firestore.collection('col');\\n     *\\n     * query.get().forEach(snapshot =\u003e {\\n     *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\\n     * });\\n     * ```\\n     */\\n    get updateTime() {\\n        return super.updateTime;\\n    }\\n    /**\\n     * Retrieves all fields in the document as an object.\\n     *\\n     * @override\\n     *\\n     * @returns {T} An object containing all fields in the document.\\n     *\\n     * @example\\n     * ```\\n     * let query = firestore.collection('col');\\n     *\\n     * query.get().forEach(documentSnapshot =\u003e {\\n     *   let data = documentSnapshot.data();\\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\\n     * });\\n     * ```\\n     */\\n    data() {\\n        const data = super.data();\\n        if (!data) {\\n            throw new Error('The data in a QueryDocumentSnapshot should always exist.');\\n        }\\n        return data;\\n    }\\n},\\\"name\\\",{value:\\\"QueryDocumentSnapshot\\\"})\"\n"])</script><script>self.__next_f.push([1,"131:\"$132\"\n86:{\"_fieldsProto\":\"$88\",\"_ref\":\"$89\",\"_serializer\":\"$8d\",\"_readTime\":\"$12c\",\"_createTime\":\"$12f\",\"_updateTime\":\"$130\",\"\":\"$P131\"}\n134:\"$EObject.defineProperty(class ServiceClientImpl extends client_1.Client {\\n    },\\\"name\\\",{value:\\\"ServiceClientImpl\\\"})\"\n133:\"$134\"\n114:{\"\":\"$P133\"}\n11c:\n"])</script><script>self.__next_f.push([1,"136:{\"name\":\"FAQStructuredData\",\"key\":null,\"env\":\"Server\",\"owner\":\"$3f\",\"stack\":[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",589,264,574,1,false]],\"props\":{\"role\":{\"slug\":\"project-manager-resume-india\",\"job_title\":\"Project Manager\",\"experience_level\":\"Mid-Senior\",\"avg_salary_india\":\"â‚¹15L - â‚¹35L\",\"summary_text\":\"Passionate Project Manager seeking to leverage extensive background in enhancing business performance to contribute to organizational success.\",\"hard_skills\":[\"Project Expertise\",\"Project Management\",\"Communication\",\"Problem Solving\"],\"soft_skills\":[\"Leadership\",\"Teamwork\",\"Adaptability\",\"Time Management\",\"Critical Thinking\"],\"common_mistakes\":\"Using generic templates that don't highlight specific Project Manager achievements. Failing to quantify results (e.g., 'improved efficiency by 20%').\",\"seo_title\":\"Project Manager Resume Format (2026) | Download Free Template\",\"meta_description\":\"Download professional Project Manager resume format. Get salary insights, career path, and expert tips for Project Manager jobs in India.\",\"keywords\":[\"Project Manager resume\",\"Project Manager cv format\",\"resume for Project Manager\"],\"faqs\":[{\"q\":\"How do I write a resume for a Project Manager?\",\"a\":\"Focus on your relevant experience and specific achievements. Use a reverse-chronological format.\"},{\"q\":\"What skills are required for a Project Manager?\",\"a\":\"Key skills include technical proficiency in your domain, problem-solving, and communication.\"}],\"industry_context\":\"The demand for Project Manager professionals is growing rapidly in India's evolving market.\",\"ats_tips\":\"$Y\",\"day_in_life\":\"A typical day as a Project Manager is dynamic and engaging. You start by planning project timelines to set the tone for the day. Mid-day often involves planning project timelines and developing strategic roadmaps, ensuring alignment with team goals. In the afternoon, you focus on reviewing budget reports, which is critical for project success. The day wraps up with analyzing performance metrics to prepare for the next day's challenges.\",\"career_path\":\"$Y\",\"salary_breakdown\":\"$Y\",\"top_certifications\":\"$Y\",\"tech_stack_breakdown\":\"$Y\",\"source\":\"firestore\"}}}\n"])</script><script>self.__next_f.push([1,"137:[[\"FAQStructuredData\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",488,263,475,1,false]]\n139:{\"name\":\"JobPostingStructuredData\",\"key\":null,\"env\":\"Server\",\"owner\":\"$3f\",\"stack\":[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",596,264,574,1,false]],\"props\":{\"role\":\"$136:props:role\"}}\n13a:[[\"JobPostingStructuredData\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",526,263,500,1,false]]\n13c:{\"name\":\"BreadcrumbStructuredData\",\"key\":null,\"env\":\"Server\",\"owner\":\"$3f\",\"stack\":[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",603,264,574,1,false]],\"props\":{\"role\":\"$136:props:role\"}}\n13d:[[\"BreadcrumbStructuredData\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",563,263,538,1,false]]\n13e:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",610,264,574,1,false]]\n13f:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",613,272,574,1,false]]\n140:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",616,280,574,1,false]]\n141:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",618,294,574,1,false]]\n142:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",621,292,574,1,false]]\n144:{\"name\":\"Target\",\"key\":null,\"env\":\"Server\",\"owner\":\"$3f\",\"stack\":[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",624,300,574,1,false]],\"props\":{\"className\":\"w-4 h-4\"}}\n145:{\"name\":\"\",\"key\":null,\"env\":\"Server\",\"owner\":\"$144\",\"stack\":[],\"props\":{\"ref\":\"$undefined\",\"iconNode\":[[\"circle\",{\"cx\":\"12\",\"cy\":\"12\",\"r\":\"10\",\"key\":\"1mglay\"}],[\"circle\",{\"cx\":\"12\",\"cy\":\"12\",\"r\":\"6\",\"key\":\"1vlfrh\"}],[\"circle\",{\"cx\":\"12\",\"cy\":\"12\",\"r\":\"2\",\"key\":\"1c9p78\"}]],\"className\":\"lucide-target w-4 h-4\"}}\n146:[]\n147:[[\"Array.map\",\"\",0,0,0,0,false]]\n148:[[\"Array.map\",\"\",0,0,0,0,false]]\n149:[[\"Array.map\",\"\",0,0,0,0,false]]\n14a:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",631,300,574,1,false]]\n14b:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",645,292,574,1,false]]\n14c:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",650,300,574,1,false]]\n14d:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",664,292,574,1,false]]\n14e:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",672,292,574,1,false]]\n153:\"$EObject.defineProperty(({ className, ...props }, ref)=\u003e(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__[\\\"createElement\\\"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__[\\\"default\\\"], {\\n            ref,\\n            iconNode,\\n            className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__[\\\"mergeClasses\\\"])(`lucide-${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__[\\\"toKebabCase\\\"])(iconName)}`, className),\\n            ...props\\n        }),\\\"name\\\",{value:\\\"FileText\\\"})\"\n151:{\"$$typeof\":\"$152\",\"render\":\"$153\"}\n154:{\"className\":\"w-5 h-5\"}\n155:[[\"ResumeFormatPage\",\"/Users/ra"])</script><script>self.__next_f.push([1,"huldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",679,308,574,1,false]]\n150:{\"name\":\"LinkComponent\",\"key\":null,\"env\":\"Server\",\"owner\":\"$3f\",\"stack\":[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",675,300,574,1,false]],\"props\":{\"href\":\"/resume-builder\",\"className\":\"w-full sm:w-auto px-8 py-4 bg-blue-600 text-white rounded-xl font-bold text-lg hover:bg-blue-700 transition-all shadow-lg hover:shadow-blue-200 flex items-center justify-center gap-2\",\"children\":[[\"$\",\"$151\",null,\"$154\",\"$3f\",\"$155\",1],\"Create My Resume\"]}}\n156:[]\n159:{\"name\":\"FileText\",\"key\":null,\"env\":\"Server\",\"owner\":\"$3f\",\"stack\":[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",679,308,574,1,false]],\"props\":\"$154\"}\n15a:{\"name\":\"\",\"key\":null,\"env\":\"Server\",\"owner\":\"$159\",\"stack\":[],\"props\":{\"ref\":\"$undefined\",\"iconNode\":[[\"path\",{\"d\":\"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z\",\"key\":\"1rqfz7\"}],[\"path\",{\"d\":\"M14 2v4a2 2 0 0 0 2 2h4\",\"key\":\"tnqrlb\"}],[\"path\",{\"d\":\"M10 9H8\",\"key\":\"b1mrlr\"}],\"$Y\",\"$Y\"],\"className\":\"lucide-file-text w-5 h-5\"}}\n15b:[]\n15c:[[\"Array.map\",\"\",0,0,0,0,false]]\n15d:[[\"Array.map\",\"\",0,0,0,0,false]]\n15e:[[\"Array.map\",\"\",0,0,0,0,false]]\n15f:[[\"Array.map\",\"\",0,0,0,0,false]]\n160:[[\"Array.map\",\"\",0,0,0,0,false]]\n165:\"$EObject.defineProperty(({ className, ...props }, ref)=\u003e(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__[\\\"createElement\\\"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__[\\\"default\\\"], {\\n            ref,\\n            iconNode,\\n            className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__[\\\"mergeClasses\\\"])(`lucide-${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__[\\\"toKebabCase\\\"])(iconName)}`, className),\\n            ...props\\n        }),\\\"name\\\",{value:\\\"ArrowRight\\\"})\"\n163:{\"$$typeof\":\"$164\",\"render\":\"$165\"}\n166:{\"className\":\"w-5 h-5\"}\n167:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",698,308,574,1,false]]\n162:{\"name\":\"LinkComponent\",\"key\":null,\"env\":\"Server\",\"owner\":\"$3f\",\"stack\":[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",693,300,574,1,false]],\"props\":{\"href\":\"/resumes-list\",\"className\":\"w-full sm:w-auto px-8 py-4 bg-white text-gray-700 border-2 border-gray-200 rounded-xl font-bold text-lg hover:border-blue-200 hover:bg-blue-50 transition-all flex items-center justify-center gap-2\",\"children\":[\"View All Formats\",[\"$\",\"$163\",null,\"$166\",\"$3f\",\"$167\",1]]}}\n168:[]\n16a:{\"name\":\"ArrowRight\",\"key\":null,\"env\":\"Server\",\"owner\":\"$3f\",\"stack\":[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",698,308,574,1,false]],\"props\":\"$166\"}\n16b:{\"name\":\"\",\"key\":null,\"env\":\"Server\",\"owner\":\"$16a\",\"stack\":[],\"props\":{\"ref\":\"$undefined\",\"iconNode\":[[\"path\",{\"d\":\"M5 12h14\",\"key\":\"1ays0h\"}],[\"path\",{\"d\":\"m12 5 7 7-7 7\",\"key\":\"xquz4c\"}]],\"className\":\"lucide-arrow-right w-5 h-5\"}}\n16c:[]\n16d:[[\"Array.map\",\"\",0,0,0,0,false]]\n16e:[[\"Array.map\",\"\",0,0,0,0,false]]\n16f:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",728,280,574,1,false]]\n170:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",731,288,574,1,false]]\n171:[[\"ResumeFormatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",738,288,574,1,false]]\n172:[[\"ResumeFo"])</script><script>self.__next_f.push([1,"rmatPage\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",757,272,574,1,false]]\n3e:D{\"time\":22.215916998684406}\n3e:D{\"awaited\":\"$85\",\"env\":\"Server\",\"owner\":\"$3f\",\"stack\":\"$87\"}\n3e:D{\"time\":390.7744999974966}\n3e:D{\"time\":398.35254199802876}\n135:D{\"time\":398.43558299541473}\n135:D\"$136\"\n135:D{\"time\":398.5019579976797}\n135:[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"FAQPage\\\",\\\"mainEntity\\\":[{\\\"@type\\\":\\\"Question\\\",\\\"name\\\":\\\"How do I write a resume for a Project Manager?\\\",\\\"acceptedAnswer\\\":{\\\"@type\\\":\\\"Answer\\\",\\\"text\\\":\\\"Focus on your relevant experience and specific achievements. Use a reverse-chronological format.\\\"}},{\\\"@type\\\":\\\"Question\\\",\\\"name\\\":\\\"What skills are required for a Project Manager?\\\",\\\"acceptedAnswer\\\":{\\\"@type\\\":\\\"Answer\\\",\\\"text\\\":\\\"Key skills include technical proficiency in your domain, problem-solving, and communication.\\\"}}]}\"}},\"$136\",\"$137\",1]\n138:D{\"time\":398.5428330004215}\n138:D\"$139\"\n138:D{\"time\":398.5910829976201}\n138:[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"Project Manager Resume Format (2026) | Download Free Template\\\",\\\"description\\\":\\\"Download professional Project Manager resume format. Get salary insights, career path, and expert tips for Project Manager jobs in India.\\\",\\\"author\\\":{\\\"@type\\\":\\\"Organization\\\",\\\"name\\\":\\\"ResumeGyani\\\",\\\"url\\\":\\\"https://resumegyani.in\\\"},\\\"publisher\\\":{\\\"@type\\\":\\\"Organization\\\",\\\"name\\\":\\\"ResumeGyani\\\",\\\"logo\\\":{\\\"@type\\\":\\\"ImageObject\\\",\\\"url\\\":\\\"https://resumegyani.in/resumegyani-logo-blue-transparent.png\\\"}},\\\"datePublished\\\":\\\"2025-01-01\\\",\\\"dateModified\\\":\\\"2025-01-01\\\",\\\"mainEntityOfPage\\\":{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://resumegyani.in/resume-format-for/project-manager-resume-india\\\"}}\"}},\"$139\",\"$13a\",1]\n13b:D{\"time\":398.6220829933882}\n13b:D\"$13c\"\n13b:D{\"time\":398.6555419936776}\n13b:[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"BreadcrumbList\\\",\\\"itemListElement\\\":[{\\\"@type\\\":\\\"ListItem\\\",\\\"position\\\":1,\\\"name\\\":\\\"Home\\\",\\\"item\\\":\\\"https://resumegyani.in\\\"},{\\\"@type\\\":\\\"ListItem\\\",\\\"position\\\":2,\\\"name\\\":\\\"Resume Formats\\\",\\\"item\\\":\\\"https://resumegyani.in/resume-format-for\\\"},{\\\"@type\\\":\\\"ListItem\\\",\\\"position\\\":3,\\\"name\\\":\\\"Project Manager\\\",\\\"item\\\":\\\"https://resumegyani.in/resume-format-for/project-manager-resume-india\\\"}]}\"}},\"$13c\",\"$13d\",1]\n143:D{\"time\":398.7709579989314}\n143:D\"$144\"\n143:D{\"time\":398.84558299928904}\n143:D\"$145\"\n143:D{\"time\":398.92179199308157}\n143:[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-target w-4 h-4\",\"children\":[[\"$\",\"circle\",\"1mglay\",{\"cx\":\"12\",\"cy\":\"12\",\"r\":\"10\"},\"$145\",\"$147\",0],[\"$\",\"circle\",\"1vlfrh\",{\"cx\":\"12\",\"cy\":\"12\",\"r\":\"6\"},\"$145\",\"$148\",0],[\"$\",\"circle\",\"1c9p78\",{\"cx\":\"12\",\"cy\":\"12\",\"r\":\"2\"},\"$145\",\"$149\",0],\"$undefined\"]},\"$145\",\"$146\",1]\n14f:D{\"time\":399.2112919986248}\n14f:D\"$150\"\n14f:D{\"time\":399.25466699898243}\n158:D{\"time\":399.296875}\n158:D\"$159\"\n158:D{\"time\":399.34508299827576}\n158:D\"$15a\"\n158:D{\"time\":399.4219169989228}\n158:[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-file-text w-5 h-5\",\"children\":[[\"$\",\"path\",\"1rqfz7\",{\"d\":\"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z\"},\"$15a\",\"$15c\",0],[\"$\",\"path\",\"tnqrlb\",{\"d\":\"M14 2v4a2 2 0 0 0 2 2h4\"},\"$15a\",\"$15d\",0],[\"$\",\"path\",\"b1mrlr\",{\"d\":\"M10 9H8\"},\"$15a\",\"$15e\",0],[\"$\",\"path\",\"t4e002\",{\"d\":\"M16 13H8\"},\"$15a\",\"$15f\",0],[\"$\",\"path\",\"z1uh3a\",{\"d\":\"M16 17H8\"},\"$15a\",\"$160\",0],\"$undefined\"]},\"$15a\",\"$"])</script><script>self.__next_f.push([1,"15b\",1]\n14f:[\"$\",\"$L157\",null,{\"href\":\"/resume-builder\",\"className\":\"w-full sm:w-auto px-8 py-4 bg-blue-600 text-white rounded-xl font-bold text-lg hover:bg-blue-700 transition-all shadow-lg hover:shadow-blue-200 flex items-center justify-center gap-2\",\"children\":[\"$158\",\"Create My Resume\"]},\"$150\",\"$156\",1]\n161:D{\"time\":399.60249999910593}\n161:D\"$162\"\n161:D{\"time\":399.6241249963641}\n169:D{\"time\":399.64458299428225}\n169:D\"$16a\"\n169:D{\"time\":399.68329199403524}\n169:D\"$16b\"\n169:D{\"time\":399.72874999791384}\n169:[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-arrow-right w-5 h-5\",\"children\":[[\"$\",\"path\",\"1ays0h\",{\"d\":\"M5 12h14\"},\"$16b\",\"$16d\",0],[\"$\",\"path\",\"xquz4c\",{\"d\":\"m12 5 7 7-7 7\"},\"$16b\",\"$16e\",0],\"$undefined\"]},\"$16b\",\"$16c\",1]\n161:[\"$\",\"$L157\",null,{\"href\":\"/resumes-list\",\"className\":\"w-full sm:w-auto px-8 py-4 bg-white text-gray-700 border-2 border-gray-200 rounded-xl font-bold text-lg hover:border-blue-200 hover:bg-blue-50 transition-all flex items-center justify-center gap-2\",\"children\":[\"View All Formats\",\"$169\"]},\"$162\",\"$168\",1]\n"])</script><script>self.__next_f.push([1,"3e:[\"$135\",\"$138\",\"$13b\",[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gradient-to-b from-white to-gray-50\",\"children\":[[\"$\",\"section\",null,{\"className\":\"relative pt-20 pb-12 overflow-hidden\",\"children\":[[\"$\",\"div\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 relative z-10\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center max-w-3xl mx-auto\",\"children\":[[\"$\",\"div\",null,{\"className\":\"inline-flex items-center gap-2 bg-blue-50 text-blue-700 px-4 py-2 rounded-full mb-6 border border-blue-100\",\"children\":[\"$143\",[\"$\",\"span\",null,{\"className\":\"font-semibold text-sm\",\"children\":\"ATS-Optimized for India\"},\"$3f\",\"$14a\",1]]},\"$3f\",\"$142\",1],[\"$\",\"h1\",null,{\"className\":\"text-4xl md:text-5xl lg:text-6xl font-bold text-gray-900 mb-6 leading-tight\",\"children\":[\"Project Manager\",\" \",[\"$\",\"span\",null,{\"className\":\"text-blue-600\",\"children\":\"Resume Format\"},\"$3f\",\"$14c\",1]]},\"$3f\",\"$14b\",1],[\"$\",\"p\",null,{\"className\":\"text-xl text-gray-600 mb-8 leading-relaxed\",\"children\":\"Download professional Project Manager resume format. Get salary insights, career path, and expert tips for Project Manager jobs in India.\"},\"$3f\",\"$14d\",1],[\"$\",\"div\",null,{\"className\":\"flex flex-col sm:flex-row gap-4 justify-center items-center mb-12\",\"children\":[\"$14f\",\"$161\"]},\"$3f\",\"$14e\",1]]},\"$3f\",\"$141\",1]},\"$3f\",\"$140\",1],[\"$\",\"div\",null,{\"className\":\"absolute top-0 left-0 w-full h-full overflow-hidden -z-0 opacity-40\",\"children\":[[\"$\",\"div\",null,{\"className\":\"absolute top-0 right-0 w-96 h-96 bg-blue-100 rounded-full blur-3xl transform translate-x-1/2 -translate-y-1/2\"},\"$3f\",\"$170\",1],[\"$\",\"div\",null,{\"className\":\"absolute bottom-0 left-0 w-96 h-96 bg-purple-100 rounded-full blur-3xl transform -translate-x-1/2 translate-y-1/2\"},\"$3f\",\"$171\",1]]},\"$3f\",\"$16f\",1]]},\"$3f\",\"$13f\",1],[\"$\",\"$L173\",null,{\"role\":{\"slug\":\"project-manager-resume-india\",\"job_title\":\"Project Manager\",\"experience_level\":\"Mid-Senior\",\"avg_salary_india\":\"â‚¹15L - â‚¹35L\",\"summary_text\":\"Passionate Project Manager seeking to leverage extensive background in enhancing business performance to contribute to organizational success.\",\"hard_skills\":[\"Project Expertise\",\"Project Management\",\"Communication\",\"Problem Solving\"],\"soft_skills\":[\"Leadership\",\"Teamwork\",\"Adaptability\",\"Time Management\",\"Critical Thinking\"],\"common_mistakes\":\"Using generic templates that don't highlight specific Project Manager achievements. Failing to quantify results (e.g., 'improved efficiency by 20%').\",\"seo_title\":\"Project Manager Resume Format (2026) | Download Free Template\",\"meta_description\":\"Download professional Project Manager resume format. Get salary insights, career path, and expert tips for Project Manager jobs in India.\",\"keywords\":[\"Project Manager resume\",\"Project Manager cv format\",\"resume for Project Manager\"],\"faqs\":[{\"q\":\"How do I write a resume for a Project Manager?\",\"a\":\"Focus on your relevant experience and specific achievements. Use a reverse-chronological format.\"},{\"q\":\"What skills are required for a Project Manager?\",\"a\":\"Key skills include technical proficiency in your domain, problem-solving, and communication.\"}],\"industry_context\":\"The demand for Project Manager professionals is growing rapidly in India's evolving market.\",\"ats_tips\":[\"Use standard fonts\",\"Include relevant keywords\",\"Save as PDF\"],\"day_in_life\":\"A typical day as a Project Manager is dynamic and engaging. You start by planning project timelines to set the tone for the day. Mid-day often involves planning project timelines and developing strategic roadmaps, ensuring alignment with team goals. In the afternoon, you focus on reviewing budget reports, which is critical for project success. The day wraps up with analyzing performance metrics to prepare for the next day's challenges.\",\"career_path\":[\"Project Manager\",\"Lead Manager\",\"Principal Manager\"],\"salary_breakdown\":{\"entry\":\"â‚¹13L - â‚¹15L\",\"mid\":\"â‚¹15L - â‚¹35L\",\"senior\":\"â‚¹35L - â‚¹50L+\"},\"top_certifications\":[\"Certified Manager Professional\",\"Project Management Professional (PMP)\"],\"tech_stack_breakdown\":{\"Essential Tools\":[\"JIRA\",\"Slack\",\"Microsoft Office\",\"Zoom\"],\"Domain Skills\":[\"Core Competency A\",\"Core Competency B\"]},\"source\":\"firestore\"},\"relatedRoles\":[{\"slug\":\"operations-manager-resume-india\",\"job_title\":\"Operations Manager\",\"experience_level\":\"Mid-Senior\",\"avg_salary_india\":\"â‚¹8L - â‚¹20L\",\"summary_text\":\"Operations Manager with 6+ years of experience in process optimization, supply chain management, and operations excellence. Expertise in lean methodologies, quality control, and team management. Improved operational efficiency by 30% and reduced costs by 20% for US companies.\",\"hard_skills\":[\"Operations Management\",\"Process Improvement\",\"Supply Chain\",\"Quality Control\",\"Lean/Six Sigma\",\"ERP Systems\",\"Data Analysis\",\"Project Management\",\"Inventory Management\",\"Vendor Management\"],\"soft_skills\":[\"Process Thinking\",\"Problem Solving\",\"Leadership\",\"Coordination\",\"Strategic Thinking\"],\"common_mistakes\":\"Not quantifying operational improvements, missing process improvement methodologies, not highlighting cost reduction, or failing to mention team management.\",\"seo_title\":\"Best Operations Manager Resume Format for India (2026) | ATS-Optimized\",\"meta_description\":\"Create a winning Operations Manager resume for India. Get ATS-optimized template, salary insights (â‚¹8L-â‚¹20L), key skills (Operations, Process Improvement, Supply Chain), and expert tips for operations manager roles.\",\"keywords\":[\"operations manager resume\",\"operations manager resume india\",\"operations manager resume template\",\"operations head resume\",\"operations manager resume for experienced\",\"supply chain manager resume\",\"ats resume operations manager\"],\"faqs\":[{\"q\":\"Should I quantify operational improvements in my resume?\",\"a\":\"Absolutely! Mention metrics like 'improved efficiency by 30%', 'reduced costs by 20%', 'increased throughput by 25%', or 'reduced defects by 40%'. Quantified improvements demonstrate operations effectiveness.\"},{\"q\":\"How important are process improvement methodologies?\",\"a\":\"Very important. Mention Lean, Six Sigma, Kaizen, or other methodologies you've used. Also mention if you're certified (Green Belt, Black Belt). Process improvement knowledge is essential for operations roles.\"},{\"q\":\"Should I mention supply chain experience?\",\"a\":\"Yes! Mention supply chain management, vendor management, inventory management, or logistics if you have experience. Many operations roles involve supply chain coordination. Also mention ERP systems you've used.\"}],\"industry_context\":\"Operations Management is in demand across manufacturing, e-commerce, and service industries in India. Top recruiters include manufacturing companies, e-commerce (Flipkart, Amazon), logistics companies, and startups. High demand in Mumbai, Bangalore, and Delhi.\",\"ats_tips\":[\"Quantify operational improvements (efficiency, costs, quality)\",\"List process improvement methodologies (Lean, Six Sigma)\",\"Include supply chain and logistics experience\",\"Mention ERP systems and team size managed\"]},{\"slug\":\"supply-chain-manager-resume-india\",\"job_title\":\"Supply Chain Manager\",\"experience_level\":\"Mid-Senior\",\"avg_salary_india\":\"â‚¹8L - â‚¹20L\",\"summary_text\":\"Supply Chain Manager with 6+ years of experience in logistics, inventory management, and vendor relations. Expertise in supply chain optimization, cost reduction, and process improvement. Reduced supply chain costs by 25% and improved delivery time by 30% for US companies.\",\"hard_skills\":[\"Supply Chain Management\",\"Logistics\",\"Inventory Management\",\"Vendor Management\",\"ERP Systems (SAP, Oracle)\",\"Demand Planning\",\"Warehouse Management\",\"Transportation\",\"Cost Optimization\",\"Process Improvement\"],\"soft_skills\":[\"Strategic Thinking\",\"Negotiation\",\"Problem Solving\",\"Coordination\",\"Analytical Thinking\"],\"common_mistakes\":\"Not quantifying cost savings, missing ERP systems, not highlighting vendor management, or failing to mention logistics experience.\",\"seo_title\":\"Best Supply Chain Manager Resume Format for India (2026) | ATS-Optimized\",\"meta_description\":\"Create a winning Supply Chain Manager resume for India. Get ATS-optimized template, salary insights (â‚¹8L-â‚¹20L), key skills (Supply Chain, Logistics, Inventory Management), and expert tips for supply chain roles.\",\"keywords\":[\"supply chain manager resume\",\"supply chain manager resume india\",\"logistics manager resume\",\"supply chain resume template\",\"procurement manager resume\",\"supply chain manager resume for experienced\",\"ats resume supply chain manager\"],\"faqs\":[{\"q\":\"Should I quantify supply chain improvements in my resume?\",\"a\":\"Absolutely! Mention metrics like 'reduced costs by 25%', 'improved delivery time by 30%', 'reduced inventory by 20%', or 'optimized vendor base by 40%'. Quantified improvements demonstrate supply chain effectiveness.\"},{\"q\":\"How important are ERP systems for Supply Chain Managers?\",\"a\":\"Very important. Mention ERP systems like SAP, Oracle, or others you've used. ERP knowledge is essential for supply chain roles. Also mention warehouse management systems (WMS) or transportation management systems (TMS).\"},{\"q\":\"Should I mention vendor management experience?\",\"a\":\"Yes! Mention vendor selection, negotiation, relationship management, or vendor performance improvement. Also mention if you've managed international vendors or reduced vendor base. Vendor management is crucial for supply chain roles.\"}],\"industry_context\":\"Supply Chain Management is in demand across manufacturing, e-commerce, and retail in India. Top recruiters include manufacturing companies, e-commerce (Flipkart, Amazon), retail companies, and logistics firms. High demand in Mumbai, Delhi, and Bangalore.\",\"ats_tips\":[\"Quantify supply chain improvements (costs, delivery, inventory)\",\"List ERP systems (SAP, Oracle, WMS, TMS)\",\"Include vendor management and logistics experience\",\"Mention process improvement and cost optimization\"]},{\"slug\":\"java-developer-resume-india\",\"job_title\":\"Java Developer\",\"experience_level\":\"Mid-Senior\",\"avg_salary_india\":\"â‚¹6L - â‚¹20L\",\"summary_text\":\"Results-oriented Java Developer with 5+ years of experience in building scalable enterprise applications using Spring Boot, Hibernate, and microservices architecture. Proven track record of developing high-performance backend systems for US MNCs like TCS, Infosys, and Wipro.\",\"hard_skills\":[\"Java 8/11/17\",\"Spring Boot\",\"Hibernate/JPA\",\"RESTful APIs\",\"Microservices\",\"MySQL/PostgreSQL\",\"Maven/Gradle\",\"Docker\",\"AWS/Cloud\",\"System Design\"],\"soft_skills\":[\"Problem Solving\",\"Agile Methodology\",\"Team Collaboration\",\"Code Review\",\"Technical Documentation\"],\"common_mistakes\":\"Listing outdated Java versions (Java 6/7), failing to mention Spring Boot or microservices experience, not highlighting cloud deployment skills (AWS/Azure), or missing system design knowledge.\",\"seo_title\":\"Best Java Developer Resume Format for India (2026) | ATS-Optimized Template\",\"meta_description\":\"Create a winning Java Developer resume for India. Get ATS-optimized template, salary insights (â‚¹6L-â‚¹20L), key skills (Spring Boot, Microservices), and expert tips for TCS, Infosys, Wipro applications.\",\"keywords\":[\"java developer resume\",\"java developer resume india\",\"java developer cv format\",\"spring boot resume\",\"java resume template\",\"java developer resume for freshers\",\"java developer resume for experienced\",\"ats resume java developer\",\"java developer resume sample india\"],\"faqs\":[{\"q\":\"Should I include a photo in a Java Developer resume in India?\",\"a\":\"Generally, no. Unless specifically asked by the company, focus on your GitHub profile, project portfolio, and technical certifications. US IT companies prioritize technical skills over photos.\"},{\"q\":\"What Java frameworks should I mention in my resume?\",\"a\":\"Always mention Spring Boot (most in-demand), Hibernate/JPA, and if applicable, Spring Cloud for microservices. Avoid listing outdated frameworks like Struts unless the job specifically requires it.\"},{\"q\":\"How important is system design for a Java Developer resume?\",\"a\":\"Very important for mid-senior roles. Mention experience with microservices architecture, database design, caching strategies (Redis), and message queues (Kafka/RabbitMQ). This differentiates you from junior developers.\"},{\"q\":\"Should I include my father's name or marital status?\",\"a\":\"No. Modern US IT companies (especially MNCs) don't require this information. Keep your resume focused on professional qualifications and skills.\"}],\"industry_context\":\"Java remains the #1 programming language in India, with 70% of enterprise applications built on Java. Major recruiters include TCS, Infosys, Wipro, Cognizant, Accenture, and product companies like Flipkart, Paytm, and Razorpay.\",\"ats_tips\":[\"Use exact keywords from job description (e.g., 'Spring Boot' not just 'Spring')\",\"Mention specific Java versions (Java 11, Java 17) not just 'Java'\",\"Include cloud platforms explicitly (AWS, Azure, GCP)\",\"List database names (MySQL, PostgreSQL, MongoDB) separately\"],\"day_in_life\":\"A typical day for a Java Developer involves starting with a daily standup meeting to sync with the team. You spend a significant portion of the day writing and optimizing Java code using frameworks like Spring Boot. This includes building RESTful APIs, integrating with databases, and fixing bugs. Code reviews are a crucial part of the process, where you review peers' code and get yours reviewed. In the afternoon, you might work on system design, attend sprint planning meetings, or troubleshoot deployment issues on cloud platforms like AWS.\",\"career_path\":[\"Junior Java Developer (0-2 years)\",\"Java Developer (2-5 years)\",\"Senior Java Developer (5-8 years)\",\"Tech Lead / Architect (8+ years)\"],\"salary_breakdown\":{\"entry\":\"â‚¹4L - â‚¹8L\",\"mid\":\"â‚¹8L - â‚¹18L\",\"senior\":\"â‚¹20L - â‚¹40L+\"},\"top_certifications\":[\"Oracle Certified Professional: Java SE Programmer\",\"Spring Professional Certification\",\"AWS Certified Developer - Associate\"],\"tech_stack_breakdown\":{\"Languages\":[\"Java 8/11/17\",\"SQL\",\"HTML/CSS\"],\"Frameworks\":[\"Spring Boot\",\"Hibernate\",\"Microservices\"],\"Tools\":[\"Git\",\"Maven\",\"Jenkins\",\"Docker\",\"JIRA\"],\"Databases\":[\"MySQL\",\"PostgreSQL\",\"MongoDB\"]}},{\"slug\":\"python-developer-resume-india\",\"job_title\":\"Python Developer\",\"experience_level\":\"Mid-Senior\",\"avg_salary_india\":\"â‚¹7L - â‚¹25L\",\"summary_text\":\"Passionate Python Developer with expertise in Django, Flask, and FastAPI frameworks. Specialized in building scalable web applications, REST APIs, and data processing pipelines. Experience with machine learning libraries (Pandas, NumPy, Scikit-learn) and cloud deployment on AWS.\",\"hard_skills\":[\"Python 3.x\",\"Django/Flask/FastAPI\",\"RESTful APIs\",\"PostgreSQL/MySQL\",\"Redis\",\"Celery\",\"Docker\",\"AWS/GCP\",\"Pandas/NumPy\",\"Git/GitHub\"],\"soft_skills\":[\"Agile Development\",\"Code Optimization\",\"API Design\",\"Problem Solving\",\"Technical Mentoring\"],\"common_mistakes\":\"Not specifying Python version (Python 3.8+ is standard), missing framework names (just saying 'Python' instead of 'Django'), not mentioning cloud experience, or failing to highlight data science libraries if applicable.\",\"seo_title\":\"Best Python Developer Resume Format for India (2026) | ATS-Optimized Template\",\"meta_description\":\"Create a winning Python Developer resume for India. Get ATS-optimized template, salary insights (â‚¹7L-â‚¹25L), key skills (Django, FastAPI, AWS), and expert tips for US startups and MNCs.\",\"keywords\":[\"python developer resume\",\"python developer resume india\",\"django developer resume\",\"python resume template\",\"python developer cv format\",\"python developer resume for freshers\",\"python developer resume for experienced\",\"ats resume python developer\",\"python developer resume sample india\"],\"faqs\":[{\"q\":\"Should I mention Python 2.x experience in my resume?\",\"a\":\"No. Python 2 is deprecated. Focus on Python 3.8+ and mention specific versions if you've worked with Python 3.9, 3.10, or 3.11 features.\"},{\"q\":\"Which Python framework is most in-demand in India?\",\"a\":\"Django is most popular for web development, followed by Flask for lightweight APIs. FastAPI is growing rapidly for modern microservices. Mention the one most relevant to your target role.\"},{\"q\":\"How important is mentioning data science libraries for a Python Developer?\",\"a\":\"Very important if targeting data-heavy roles or startups. Mention Pandas, NumPy, and Scikit-learn if you have experience. This opens doors to both backend and data engineering roles.\"},{\"q\":\"Should I include my LeetCode or HackerRank profile?\",\"a\":\"Yes, especially for product companies (Flipkart, Razorpay, Zomato). Include your competitive programming profiles if you have good rankings, as US startups value problem-solving skills.\"}],\"industry_context\":\"Python is the fastest-growing language in India, especially in startups, fintech, and data science. Top recruiters include Razorpay, Paytm, Zomato, Swiggy, and MNCs like Accenture, Capgemini.\",\"ats_tips\":[\"Specify framework names (Django, Flask, FastAPI) separately\",\"Mention Python version (Python 3.9, 3.10, etc.)\",\"Include cloud services (AWS Lambda, EC2, S3) explicitly\",\"List data science libraries if applicable (Pandas, NumPy)\"]},{\"slug\":\"mern-stack-developer-resume-india\",\"job_title\":\"MERN Stack Developer\",\"experience_level\":\"Mid-Senior\",\"avg_salary_india\":\"â‚¹8L - â‚¹22L\",\"summary_text\":\"Full-stack MERN Developer with 4+ years of experience building scalable web applications using MongoDB, Express.js, React, and Node.js. Expertise in RESTful APIs, state management (Redux), and cloud deployment. Delivered 10+ production applications for US startups and MNCs.\",\"hard_skills\":[\"React.js\",\"Node.js\",\"Express.js\",\"MongoDB\",\"Redux/Context API\",\"RESTful APIs\",\"JWT Authentication\",\"Socket.io\",\"AWS/Heroku\",\"Git/GitHub\"],\"soft_skills\":[\"Full-Stack Thinking\",\"API Design\",\"Code Optimization\",\"Agile Development\",\"Problem Solving\"],\"common_mistakes\":\"Not specifying which parts of MERN stack you're strong in, missing state management tools (Redux), not mentioning API design experience, or failing to highlight deployment experience (AWS, Heroku, Vercel).\",\"seo_title\":\"Best MERN Stack Developer Resume Format for India (2026) | ATS-Optimized\",\"meta_description\":\"Create a winning MERN Stack Developer resume for India. Get ATS-optimized template, salary insights (â‚¹8L-â‚¹22L), key skills (React, Node.js, MongoDB), and expert tips for US startups and tech companies.\",\"keywords\":[\"mern stack developer resume\",\"mern developer resume india\",\"full stack developer resume\",\"react nodejs resume\",\"mern resume template\",\"full stack developer resume india\",\"mern stack resume for freshers\",\"ats resume mern developer\"],\"faqs\":[{\"q\":\"Should I mention all MERN technologies separately in my resume?\",\"a\":\"Yes! List React.js, Node.js, Express.js, and MongoDB separately. Also mention related tools like Redux, Socket.io, and deployment platforms (AWS, Heroku). This helps ATS systems match your skills better.\"},{\"q\":\"How important is mentioning state management for MERN developers?\",\"a\":\"Very important. Mention Redux, Context API, or Zustand if you've used them. For senior roles, also mention state management patterns and performance optimization techniques.\"},{\"q\":\"Should I include my GitHub profile with MERN projects?\",\"a\":\"Absolutely! Include your GitHub profile and highlight 2-3 best MERN projects. US startups (Razorpay, Zomato, Swiggy) actively review GitHub profiles during hiring.\"}],\"industry_context\":\"MERN stack is highly popular in US startups and product companies. Top recruiters include Razorpay, Paytm, Zomato, Swiggy, Ola, and MNCs like Accenture, TCS. Demand is highest in Bangalore, Pune, and Gurgaon.\",\"ats_tips\":[\"List each MERN technology separately (React.js, Node.js, Express.js, MongoDB)\",\"Mention state management tools (Redux, Context API)\",\"Include deployment platforms (AWS, Heroku, Vercel, Netlify)\",\"Specify API experience (REST, GraphQL if applicable)\"]}]},\"$3f\",\"$172\",1]]},\"$3f\",\"$13e\",1]]\n"])</script><script>self.__next_f.push([1,"19a:I[\"[project]/node_modules/next/dist/lib/metadata/generate/icon-mark.js [app-client] (ecmascript)\",[\"/_next/static/chunks/node_modules_next_dist_094231d7._.js\",\"/_next/static/chunks/app_favicon_ico_mjs_756560dc._.js\"],\"IconMark\"]\n174:J{\"name\":\"\",\"start\":-70256.52258300036,\"end\":1566.0591249987483,\"env\":\"Server\",\"owner\":\"$82\",\"value\":\"$@175\"}\n176:[[\"getRoleBySlug\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",94,38,90,1,false],[\"Module.generateMetadata\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",426,169,423,1,false]]\n177:[[\"getRoleBySlug\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",94,38,90,1,false],[\"Module.generateMetadata\",\"/Users/rahuldubey/resumemaker/resume-maker/.next/dev/server/chunks/ssr/app_df139793._.js\",426,169,423,1,false]]\n178:{\"slug\":{\"stringValue\":\"project-manager-resume-india\",\"valueType\":\"stringValue\"},\"job_title\":{\"stringValue\":\"Project Manager\",\"valueType\":\"stringValue\"},\"experience_level\":{\"stringValue\":\"Mid-Senior\",\"valueType\":\"stringValue\"},\"avg_salary_india\":{\"stringValue\":\"â‚¹15L - â‚¹35L\",\"valueType\":\"stringValue\"},\"summary_text\":{\"stringValue\":\"Passionate Project Manager seeking to leverage extensive background in enhancing business performance to contribute to organizational success.\",\"valueType\":\"stringValue\"},\"hard_skills\":{\"arrayValue\":{\"values\":\"$Y\"},\"valueType\":\"arrayValue\"},\"soft_skills\":\"$Y\",\"common_mistakes\":\"$Y\",\"seo_title\":\"$Y\",\"meta_description\":\"$Y\",\"keywords\":\"$Y\",\"faqs\":\"$Y\",\"industry_context\":\"$Y\",\"ats_tips\":\"$Y\",\"day_in_life\":\"$Y\",\"career_path\":\"$Y\",\"salary_breakdown\":\"$Y\",\"top_certifications\":\"$Y\",\"tech_stack_breakdown\":\"$Y\"}\n17b:[\"generated_job_roles\",\"project-manager-resume-india\"]\n17a:{\"segments\":\"$17b\",\"\":\"$P126\"}\n179:{\"_firestore\":\"$8a\",\"_path\":\"$17a\",\"_converter\":\"$127\",\"\":\"$P12b\"}\n17c:{\"_seconds\":1766030868,\"_nanoseconds\":299162000,\"\":\"$P12e\"}\n17d:{\"_seconds\":1765909774,\"_nanoseconds\":674155000,\"\":\"$P12e\"}\n17e:{\"_seconds\":1765909774,\"_nanoseconds\":674155000,\"\":\"$P12e\"}\n175:{\"_fieldsProto\":\"$178\",\"_ref\":\"$179\",\"_serializer\":\"$8d\",\"_readTime\":\"$17c\",\"_createTime\":\"$17d\",\"_updateTime\":\"$17e\",\"\":\"$P132\"}\n17f:[]\n180:[]\n181:[[\"Array.map\",\"\",0,0,0,0,false]]\n182:[]\n183:[]\n184:[[\"Array.map\",\"\",0,0,0,0,false]]\n185:[[\"Array.map\",\"\",0,0,0,0,false]]\n186:[[\"Array.map\",\"\",0,0,0,0,false]]\n187:[[\"Array.map\",\"\",0,0,0,0,false]]\n188:[]\n189:[[\"Array.map\",\"\",0,0,0,0,false]]\n18a:[]\n18b:[]\n18c:[]\n18d:[]\n18e:[]\n18f:[[\"Array.map\",\"\",0,0,0,0,false],[\"Array.map\",\"\",0,0,0,0,false]]\n190:[[\"Array.map\",\"\",0,0,0,0,false],[\"Array.map\",\"\",0,0,0,0,false]]\n191:[[\"Array.map\",\"\",0,0,0,0,false],[\"Array.map\",\"\",0,0,0,0,false]]\n192:[[\"Array.map\",\"\",0,0,0,0,false],[\"Array.map\",\"\",0,0,0,0,false]]\n193:[]\n194:[]\n195:[]\n196:[]\n197:[[\"Array.map\",\"\",0,0,0,0,false],[\"Array.map\",\"\",0,0,0,0,false]]\n198:[[\"Array.map\",\"\",0,0,0,0,false]]\n199:[]\n5b:D{\"time\":46.747082993388176}\n5b:D{\"awaited\":\"$174\",\"env\":\"Server\",\"owner\":\"$46\",\"stack\":\"$176\"}\n5b:D{\"time\":1566.2402919977903}\n4b:D{\"time\":46.747082993388176}\n4b:D{\"awaited\":\"$174\",\"env\":\"Server\",\"owner\":\"$46\",\"stack\":\"$177\"}\n4b:D{\"time\":1566.2402919977903}\n5b:D{\"time\":1569.249207995832}\n"])</script><script>self.__next_f.push([1,"5b:[[\"$\",\"title\",\"0\",{\"children\":\"Project Manager Resume Format (2026) | Download Free Template\"},\"$46\",\"$17f\",0],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Download professional Project Manager resume format. Get salary insights, career path, and expert tips for Project Manager jobs in India.\"},\"$46\",\"$180\",0],[\"$\",\"meta\",\"2\",{\"name\":\"author\",\"content\":\"Nyquist Tech\"},\"$46\",\"$181\",0],[\"$\",\"meta\",\"3\",{\"name\":\"keywords\",\"content\":\"Project Manager resume, Project Manager cv format, resume for Project Manager\"},\"$46\",\"$182\",0],[\"$\",\"meta\",\"4\",{\"name\":\"robots\",\"content\":\"index, follow\"},\"$46\",\"$183\",0],[\"$\",\"meta\",\"5\",{\"name\":\"application-name\",\"content\":\"ResumeGyani\"},\"$46\",\"$184\",0],[\"$\",\"meta\",\"6\",{\"name\":\"msapplication-TileColor\",\"content\":\"#2563eb\"},\"$46\",\"$185\",0],[\"$\",\"meta\",\"7\",{\"name\":\"theme-color\",\"content\":\"#2563eb\"},\"$46\",\"$186\",0],[\"$\",\"meta\",\"8\",{\"name\":\"google\",\"content\":\"notranslate\"},\"$46\",\"$187\",0],[\"$\",\"link\",\"9\",{\"rel\":\"canonical\",\"href\":\"https://resumegyani.in/resume-format-for/project-manager-resume-india\"},\"$46\",\"$188\",0],[\"$\",\"meta\",\"10\",{\"name\":\"google-site-verification\",\"content\":\"MpKSykohaMeXQNw5vcppYGV5L8CMp_Qq32uZsc08Uz8\"},\"$46\",\"$189\",0],[\"$\",\"meta\",\"11\",{\"property\":\"og:title\",\"content\":\"Project Manager Resume Format (2026) | Download Free Template\"},\"$46\",\"$18a\",0],[\"$\",\"meta\",\"12\",{\"property\":\"og:description\",\"content\":\"Download professional Project Manager resume format. Get salary insights, career path, and expert tips for Project Manager jobs in India.\"},\"$46\",\"$18b\",0],[\"$\",\"meta\",\"13\",{\"property\":\"og:url\",\"content\":\"https://resumegyani.in/resume-format-for/project-manager-resume-india\"},\"$46\",\"$18c\",0],[\"$\",\"meta\",\"14\",{\"property\":\"og:site_name\",\"content\":\"ResumeGyani\"},\"$46\",\"$18d\",0],[\"$\",\"meta\",\"15\",{\"property\":\"og:locale\",\"content\":\"en_IN\"},\"$46\",\"$18e\",0],[\"$\",\"meta\",\"16\",{\"property\":\"og:image\",\"content\":\"https://resumegyani.in/resumegyani-logo-blue-transparent.png\"},\"$46\",\"$18f\",0],[\"$\",\"meta\",\"17\",{\"property\":\"og:image:width\",\"content\":\"1200\"},\"$46\",\"$190\",0],[\"$\",\"meta\",\"18\",{\"property\":\"og:image:height\",\"content\":\"630\"},\"$46\",\"$191\",0],[\"$\",\"meta\",\"19\",{\"property\":\"og:image:alt\",\"content\":\"Project Manager Resume Format - ResumeGyani\"},\"$46\",\"$192\",0],[\"$\",\"meta\",\"20\",{\"property\":\"og:type\",\"content\":\"article\"},\"$46\",\"$193\",0],[\"$\",\"meta\",\"21\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"},\"$46\",\"$194\",0],[\"$\",\"meta\",\"22\",{\"name\":\"twitter:title\",\"content\":\"Project Manager Resume Format (2026) | Download Free Template\"},\"$46\",\"$195\",0],[\"$\",\"meta\",\"23\",{\"name\":\"twitter:description\",\"content\":\"Download professional Project Manager resume format. Get salary insights, career path, and expert tips for Project Manager jobs in India.\"},\"$46\",\"$196\",0],[\"$\",\"meta\",\"24\",{\"name\":\"twitter:image\",\"content\":\"https://resumegyani.in/resumegyani-logo-blue-transparent.png\"},\"$46\",\"$197\",0],[\"$\",\"link\",\"25\",{\"rel\":\"icon\",\"href\":\"/favicon.ico?favicon.10566262.ico\",\"sizes\":\"256x256\",\"type\":\"image/x-icon\"},\"$46\",\"$198\",0],[\"$\",\"$L19a\",\"26\",{},\"$46\",\"$199\",0]]\n"])</script><script>self.__next_f.push([1,"4b:D{\"time\":1570.2214169949293}\n4b:null\n"])</script><title>Project Manager Resume Format (2026) | Download Free Template</title><meta name="description" content="Download professional Project Manager resume format. Get salary insights, career path, and expert tips for Project Manager jobs in India."/><meta name="author" content="Nyquist Tech"/><meta name="keywords" content="Project Manager resume, Project Manager cv format, resume for Project Manager"/><meta name="robots" content="index, follow"/><meta name="application-name" content="ResumeGyani"/><meta name="msapplication-TileColor" content="#2563eb"/><meta name="theme-color" content="#2563eb"/><meta name="google" content="notranslate"/><link rel="canonical" href="https://resumegyani.in/resume-format-for/project-manager-resume-india"/><meta name="google-site-verification" content="MpKSykohaMeXQNw5vcppYGV5L8CMp_Qq32uZsc08Uz8"/><meta property="og:title" content="Project Manager Resume Format (2026) | Download Free Template"/><meta property="og:description" content="Download professional Project Manager resume format. Get salary insights, career path, and expert tips for Project Manager jobs in India."/><meta property="og:url" content="https://resumegyani.in/resume-format-for/project-manager-resume-india"/><meta property="og:site_name" content="ResumeGyani"/><meta property="og:locale" content="en_IN"/><meta property="og:image" content="https://resumegyani.in/resumegyani-logo-blue-transparent.png"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:alt" content="Project Manager Resume Format - ResumeGyani"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Project Manager Resume Format (2026) | Download Free Template"/><meta name="twitter:description" content="Download professional Project Manager resume format. Get salary insights, career path, and expert tips for Project Manager jobs in India."/><meta name="twitter:image" content="https://resumegyani.in/resumegyani-logo-blue-transparent.png"/><link rel="icon" href="/favicon.ico?favicon.10566262.ico" sizes="256x256" type="image/x-icon"/><script >document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><div hidden id="S:0"></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"></div><script>$RC("B:1","S:1")</script></body></html>